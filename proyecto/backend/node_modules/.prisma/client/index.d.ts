
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model TokenSesion
 * 
 */
export type TokenSesion = $Result.DefaultSelection<Prisma.$TokenSesionPayload>
/**
 * Model Estudiante
 * 
 */
export type Estudiante = $Result.DefaultSelection<Prisma.$EstudiantePayload>
/**
 * Model Carrera
 * 
 */
export type Carrera = $Result.DefaultSelection<Prisma.$CarreraPayload>
/**
 * Model Materia
 * 
 */
export type Materia = $Result.DefaultSelection<Prisma.$MateriaPayload>
/**
 * Model Grupo
 * 
 */
export type Grupo = $Result.DefaultSelection<Prisma.$GrupoPayload>
/**
 * Model Inscripcion
 * 
 */
export type Inscripcion = $Result.DefaultSelection<Prisma.$InscripcionPayload>
/**
 * Model Calificacion
 * 
 */
export type Calificacion = $Result.DefaultSelection<Prisma.$CalificacionPayload>
/**
 * Model Profesor
 * 
 */
export type Profesor = $Result.DefaultSelection<Prisma.$ProfesorPayload>
/**
 * Model Administrador
 * 
 */
export type Administrador = $Result.DefaultSelection<Prisma.$AdministradorPayload>
/**
 * Model Documento
 * 
 */
export type Documento = $Result.DefaultSelection<Prisma.$DocumentoPayload>
/**
 * Model DocumentoEstudiante
 * 
 */
export type DocumentoEstudiante = $Result.DefaultSelection<Prisma.$DocumentoEstudiantePayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model ActividadUsuario
 * 
 */
export type ActividadUsuario = $Result.DefaultSelection<Prisma.$ActividadUsuarioPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMINISTRADOR: 'ADMINISTRADOR',
  PROFESOR: 'PROFESOR',
  ESTUDIANTE: 'ESTUDIANTE',
  PERSONAL_ADMINISTRATIVO: 'PERSONAL_ADMINISTRATIVO'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const TipoToken: {
  ACCESS: 'ACCESS',
  REFRESH: 'REFRESH',
  RESET_PASSWORD: 'RESET_PASSWORD',
  VERIFY_EMAIL: 'VERIFY_EMAIL'
};

export type TipoToken = (typeof TipoToken)[keyof typeof TipoToken]


export const EstatusEstudiante: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO',
  EGRESADO: 'EGRESADO',
  BAJA_TEMPORAL: 'BAJA_TEMPORAL',
  BAJA_DEFINITIVA: 'BAJA_DEFINITIVA'
};

export type EstatusEstudiante = (typeof EstatusEstudiante)[keyof typeof EstatusEstudiante]


export const Modalidad: {
  PRESENCIAL: 'PRESENCIAL',
  EN_LINEA: 'EN_LINEA',
  MIXTA: 'MIXTA'
};

export type Modalidad = (typeof Modalidad)[keyof typeof Modalidad]


export const EstatusInscripcion: {
  INSCRITO: 'INSCRITO',
  CURSANDO: 'CURSANDO',
  APROBADO: 'APROBADO',
  REPROBADO: 'REPROBADO',
  BAJA: 'BAJA'
};

export type EstatusInscripcion = (typeof EstatusInscripcion)[keyof typeof EstatusInscripcion]


export const TipoDocumento: {
  KARDEX: 'KARDEX',
  FICHA_REINSCRIPCION: 'FICHA_REINSCRIPCION',
  COMPROBANTE_PAGO: 'COMPROBANTE_PAGO'
};

export type TipoDocumento = (typeof TipoDocumento)[keyof typeof TipoDocumento]


export const EstatusDocumento: {
  PENDIENTE: 'PENDIENTE',
  EN_REVISION: 'EN_REVISION',
  APROBADO: 'APROBADO',
  RECHAZADO: 'RECHAZADO',
  VENCIDO: 'VENCIDO',
  ANULADO: 'ANULADO'
};

export type EstatusDocumento = (typeof EstatusDocumento)[keyof typeof EstatusDocumento]


export const TipoNotificacion: {
  DOCUMENTO_APROBADO: 'DOCUMENTO_APROBADO',
  DOCUMENTO_RECHAZADO: 'DOCUMENTO_RECHAZADO',
  DOCUMENTO_PENDIENTE: 'DOCUMENTO_PENDIENTE',
  GENERAL: 'GENERAL'
};

export type TipoNotificacion = (typeof TipoNotificacion)[keyof typeof TipoNotificacion]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type TipoToken = $Enums.TipoToken

export const TipoToken: typeof $Enums.TipoToken

export type EstatusEstudiante = $Enums.EstatusEstudiante

export const EstatusEstudiante: typeof $Enums.EstatusEstudiante

export type Modalidad = $Enums.Modalidad

export const Modalidad: typeof $Enums.Modalidad

export type EstatusInscripcion = $Enums.EstatusInscripcion

export const EstatusInscripcion: typeof $Enums.EstatusInscripcion

export type TipoDocumento = $Enums.TipoDocumento

export const TipoDocumento: typeof $Enums.TipoDocumento

export type EstatusDocumento = $Enums.EstatusDocumento

export const EstatusDocumento: typeof $Enums.EstatusDocumento

export type TipoNotificacion = $Enums.TipoNotificacion

export const TipoNotificacion: typeof $Enums.TipoNotificacion

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokenSesion`: Exposes CRUD operations for the **TokenSesion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenSesions
    * const tokenSesions = await prisma.tokenSesion.findMany()
    * ```
    */
  get tokenSesion(): Prisma.TokenSesionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estudiante`: Exposes CRUD operations for the **Estudiante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiante.findMany()
    * ```
    */
  get estudiante(): Prisma.EstudianteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carrera`: Exposes CRUD operations for the **Carrera** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carreras
    * const carreras = await prisma.carrera.findMany()
    * ```
    */
  get carrera(): Prisma.CarreraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materia`: Exposes CRUD operations for the **Materia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materias
    * const materias = await prisma.materia.findMany()
    * ```
    */
  get materia(): Prisma.MateriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grupo`: Exposes CRUD operations for the **Grupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grupos
    * const grupos = await prisma.grupo.findMany()
    * ```
    */
  get grupo(): Prisma.GrupoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscripcion`: Exposes CRUD operations for the **Inscripcion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscripcions
    * const inscripcions = await prisma.inscripcion.findMany()
    * ```
    */
  get inscripcion(): Prisma.InscripcionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calificacion`: Exposes CRUD operations for the **Calificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calificacions
    * const calificacions = await prisma.calificacion.findMany()
    * ```
    */
  get calificacion(): Prisma.CalificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profesor`: Exposes CRUD operations for the **Profesor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profesors
    * const profesors = await prisma.profesor.findMany()
    * ```
    */
  get profesor(): Prisma.ProfesorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.administrador`: Exposes CRUD operations for the **Administrador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administradors
    * const administradors = await prisma.administrador.findMany()
    * ```
    */
  get administrador(): Prisma.AdministradorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documento`: Exposes CRUD operations for the **Documento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentos
    * const documentos = await prisma.documento.findMany()
    * ```
    */
  get documento(): Prisma.DocumentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentoEstudiante`: Exposes CRUD operations for the **DocumentoEstudiante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentoEstudiantes
    * const documentoEstudiantes = await prisma.documentoEstudiante.findMany()
    * ```
    */
  get documentoEstudiante(): Prisma.DocumentoEstudianteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actividadUsuario`: Exposes CRUD operations for the **ActividadUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActividadUsuarios
    * const actividadUsuarios = await prisma.actividadUsuario.findMany()
    * ```
    */
  get actividadUsuario(): Prisma.ActividadUsuarioDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.3
   * Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    TokenSesion: 'TokenSesion',
    Estudiante: 'Estudiante',
    Carrera: 'Carrera',
    Materia: 'Materia',
    Grupo: 'Grupo',
    Inscripcion: 'Inscripcion',
    Calificacion: 'Calificacion',
    Profesor: 'Profesor',
    Administrador: 'Administrador',
    Documento: 'Documento',
    DocumentoEstudiante: 'DocumentoEstudiante',
    Notificacion: 'Notificacion',
    ActividadUsuario: 'ActividadUsuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "usuario" | "tokenSesion" | "estudiante" | "carrera" | "materia" | "grupo" | "inscripcion" | "calificacion" | "profesor" | "administrador" | "documento" | "documentoEstudiante" | "notificacion" | "actividadUsuario"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      TokenSesion: {
        payload: Prisma.$TokenSesionPayload<ExtArgs>
        fields: Prisma.TokenSesionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenSesionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenSesionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>
          }
          findFirst: {
            args: Prisma.TokenSesionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenSesionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>
          }
          findMany: {
            args: Prisma.TokenSesionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>[]
          }
          create: {
            args: Prisma.TokenSesionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>
          }
          createMany: {
            args: Prisma.TokenSesionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenSesionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>[]
          }
          delete: {
            args: Prisma.TokenSesionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>
          }
          update: {
            args: Prisma.TokenSesionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>
          }
          deleteMany: {
            args: Prisma.TokenSesionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenSesionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenSesionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>[]
          }
          upsert: {
            args: Prisma.TokenSesionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenSesionPayload>
          }
          aggregate: {
            args: Prisma.TokenSesionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenSesion>
          }
          groupBy: {
            args: Prisma.TokenSesionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenSesionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenSesionCountArgs<ExtArgs>
            result: $Utils.Optional<TokenSesionCountAggregateOutputType> | number
          }
        }
      }
      Estudiante: {
        payload: Prisma.$EstudiantePayload<ExtArgs>
        fields: Prisma.EstudianteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudianteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudianteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findFirst: {
            args: Prisma.EstudianteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudianteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findMany: {
            args: Prisma.EstudianteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          create: {
            args: Prisma.EstudianteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          createMany: {
            args: Prisma.EstudianteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstudianteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          delete: {
            args: Prisma.EstudianteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          update: {
            args: Prisma.EstudianteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          deleteMany: {
            args: Prisma.EstudianteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudianteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EstudianteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          upsert: {
            args: Prisma.EstudianteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          aggregate: {
            args: Prisma.EstudianteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiante>
          }
          groupBy: {
            args: Prisma.EstudianteGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudianteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudianteCountArgs<ExtArgs>
            result: $Utils.Optional<EstudianteCountAggregateOutputType> | number
          }
        }
      }
      Carrera: {
        payload: Prisma.$CarreraPayload<ExtArgs>
        fields: Prisma.CarreraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarreraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarreraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          findFirst: {
            args: Prisma.CarreraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarreraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          findMany: {
            args: Prisma.CarreraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>[]
          }
          create: {
            args: Prisma.CarreraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          createMany: {
            args: Prisma.CarreraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarreraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>[]
          }
          delete: {
            args: Prisma.CarreraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          update: {
            args: Prisma.CarreraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          deleteMany: {
            args: Prisma.CarreraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarreraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarreraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>[]
          }
          upsert: {
            args: Prisma.CarreraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          aggregate: {
            args: Prisma.CarreraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarrera>
          }
          groupBy: {
            args: Prisma.CarreraGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarreraGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarreraCountArgs<ExtArgs>
            result: $Utils.Optional<CarreraCountAggregateOutputType> | number
          }
        }
      }
      Materia: {
        payload: Prisma.$MateriaPayload<ExtArgs>
        fields: Prisma.MateriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MateriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MateriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          findFirst: {
            args: Prisma.MateriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MateriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          findMany: {
            args: Prisma.MateriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          create: {
            args: Prisma.MateriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          createMany: {
            args: Prisma.MateriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MateriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          delete: {
            args: Prisma.MateriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          update: {
            args: Prisma.MateriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          deleteMany: {
            args: Prisma.MateriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MateriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MateriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          upsert: {
            args: Prisma.MateriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          aggregate: {
            args: Prisma.MateriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateria>
          }
          groupBy: {
            args: Prisma.MateriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MateriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MateriaCountArgs<ExtArgs>
            result: $Utils.Optional<MateriaCountAggregateOutputType> | number
          }
        }
      }
      Grupo: {
        payload: Prisma.$GrupoPayload<ExtArgs>
        fields: Prisma.GrupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GrupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GrupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          findFirst: {
            args: Prisma.GrupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GrupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          findMany: {
            args: Prisma.GrupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>[]
          }
          create: {
            args: Prisma.GrupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          createMany: {
            args: Prisma.GrupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GrupoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>[]
          }
          delete: {
            args: Prisma.GrupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          update: {
            args: Prisma.GrupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          deleteMany: {
            args: Prisma.GrupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GrupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GrupoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>[]
          }
          upsert: {
            args: Prisma.GrupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          aggregate: {
            args: Prisma.GrupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrupo>
          }
          groupBy: {
            args: Prisma.GrupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GrupoCountArgs<ExtArgs>
            result: $Utils.Optional<GrupoCountAggregateOutputType> | number
          }
        }
      }
      Inscripcion: {
        payload: Prisma.$InscripcionPayload<ExtArgs>
        fields: Prisma.InscripcionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InscripcionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InscripcionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          findFirst: {
            args: Prisma.InscripcionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InscripcionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          findMany: {
            args: Prisma.InscripcionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[]
          }
          create: {
            args: Prisma.InscripcionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          createMany: {
            args: Prisma.InscripcionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InscripcionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[]
          }
          delete: {
            args: Prisma.InscripcionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          update: {
            args: Prisma.InscripcionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          deleteMany: {
            args: Prisma.InscripcionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InscripcionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InscripcionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[]
          }
          upsert: {
            args: Prisma.InscripcionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          aggregate: {
            args: Prisma.InscripcionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscripcion>
          }
          groupBy: {
            args: Prisma.InscripcionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InscripcionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InscripcionCountArgs<ExtArgs>
            result: $Utils.Optional<InscripcionCountAggregateOutputType> | number
          }
        }
      }
      Calificacion: {
        payload: Prisma.$CalificacionPayload<ExtArgs>
        fields: Prisma.CalificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          findFirst: {
            args: Prisma.CalificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          findMany: {
            args: Prisma.CalificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>[]
          }
          create: {
            args: Prisma.CalificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          createMany: {
            args: Prisma.CalificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalificacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>[]
          }
          delete: {
            args: Prisma.CalificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          update: {
            args: Prisma.CalificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          deleteMany: {
            args: Prisma.CalificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalificacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>[]
          }
          upsert: {
            args: Prisma.CalificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          aggregate: {
            args: Prisma.CalificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalificacion>
          }
          groupBy: {
            args: Prisma.CalificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalificacionCountArgs<ExtArgs>
            result: $Utils.Optional<CalificacionCountAggregateOutputType> | number
          }
        }
      }
      Profesor: {
        payload: Prisma.$ProfesorPayload<ExtArgs>
        fields: Prisma.ProfesorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfesorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfesorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          findFirst: {
            args: Prisma.ProfesorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfesorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          findMany: {
            args: Prisma.ProfesorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          create: {
            args: Prisma.ProfesorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          createMany: {
            args: Prisma.ProfesorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfesorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          delete: {
            args: Prisma.ProfesorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          update: {
            args: Prisma.ProfesorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          deleteMany: {
            args: Prisma.ProfesorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfesorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfesorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          upsert: {
            args: Prisma.ProfesorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          aggregate: {
            args: Prisma.ProfesorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfesor>
          }
          groupBy: {
            args: Prisma.ProfesorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfesorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfesorCountArgs<ExtArgs>
            result: $Utils.Optional<ProfesorCountAggregateOutputType> | number
          }
        }
      }
      Administrador: {
        payload: Prisma.$AdministradorPayload<ExtArgs>
        fields: Prisma.AdministradorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdministradorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdministradorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>
          }
          findFirst: {
            args: Prisma.AdministradorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdministradorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>
          }
          findMany: {
            args: Prisma.AdministradorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>[]
          }
          create: {
            args: Prisma.AdministradorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>
          }
          createMany: {
            args: Prisma.AdministradorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdministradorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>[]
          }
          delete: {
            args: Prisma.AdministradorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>
          }
          update: {
            args: Prisma.AdministradorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>
          }
          deleteMany: {
            args: Prisma.AdministradorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdministradorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdministradorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>[]
          }
          upsert: {
            args: Prisma.AdministradorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministradorPayload>
          }
          aggregate: {
            args: Prisma.AdministradorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrador>
          }
          groupBy: {
            args: Prisma.AdministradorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministradorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdministradorCountArgs<ExtArgs>
            result: $Utils.Optional<AdministradorCountAggregateOutputType> | number
          }
        }
      }
      Documento: {
        payload: Prisma.$DocumentoPayload<ExtArgs>
        fields: Prisma.DocumentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          findFirst: {
            args: Prisma.DocumentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          findMany: {
            args: Prisma.DocumentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>[]
          }
          create: {
            args: Prisma.DocumentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          createMany: {
            args: Prisma.DocumentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>[]
          }
          delete: {
            args: Prisma.DocumentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          update: {
            args: Prisma.DocumentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          deleteMany: {
            args: Prisma.DocumentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>[]
          }
          upsert: {
            args: Prisma.DocumentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          aggregate: {
            args: Prisma.DocumentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumento>
          }
          groupBy: {
            args: Prisma.DocumentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentoCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentoCountAggregateOutputType> | number
          }
        }
      }
      DocumentoEstudiante: {
        payload: Prisma.$DocumentoEstudiantePayload<ExtArgs>
        fields: Prisma.DocumentoEstudianteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentoEstudianteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentoEstudianteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>
          }
          findFirst: {
            args: Prisma.DocumentoEstudianteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentoEstudianteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>
          }
          findMany: {
            args: Prisma.DocumentoEstudianteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>[]
          }
          create: {
            args: Prisma.DocumentoEstudianteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>
          }
          createMany: {
            args: Prisma.DocumentoEstudianteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentoEstudianteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>[]
          }
          delete: {
            args: Prisma.DocumentoEstudianteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>
          }
          update: {
            args: Prisma.DocumentoEstudianteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>
          }
          deleteMany: {
            args: Prisma.DocumentoEstudianteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentoEstudianteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentoEstudianteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>[]
          }
          upsert: {
            args: Prisma.DocumentoEstudianteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoEstudiantePayload>
          }
          aggregate: {
            args: Prisma.DocumentoEstudianteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentoEstudiante>
          }
          groupBy: {
            args: Prisma.DocumentoEstudianteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentoEstudianteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentoEstudianteCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentoEstudianteCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      ActividadUsuario: {
        payload: Prisma.$ActividadUsuarioPayload<ExtArgs>
        fields: Prisma.ActividadUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActividadUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActividadUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>
          }
          findFirst: {
            args: Prisma.ActividadUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActividadUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>
          }
          findMany: {
            args: Prisma.ActividadUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>[]
          }
          create: {
            args: Prisma.ActividadUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>
          }
          createMany: {
            args: Prisma.ActividadUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActividadUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>[]
          }
          delete: {
            args: Prisma.ActividadUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>
          }
          update: {
            args: Prisma.ActividadUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.ActividadUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActividadUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActividadUsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>[]
          }
          upsert: {
            args: Prisma.ActividadUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadUsuarioPayload>
          }
          aggregate: {
            args: Prisma.ActividadUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActividadUsuario>
          }
          groupBy: {
            args: Prisma.ActividadUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActividadUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActividadUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<ActividadUsuarioCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit
    tokenSesion?: TokenSesionOmit
    estudiante?: EstudianteOmit
    carrera?: CarreraOmit
    materia?: MateriaOmit
    grupo?: GrupoOmit
    inscripcion?: InscripcionOmit
    calificacion?: CalificacionOmit
    profesor?: ProfesorOmit
    administrador?: AdministradorOmit
    documento?: DocumentoOmit
    documentoEstudiante?: DocumentoEstudianteOmit
    notificacion?: NotificacionOmit
    actividadUsuario?: ActividadUsuarioOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    tokens: number
    actividades: number
    documentosCreados: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | UsuarioCountOutputTypeCountTokensArgs
    actividades?: boolean | UsuarioCountOutputTypeCountActividadesArgs
    documentosCreados?: boolean | UsuarioCountOutputTypeCountDocumentosCreadosArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenSesionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountActividadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadUsuarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDocumentosCreadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
  }


  /**
   * Count Type EstudianteCountOutputType
   */

  export type EstudianteCountOutputType = {
    inscripciones: number
    calificaciones: number
    documentos: number
    notificaciones: number
  }

  export type EstudianteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripciones?: boolean | EstudianteCountOutputTypeCountInscripcionesArgs
    calificaciones?: boolean | EstudianteCountOutputTypeCountCalificacionesArgs
    documentos?: boolean | EstudianteCountOutputTypeCountDocumentosArgs
    notificaciones?: boolean | EstudianteCountOutputTypeCountNotificacionesArgs
  }

  // Custom InputTypes
  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteCountOutputType
     */
    select?: EstudianteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountCalificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalificacionWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountDocumentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoEstudianteWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountNotificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
  }


  /**
   * Count Type CarreraCountOutputType
   */

  export type CarreraCountOutputType = {
    estudiantes: number
    materias: number
  }

  export type CarreraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | CarreraCountOutputTypeCountEstudiantesArgs
    materias?: boolean | CarreraCountOutputTypeCountMateriasArgs
  }

  // Custom InputTypes
  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarreraCountOutputType
     */
    select?: CarreraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeCountEstudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteWhereInput
  }

  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeCountMateriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriaWhereInput
  }


  /**
   * Count Type MateriaCountOutputType
   */

  export type MateriaCountOutputType = {
    grupos: number
    calificaciones: number
  }

  export type MateriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupos?: boolean | MateriaCountOutputTypeCountGruposArgs
    calificaciones?: boolean | MateriaCountOutputTypeCountCalificacionesArgs
  }

  // Custom InputTypes
  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MateriaCountOutputType
     */
    select?: MateriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeCountGruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrupoWhereInput
  }

  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeCountCalificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalificacionWhereInput
  }


  /**
   * Count Type GrupoCountOutputType
   */

  export type GrupoCountOutputType = {
    inscripciones: number
  }

  export type GrupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripciones?: boolean | GrupoCountOutputTypeCountInscripcionesArgs
  }

  // Custom InputTypes
  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrupoCountOutputType
     */
    select?: GrupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
  }


  /**
   * Count Type ProfesorCountOutputType
   */

  export type ProfesorCountOutputType = {
    grupos: number
  }

  export type ProfesorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupos?: boolean | ProfesorCountOutputTypeCountGruposArgs
  }

  // Custom InputTypes
  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesorCountOutputType
     */
    select?: ProfesorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeCountGruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrupoWhereInput
  }


  /**
   * Count Type DocumentoCountOutputType
   */

  export type DocumentoCountOutputType = {
    documentosEstudiante: number
  }

  export type DocumentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentosEstudiante?: boolean | DocumentoCountOutputTypeCountDocumentosEstudianteArgs
  }

  // Custom InputTypes
  /**
   * DocumentoCountOutputType without action
   */
  export type DocumentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoCountOutputType
     */
    select?: DocumentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentoCountOutputType without action
   */
  export type DocumentoCountOutputTypeCountDocumentosEstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoEstudianteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    intentosFallidos: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    intentosFallidos: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nombre: string | null
    apellidoPaterno: string | null
    apellidoMaterno: string | null
    telefono: string | null
    rol: $Enums.Rol | null
    activo: boolean | null
    emailVerificado: boolean | null
    primerLogin: boolean | null
    intentosFallidos: number | null
    bloqueadoHasta: Date | null
    ultimoAcceso: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nombre: string | null
    apellidoPaterno: string | null
    apellidoMaterno: string | null
    telefono: string | null
    rol: $Enums.Rol | null
    activo: boolean | null
    emailVerificado: boolean | null
    primerLogin: boolean | null
    intentosFallidos: number | null
    bloqueadoHasta: Date | null
    ultimoAcceso: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    email: number
    password: number
    nombre: number
    apellidoPaterno: number
    apellidoMaterno: number
    telefono: number
    rol: number
    activo: number
    emailVerificado: number
    primerLogin: number
    intentosFallidos: number
    bloqueadoHasta: number
    ultimoAcceso: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    intentosFallidos?: true
  }

  export type UsuarioSumAggregateInputType = {
    intentosFallidos?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    apellidoPaterno?: true
    apellidoMaterno?: true
    telefono?: true
    rol?: true
    activo?: true
    emailVerificado?: true
    primerLogin?: true
    intentosFallidos?: true
    bloqueadoHasta?: true
    ultimoAcceso?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    apellidoPaterno?: true
    apellidoMaterno?: true
    telefono?: true
    rol?: true
    activo?: true
    emailVerificado?: true
    primerLogin?: true
    intentosFallidos?: true
    bloqueadoHasta?: true
    ultimoAcceso?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    apellidoPaterno?: true
    apellidoMaterno?: true
    telefono?: true
    rol?: true
    activo?: true
    emailVerificado?: true
    primerLogin?: true
    intentosFallidos?: true
    bloqueadoHasta?: true
    ultimoAcceso?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno: string | null
    telefono: string | null
    rol: $Enums.Rol
    activo: boolean
    emailVerificado: boolean
    primerLogin: boolean
    intentosFallidos: number
    bloqueadoHasta: Date | null
    ultimoAcceso: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    apellidoPaterno?: boolean
    apellidoMaterno?: boolean
    telefono?: boolean
    rol?: boolean
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | Usuario$estudianteArgs<ExtArgs>
    profesor?: boolean | Usuario$profesorArgs<ExtArgs>
    administrador?: boolean | Usuario$administradorArgs<ExtArgs>
    tokens?: boolean | Usuario$tokensArgs<ExtArgs>
    actividades?: boolean | Usuario$actividadesArgs<ExtArgs>
    documentosCreados?: boolean | Usuario$documentosCreadosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    apellidoPaterno?: boolean
    apellidoMaterno?: boolean
    telefono?: boolean
    rol?: boolean
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    apellidoPaterno?: boolean
    apellidoMaterno?: boolean
    telefono?: boolean
    rol?: boolean
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    apellidoPaterno?: boolean
    apellidoMaterno?: boolean
    telefono?: boolean
    rol?: boolean
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "nombre" | "apellidoPaterno" | "apellidoMaterno" | "telefono" | "rol" | "activo" | "emailVerificado" | "primerLogin" | "intentosFallidos" | "bloqueadoHasta" | "ultimoAcceso" | "createdAt" | "updatedAt", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | Usuario$estudianteArgs<ExtArgs>
    profesor?: boolean | Usuario$profesorArgs<ExtArgs>
    administrador?: boolean | Usuario$administradorArgs<ExtArgs>
    tokens?: boolean | Usuario$tokensArgs<ExtArgs>
    actividades?: boolean | Usuario$actividadesArgs<ExtArgs>
    documentosCreados?: boolean | Usuario$documentosCreadosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
      profesor: Prisma.$ProfesorPayload<ExtArgs> | null
      administrador: Prisma.$AdministradorPayload<ExtArgs> | null
      tokens: Prisma.$TokenSesionPayload<ExtArgs>[]
      actividades: Prisma.$ActividadUsuarioPayload<ExtArgs>[]
      documentosCreados: Prisma.$DocumentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      nombre: string
      apellidoPaterno: string
      apellidoMaterno: string | null
      telefono: string | null
      rol: $Enums.Rol
      activo: boolean
      emailVerificado: boolean
      primerLogin: boolean
      intentosFallidos: number
      bloqueadoHasta: Date | null
      ultimoAcceso: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends Usuario$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$estudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profesor<T extends Usuario$profesorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$profesorArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    administrador<T extends Usuario$administradorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$administradorArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tokens<T extends Usuario$tokensArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actividades<T extends Usuario$actividadesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$actividadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentosCreados<T extends Usuario$documentosCreadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$documentosCreadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellidoPaterno: FieldRef<"Usuario", 'String'>
    readonly apellidoMaterno: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly activo: FieldRef<"Usuario", 'Boolean'>
    readonly emailVerificado: FieldRef<"Usuario", 'Boolean'>
    readonly primerLogin: FieldRef<"Usuario", 'Boolean'>
    readonly intentosFallidos: FieldRef<"Usuario", 'Int'>
    readonly bloqueadoHasta: FieldRef<"Usuario", 'DateTime'>
    readonly ultimoAcceso: FieldRef<"Usuario", 'DateTime'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.estudiante
   */
  export type Usuario$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * Usuario.profesor
   */
  export type Usuario$profesorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    where?: ProfesorWhereInput
  }

  /**
   * Usuario.administrador
   */
  export type Usuario$administradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    where?: AdministradorWhereInput
  }

  /**
   * Usuario.tokens
   */
  export type Usuario$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    where?: TokenSesionWhereInput
    orderBy?: TokenSesionOrderByWithRelationInput | TokenSesionOrderByWithRelationInput[]
    cursor?: TokenSesionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenSesionScalarFieldEnum | TokenSesionScalarFieldEnum[]
  }

  /**
   * Usuario.actividades
   */
  export type Usuario$actividadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    where?: ActividadUsuarioWhereInput
    orderBy?: ActividadUsuarioOrderByWithRelationInput | ActividadUsuarioOrderByWithRelationInput[]
    cursor?: ActividadUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActividadUsuarioScalarFieldEnum | ActividadUsuarioScalarFieldEnum[]
  }

  /**
   * Usuario.documentosCreados
   */
  export type Usuario$documentosCreadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    cursor?: DocumentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model TokenSesion
   */

  export type AggregateTokenSesion = {
    _count: TokenSesionCountAggregateOutputType | null
    _min: TokenSesionMinAggregateOutputType | null
    _max: TokenSesionMaxAggregateOutputType | null
  }

  export type TokenSesionMinAggregateOutputType = {
    id: string | null
    token: string | null
    tipo: $Enums.TipoToken | null
    expiraEn: Date | null
    revocado: boolean | null
    ipAddress: string | null
    userAgent: string | null
    usuarioId: string | null
    createdAt: Date | null
  }

  export type TokenSesionMaxAggregateOutputType = {
    id: string | null
    token: string | null
    tipo: $Enums.TipoToken | null
    expiraEn: Date | null
    revocado: boolean | null
    ipAddress: string | null
    userAgent: string | null
    usuarioId: string | null
    createdAt: Date | null
  }

  export type TokenSesionCountAggregateOutputType = {
    id: number
    token: number
    tipo: number
    expiraEn: number
    revocado: number
    ipAddress: number
    userAgent: number
    usuarioId: number
    createdAt: number
    _all: number
  }


  export type TokenSesionMinAggregateInputType = {
    id?: true
    token?: true
    tipo?: true
    expiraEn?: true
    revocado?: true
    ipAddress?: true
    userAgent?: true
    usuarioId?: true
    createdAt?: true
  }

  export type TokenSesionMaxAggregateInputType = {
    id?: true
    token?: true
    tipo?: true
    expiraEn?: true
    revocado?: true
    ipAddress?: true
    userAgent?: true
    usuarioId?: true
    createdAt?: true
  }

  export type TokenSesionCountAggregateInputType = {
    id?: true
    token?: true
    tipo?: true
    expiraEn?: true
    revocado?: true
    ipAddress?: true
    userAgent?: true
    usuarioId?: true
    createdAt?: true
    _all?: true
  }

  export type TokenSesionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenSesion to aggregate.
     */
    where?: TokenSesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenSesions to fetch.
     */
    orderBy?: TokenSesionOrderByWithRelationInput | TokenSesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenSesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenSesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenSesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenSesions
    **/
    _count?: true | TokenSesionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenSesionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenSesionMaxAggregateInputType
  }

  export type GetTokenSesionAggregateType<T extends TokenSesionAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenSesion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenSesion[P]>
      : GetScalarType<T[P], AggregateTokenSesion[P]>
  }




  export type TokenSesionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenSesionWhereInput
    orderBy?: TokenSesionOrderByWithAggregationInput | TokenSesionOrderByWithAggregationInput[]
    by: TokenSesionScalarFieldEnum[] | TokenSesionScalarFieldEnum
    having?: TokenSesionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenSesionCountAggregateInputType | true
    _min?: TokenSesionMinAggregateInputType
    _max?: TokenSesionMaxAggregateInputType
  }

  export type TokenSesionGroupByOutputType = {
    id: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date
    revocado: boolean
    ipAddress: string | null
    userAgent: string | null
    usuarioId: string
    createdAt: Date
    _count: TokenSesionCountAggregateOutputType | null
    _min: TokenSesionMinAggregateOutputType | null
    _max: TokenSesionMaxAggregateOutputType | null
  }

  type GetTokenSesionGroupByPayload<T extends TokenSesionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenSesionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenSesionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenSesionGroupByOutputType[P]>
            : GetScalarType<T[P], TokenSesionGroupByOutputType[P]>
        }
      >
    >


  export type TokenSesionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    tipo?: boolean
    expiraEn?: boolean
    revocado?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenSesion"]>

  export type TokenSesionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    tipo?: boolean
    expiraEn?: boolean
    revocado?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenSesion"]>

  export type TokenSesionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    tipo?: boolean
    expiraEn?: boolean
    revocado?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenSesion"]>

  export type TokenSesionSelectScalar = {
    id?: boolean
    token?: boolean
    tipo?: boolean
    expiraEn?: boolean
    revocado?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
  }

  export type TokenSesionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "tipo" | "expiraEn" | "revocado" | "ipAddress" | "userAgent" | "usuarioId" | "createdAt", ExtArgs["result"]["tokenSesion"]>
  export type TokenSesionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type TokenSesionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type TokenSesionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $TokenSesionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenSesion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      tipo: $Enums.TipoToken
      expiraEn: Date
      revocado: boolean
      ipAddress: string | null
      userAgent: string | null
      usuarioId: string
      createdAt: Date
    }, ExtArgs["result"]["tokenSesion"]>
    composites: {}
  }

  type TokenSesionGetPayload<S extends boolean | null | undefined | TokenSesionDefaultArgs> = $Result.GetResult<Prisma.$TokenSesionPayload, S>

  type TokenSesionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenSesionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenSesionCountAggregateInputType | true
    }

  export interface TokenSesionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenSesion'], meta: { name: 'TokenSesion' } }
    /**
     * Find zero or one TokenSesion that matches the filter.
     * @param {TokenSesionFindUniqueArgs} args - Arguments to find a TokenSesion
     * @example
     * // Get one TokenSesion
     * const tokenSesion = await prisma.tokenSesion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenSesionFindUniqueArgs>(args: SelectSubset<T, TokenSesionFindUniqueArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TokenSesion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenSesionFindUniqueOrThrowArgs} args - Arguments to find a TokenSesion
     * @example
     * // Get one TokenSesion
     * const tokenSesion = await prisma.tokenSesion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenSesionFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenSesionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenSesion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionFindFirstArgs} args - Arguments to find a TokenSesion
     * @example
     * // Get one TokenSesion
     * const tokenSesion = await prisma.tokenSesion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenSesionFindFirstArgs>(args?: SelectSubset<T, TokenSesionFindFirstArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenSesion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionFindFirstOrThrowArgs} args - Arguments to find a TokenSesion
     * @example
     * // Get one TokenSesion
     * const tokenSesion = await prisma.tokenSesion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenSesionFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenSesionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TokenSesions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenSesions
     * const tokenSesions = await prisma.tokenSesion.findMany()
     * 
     * // Get first 10 TokenSesions
     * const tokenSesions = await prisma.tokenSesion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenSesionWithIdOnly = await prisma.tokenSesion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenSesionFindManyArgs>(args?: SelectSubset<T, TokenSesionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TokenSesion.
     * @param {TokenSesionCreateArgs} args - Arguments to create a TokenSesion.
     * @example
     * // Create one TokenSesion
     * const TokenSesion = await prisma.tokenSesion.create({
     *   data: {
     *     // ... data to create a TokenSesion
     *   }
     * })
     * 
     */
    create<T extends TokenSesionCreateArgs>(args: SelectSubset<T, TokenSesionCreateArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TokenSesions.
     * @param {TokenSesionCreateManyArgs} args - Arguments to create many TokenSesions.
     * @example
     * // Create many TokenSesions
     * const tokenSesion = await prisma.tokenSesion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenSesionCreateManyArgs>(args?: SelectSubset<T, TokenSesionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenSesions and returns the data saved in the database.
     * @param {TokenSesionCreateManyAndReturnArgs} args - Arguments to create many TokenSesions.
     * @example
     * // Create many TokenSesions
     * const tokenSesion = await prisma.tokenSesion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenSesions and only return the `id`
     * const tokenSesionWithIdOnly = await prisma.tokenSesion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenSesionCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenSesionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TokenSesion.
     * @param {TokenSesionDeleteArgs} args - Arguments to delete one TokenSesion.
     * @example
     * // Delete one TokenSesion
     * const TokenSesion = await prisma.tokenSesion.delete({
     *   where: {
     *     // ... filter to delete one TokenSesion
     *   }
     * })
     * 
     */
    delete<T extends TokenSesionDeleteArgs>(args: SelectSubset<T, TokenSesionDeleteArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TokenSesion.
     * @param {TokenSesionUpdateArgs} args - Arguments to update one TokenSesion.
     * @example
     * // Update one TokenSesion
     * const tokenSesion = await prisma.tokenSesion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenSesionUpdateArgs>(args: SelectSubset<T, TokenSesionUpdateArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TokenSesions.
     * @param {TokenSesionDeleteManyArgs} args - Arguments to filter TokenSesions to delete.
     * @example
     * // Delete a few TokenSesions
     * const { count } = await prisma.tokenSesion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenSesionDeleteManyArgs>(args?: SelectSubset<T, TokenSesionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenSesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenSesions
     * const tokenSesion = await prisma.tokenSesion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenSesionUpdateManyArgs>(args: SelectSubset<T, TokenSesionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenSesions and returns the data updated in the database.
     * @param {TokenSesionUpdateManyAndReturnArgs} args - Arguments to update many TokenSesions.
     * @example
     * // Update many TokenSesions
     * const tokenSesion = await prisma.tokenSesion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TokenSesions and only return the `id`
     * const tokenSesionWithIdOnly = await prisma.tokenSesion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenSesionUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenSesionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TokenSesion.
     * @param {TokenSesionUpsertArgs} args - Arguments to update or create a TokenSesion.
     * @example
     * // Update or create a TokenSesion
     * const tokenSesion = await prisma.tokenSesion.upsert({
     *   create: {
     *     // ... data to create a TokenSesion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenSesion we want to update
     *   }
     * })
     */
    upsert<T extends TokenSesionUpsertArgs>(args: SelectSubset<T, TokenSesionUpsertArgs<ExtArgs>>): Prisma__TokenSesionClient<$Result.GetResult<Prisma.$TokenSesionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TokenSesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionCountArgs} args - Arguments to filter TokenSesions to count.
     * @example
     * // Count the number of TokenSesions
     * const count = await prisma.tokenSesion.count({
     *   where: {
     *     // ... the filter for the TokenSesions we want to count
     *   }
     * })
    **/
    count<T extends TokenSesionCountArgs>(
      args?: Subset<T, TokenSesionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenSesionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenSesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenSesionAggregateArgs>(args: Subset<T, TokenSesionAggregateArgs>): Prisma.PrismaPromise<GetTokenSesionAggregateType<T>>

    /**
     * Group by TokenSesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenSesionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenSesionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenSesionGroupByArgs['orderBy'] }
        : { orderBy?: TokenSesionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenSesionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenSesionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenSesion model
   */
  readonly fields: TokenSesionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenSesion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenSesionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenSesion model
   */
  interface TokenSesionFieldRefs {
    readonly id: FieldRef<"TokenSesion", 'String'>
    readonly token: FieldRef<"TokenSesion", 'String'>
    readonly tipo: FieldRef<"TokenSesion", 'TipoToken'>
    readonly expiraEn: FieldRef<"TokenSesion", 'DateTime'>
    readonly revocado: FieldRef<"TokenSesion", 'Boolean'>
    readonly ipAddress: FieldRef<"TokenSesion", 'String'>
    readonly userAgent: FieldRef<"TokenSesion", 'String'>
    readonly usuarioId: FieldRef<"TokenSesion", 'String'>
    readonly createdAt: FieldRef<"TokenSesion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TokenSesion findUnique
   */
  export type TokenSesionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * Filter, which TokenSesion to fetch.
     */
    where: TokenSesionWhereUniqueInput
  }

  /**
   * TokenSesion findUniqueOrThrow
   */
  export type TokenSesionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * Filter, which TokenSesion to fetch.
     */
    where: TokenSesionWhereUniqueInput
  }

  /**
   * TokenSesion findFirst
   */
  export type TokenSesionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * Filter, which TokenSesion to fetch.
     */
    where?: TokenSesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenSesions to fetch.
     */
    orderBy?: TokenSesionOrderByWithRelationInput | TokenSesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenSesions.
     */
    cursor?: TokenSesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenSesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenSesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenSesions.
     */
    distinct?: TokenSesionScalarFieldEnum | TokenSesionScalarFieldEnum[]
  }

  /**
   * TokenSesion findFirstOrThrow
   */
  export type TokenSesionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * Filter, which TokenSesion to fetch.
     */
    where?: TokenSesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenSesions to fetch.
     */
    orderBy?: TokenSesionOrderByWithRelationInput | TokenSesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenSesions.
     */
    cursor?: TokenSesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenSesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenSesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenSesions.
     */
    distinct?: TokenSesionScalarFieldEnum | TokenSesionScalarFieldEnum[]
  }

  /**
   * TokenSesion findMany
   */
  export type TokenSesionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * Filter, which TokenSesions to fetch.
     */
    where?: TokenSesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenSesions to fetch.
     */
    orderBy?: TokenSesionOrderByWithRelationInput | TokenSesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenSesions.
     */
    cursor?: TokenSesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenSesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenSesions.
     */
    skip?: number
    distinct?: TokenSesionScalarFieldEnum | TokenSesionScalarFieldEnum[]
  }

  /**
   * TokenSesion create
   */
  export type TokenSesionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenSesion.
     */
    data: XOR<TokenSesionCreateInput, TokenSesionUncheckedCreateInput>
  }

  /**
   * TokenSesion createMany
   */
  export type TokenSesionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenSesions.
     */
    data: TokenSesionCreateManyInput | TokenSesionCreateManyInput[]
  }

  /**
   * TokenSesion createManyAndReturn
   */
  export type TokenSesionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * The data used to create many TokenSesions.
     */
    data: TokenSesionCreateManyInput | TokenSesionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenSesion update
   */
  export type TokenSesionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenSesion.
     */
    data: XOR<TokenSesionUpdateInput, TokenSesionUncheckedUpdateInput>
    /**
     * Choose, which TokenSesion to update.
     */
    where: TokenSesionWhereUniqueInput
  }

  /**
   * TokenSesion updateMany
   */
  export type TokenSesionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenSesions.
     */
    data: XOR<TokenSesionUpdateManyMutationInput, TokenSesionUncheckedUpdateManyInput>
    /**
     * Filter which TokenSesions to update
     */
    where?: TokenSesionWhereInput
    /**
     * Limit how many TokenSesions to update.
     */
    limit?: number
  }

  /**
   * TokenSesion updateManyAndReturn
   */
  export type TokenSesionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * The data used to update TokenSesions.
     */
    data: XOR<TokenSesionUpdateManyMutationInput, TokenSesionUncheckedUpdateManyInput>
    /**
     * Filter which TokenSesions to update
     */
    where?: TokenSesionWhereInput
    /**
     * Limit how many TokenSesions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenSesion upsert
   */
  export type TokenSesionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenSesion to update in case it exists.
     */
    where: TokenSesionWhereUniqueInput
    /**
     * In case the TokenSesion found by the `where` argument doesn't exist, create a new TokenSesion with this data.
     */
    create: XOR<TokenSesionCreateInput, TokenSesionUncheckedCreateInput>
    /**
     * In case the TokenSesion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenSesionUpdateInput, TokenSesionUncheckedUpdateInput>
  }

  /**
   * TokenSesion delete
   */
  export type TokenSesionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
    /**
     * Filter which TokenSesion to delete.
     */
    where: TokenSesionWhereUniqueInput
  }

  /**
   * TokenSesion deleteMany
   */
  export type TokenSesionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenSesions to delete
     */
    where?: TokenSesionWhereInput
    /**
     * Limit how many TokenSesions to delete.
     */
    limit?: number
  }

  /**
   * TokenSesion without action
   */
  export type TokenSesionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenSesion
     */
    select?: TokenSesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenSesion
     */
    omit?: TokenSesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenSesionInclude<ExtArgs> | null
  }


  /**
   * Model Estudiante
   */

  export type AggregateEstudiante = {
    _count: EstudianteCountAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  export type EstudianteMinAggregateOutputType = {
    id: string | null
    matricula: string | null
    fechaNacimiento: Date | null
    curp: string | null
    nss: string | null
    direccion: string | null
    ciudad: string | null
    estado: string | null
    codigoPostal: string | null
    tutorNombre: string | null
    tutorTelefono: string | null
    tutorEmail: string | null
    estatus: $Enums.EstatusEstudiante | null
    fechaIngreso: Date | null
    fechaEgreso: Date | null
    usuarioId: string | null
    carreraId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EstudianteMaxAggregateOutputType = {
    id: string | null
    matricula: string | null
    fechaNacimiento: Date | null
    curp: string | null
    nss: string | null
    direccion: string | null
    ciudad: string | null
    estado: string | null
    codigoPostal: string | null
    tutorNombre: string | null
    tutorTelefono: string | null
    tutorEmail: string | null
    estatus: $Enums.EstatusEstudiante | null
    fechaIngreso: Date | null
    fechaEgreso: Date | null
    usuarioId: string | null
    carreraId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EstudianteCountAggregateOutputType = {
    id: number
    matricula: number
    fechaNacimiento: number
    curp: number
    nss: number
    direccion: number
    ciudad: number
    estado: number
    codigoPostal: number
    tutorNombre: number
    tutorTelefono: number
    tutorEmail: number
    estatus: number
    fechaIngreso: number
    fechaEgreso: number
    usuarioId: number
    carreraId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EstudianteMinAggregateInputType = {
    id?: true
    matricula?: true
    fechaNacimiento?: true
    curp?: true
    nss?: true
    direccion?: true
    ciudad?: true
    estado?: true
    codigoPostal?: true
    tutorNombre?: true
    tutorTelefono?: true
    tutorEmail?: true
    estatus?: true
    fechaIngreso?: true
    fechaEgreso?: true
    usuarioId?: true
    carreraId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EstudianteMaxAggregateInputType = {
    id?: true
    matricula?: true
    fechaNacimiento?: true
    curp?: true
    nss?: true
    direccion?: true
    ciudad?: true
    estado?: true
    codigoPostal?: true
    tutorNombre?: true
    tutorTelefono?: true
    tutorEmail?: true
    estatus?: true
    fechaIngreso?: true
    fechaEgreso?: true
    usuarioId?: true
    carreraId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EstudianteCountAggregateInputType = {
    id?: true
    matricula?: true
    fechaNacimiento?: true
    curp?: true
    nss?: true
    direccion?: true
    ciudad?: true
    estado?: true
    codigoPostal?: true
    tutorNombre?: true
    tutorTelefono?: true
    tutorEmail?: true
    estatus?: true
    fechaIngreso?: true
    fechaEgreso?: true
    usuarioId?: true
    carreraId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EstudianteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiante to aggregate.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estudiantes
    **/
    _count?: true | EstudianteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudianteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudianteMaxAggregateInputType
  }

  export type GetEstudianteAggregateType<T extends EstudianteAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiante[P]>
      : GetScalarType<T[P], AggregateEstudiante[P]>
  }




  export type EstudianteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteWhereInput
    orderBy?: EstudianteOrderByWithAggregationInput | EstudianteOrderByWithAggregationInput[]
    by: EstudianteScalarFieldEnum[] | EstudianteScalarFieldEnum
    having?: EstudianteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudianteCountAggregateInputType | true
    _min?: EstudianteMinAggregateInputType
    _max?: EstudianteMaxAggregateInputType
  }

  export type EstudianteGroupByOutputType = {
    id: string
    matricula: string
    fechaNacimiento: Date | null
    curp: string | null
    nss: string | null
    direccion: string | null
    ciudad: string | null
    estado: string | null
    codigoPostal: string | null
    tutorNombre: string | null
    tutorTelefono: string | null
    tutorEmail: string | null
    estatus: $Enums.EstatusEstudiante
    fechaIngreso: Date
    fechaEgreso: Date | null
    usuarioId: string
    carreraId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EstudianteCountAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  type GetEstudianteGroupByPayload<T extends EstudianteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudianteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudianteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
            : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
        }
      >
    >


  export type EstudianteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricula?: boolean
    fechaNacimiento?: boolean
    curp?: boolean
    nss?: boolean
    direccion?: boolean
    ciudad?: boolean
    estado?: boolean
    codigoPostal?: boolean
    tutorNombre?: boolean
    tutorTelefono?: boolean
    tutorEmail?: boolean
    estatus?: boolean
    fechaIngreso?: boolean
    fechaEgreso?: boolean
    usuarioId?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    carrera?: boolean | Estudiante$carreraArgs<ExtArgs>
    inscripciones?: boolean | Estudiante$inscripcionesArgs<ExtArgs>
    calificaciones?: boolean | Estudiante$calificacionesArgs<ExtArgs>
    documentos?: boolean | Estudiante$documentosArgs<ExtArgs>
    notificaciones?: boolean | Estudiante$notificacionesArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricula?: boolean
    fechaNacimiento?: boolean
    curp?: boolean
    nss?: boolean
    direccion?: boolean
    ciudad?: boolean
    estado?: boolean
    codigoPostal?: boolean
    tutorNombre?: boolean
    tutorTelefono?: boolean
    tutorEmail?: boolean
    estatus?: boolean
    fechaIngreso?: boolean
    fechaEgreso?: boolean
    usuarioId?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    carrera?: boolean | Estudiante$carreraArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricula?: boolean
    fechaNacimiento?: boolean
    curp?: boolean
    nss?: boolean
    direccion?: boolean
    ciudad?: boolean
    estado?: boolean
    codigoPostal?: boolean
    tutorNombre?: boolean
    tutorTelefono?: boolean
    tutorEmail?: boolean
    estatus?: boolean
    fechaIngreso?: boolean
    fechaEgreso?: boolean
    usuarioId?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    carrera?: boolean | Estudiante$carreraArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectScalar = {
    id?: boolean
    matricula?: boolean
    fechaNacimiento?: boolean
    curp?: boolean
    nss?: boolean
    direccion?: boolean
    ciudad?: boolean
    estado?: boolean
    codigoPostal?: boolean
    tutorNombre?: boolean
    tutorTelefono?: boolean
    tutorEmail?: boolean
    estatus?: boolean
    fechaIngreso?: boolean
    fechaEgreso?: boolean
    usuarioId?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EstudianteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matricula" | "fechaNacimiento" | "curp" | "nss" | "direccion" | "ciudad" | "estado" | "codigoPostal" | "tutorNombre" | "tutorTelefono" | "tutorEmail" | "estatus" | "fechaIngreso" | "fechaEgreso" | "usuarioId" | "carreraId" | "createdAt" | "updatedAt", ExtArgs["result"]["estudiante"]>
  export type EstudianteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    carrera?: boolean | Estudiante$carreraArgs<ExtArgs>
    inscripciones?: boolean | Estudiante$inscripcionesArgs<ExtArgs>
    calificaciones?: boolean | Estudiante$calificacionesArgs<ExtArgs>
    documentos?: boolean | Estudiante$documentosArgs<ExtArgs>
    notificaciones?: boolean | Estudiante$notificacionesArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EstudianteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    carrera?: boolean | Estudiante$carreraArgs<ExtArgs>
  }
  export type EstudianteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    carrera?: boolean | Estudiante$carreraArgs<ExtArgs>
  }

  export type $EstudiantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estudiante"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      carrera: Prisma.$CarreraPayload<ExtArgs> | null
      inscripciones: Prisma.$InscripcionPayload<ExtArgs>[]
      calificaciones: Prisma.$CalificacionPayload<ExtArgs>[]
      documentos: Prisma.$DocumentoEstudiantePayload<ExtArgs>[]
      notificaciones: Prisma.$NotificacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matricula: string
      fechaNacimiento: Date | null
      curp: string | null
      nss: string | null
      direccion: string | null
      ciudad: string | null
      estado: string | null
      codigoPostal: string | null
      tutorNombre: string | null
      tutorTelefono: string | null
      tutorEmail: string | null
      estatus: $Enums.EstatusEstudiante
      fechaIngreso: Date
      fechaEgreso: Date | null
      usuarioId: string
      carreraId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["estudiante"]>
    composites: {}
  }

  type EstudianteGetPayload<S extends boolean | null | undefined | EstudianteDefaultArgs> = $Result.GetResult<Prisma.$EstudiantePayload, S>

  type EstudianteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EstudianteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstudianteCountAggregateInputType | true
    }

  export interface EstudianteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estudiante'], meta: { name: 'Estudiante' } }
    /**
     * Find zero or one Estudiante that matches the filter.
     * @param {EstudianteFindUniqueArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudianteFindUniqueArgs>(args: SelectSubset<T, EstudianteFindUniqueArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estudiante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EstudianteFindUniqueOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudianteFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudianteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudianteFindFirstArgs>(args?: SelectSubset<T, EstudianteFindFirstArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudianteFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudianteFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiante.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstudianteFindManyArgs>(args?: SelectSubset<T, EstudianteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estudiante.
     * @param {EstudianteCreateArgs} args - Arguments to create a Estudiante.
     * @example
     * // Create one Estudiante
     * const Estudiante = await prisma.estudiante.create({
     *   data: {
     *     // ... data to create a Estudiante
     *   }
     * })
     * 
     */
    create<T extends EstudianteCreateArgs>(args: SelectSubset<T, EstudianteCreateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estudiantes.
     * @param {EstudianteCreateManyArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudianteCreateManyArgs>(args?: SelectSubset<T, EstudianteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estudiantes and returns the data saved in the database.
     * @param {EstudianteCreateManyAndReturnArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstudianteCreateManyAndReturnArgs>(args?: SelectSubset<T, EstudianteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estudiante.
     * @param {EstudianteDeleteArgs} args - Arguments to delete one Estudiante.
     * @example
     * // Delete one Estudiante
     * const Estudiante = await prisma.estudiante.delete({
     *   where: {
     *     // ... filter to delete one Estudiante
     *   }
     * })
     * 
     */
    delete<T extends EstudianteDeleteArgs>(args: SelectSubset<T, EstudianteDeleteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estudiante.
     * @param {EstudianteUpdateArgs} args - Arguments to update one Estudiante.
     * @example
     * // Update one Estudiante
     * const estudiante = await prisma.estudiante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudianteUpdateArgs>(args: SelectSubset<T, EstudianteUpdateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estudiantes.
     * @param {EstudianteDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudianteDeleteManyArgs>(args?: SelectSubset<T, EstudianteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudianteUpdateManyArgs>(args: SelectSubset<T, EstudianteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes and returns the data updated in the database.
     * @param {EstudianteUpdateManyAndReturnArgs} args - Arguments to update many Estudiantes.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EstudianteUpdateManyAndReturnArgs>(args: SelectSubset<T, EstudianteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estudiante.
     * @param {EstudianteUpsertArgs} args - Arguments to update or create a Estudiante.
     * @example
     * // Update or create a Estudiante
     * const estudiante = await prisma.estudiante.upsert({
     *   create: {
     *     // ... data to create a Estudiante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiante we want to update
     *   }
     * })
     */
    upsert<T extends EstudianteUpsertArgs>(args: SelectSubset<T, EstudianteUpsertArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiante.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends EstudianteCountArgs>(
      args?: Subset<T, EstudianteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudianteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudianteAggregateArgs>(args: Subset<T, EstudianteAggregateArgs>): Prisma.PrismaPromise<GetEstudianteAggregateType<T>>

    /**
     * Group by Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudianteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudianteGroupByArgs['orderBy'] }
        : { orderBy?: EstudianteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudianteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudianteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estudiante model
   */
  readonly fields: EstudianteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estudiante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudianteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    carrera<T extends Estudiante$carreraArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$carreraArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inscripciones<T extends Estudiante$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calificaciones<T extends Estudiante$calificacionesArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$calificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentos<T extends Estudiante$documentosArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$documentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificaciones<T extends Estudiante$notificacionesArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$notificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estudiante model
   */
  interface EstudianteFieldRefs {
    readonly id: FieldRef<"Estudiante", 'String'>
    readonly matricula: FieldRef<"Estudiante", 'String'>
    readonly fechaNacimiento: FieldRef<"Estudiante", 'DateTime'>
    readonly curp: FieldRef<"Estudiante", 'String'>
    readonly nss: FieldRef<"Estudiante", 'String'>
    readonly direccion: FieldRef<"Estudiante", 'String'>
    readonly ciudad: FieldRef<"Estudiante", 'String'>
    readonly estado: FieldRef<"Estudiante", 'String'>
    readonly codigoPostal: FieldRef<"Estudiante", 'String'>
    readonly tutorNombre: FieldRef<"Estudiante", 'String'>
    readonly tutorTelefono: FieldRef<"Estudiante", 'String'>
    readonly tutorEmail: FieldRef<"Estudiante", 'String'>
    readonly estatus: FieldRef<"Estudiante", 'EstatusEstudiante'>
    readonly fechaIngreso: FieldRef<"Estudiante", 'DateTime'>
    readonly fechaEgreso: FieldRef<"Estudiante", 'DateTime'>
    readonly usuarioId: FieldRef<"Estudiante", 'String'>
    readonly carreraId: FieldRef<"Estudiante", 'String'>
    readonly createdAt: FieldRef<"Estudiante", 'DateTime'>
    readonly updatedAt: FieldRef<"Estudiante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Estudiante findUnique
   */
  export type EstudianteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findUniqueOrThrow
   */
  export type EstudianteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findFirst
   */
  export type EstudianteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findFirstOrThrow
   */
  export type EstudianteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findMany
   */
  export type EstudianteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiantes to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante create
   */
  export type EstudianteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to create a Estudiante.
     */
    data: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
  }

  /**
   * Estudiante createMany
   */
  export type EstudianteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
  }

  /**
   * Estudiante createManyAndReturn
   */
  export type EstudianteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estudiante update
   */
  export type EstudianteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to update a Estudiante.
     */
    data: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
    /**
     * Choose, which Estudiante to update.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante updateMany
   */
  export type EstudianteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to update.
     */
    limit?: number
  }

  /**
   * Estudiante updateManyAndReturn
   */
  export type EstudianteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estudiante upsert
   */
  export type EstudianteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The filter to search for the Estudiante to update in case it exists.
     */
    where: EstudianteWhereUniqueInput
    /**
     * In case the Estudiante found by the `where` argument doesn't exist, create a new Estudiante with this data.
     */
    create: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
    /**
     * In case the Estudiante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
  }

  /**
   * Estudiante delete
   */
  export type EstudianteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter which Estudiante to delete.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante deleteMany
   */
  export type EstudianteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiantes to delete
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to delete.
     */
    limit?: number
  }

  /**
   * Estudiante.carrera
   */
  export type Estudiante$carreraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    where?: CarreraWhereInput
  }

  /**
   * Estudiante.inscripciones
   */
  export type Estudiante$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    cursor?: InscripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Estudiante.calificaciones
   */
  export type Estudiante$calificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    where?: CalificacionWhereInput
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    cursor?: CalificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Estudiante.documentos
   */
  export type Estudiante$documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    where?: DocumentoEstudianteWhereInput
    orderBy?: DocumentoEstudianteOrderByWithRelationInput | DocumentoEstudianteOrderByWithRelationInput[]
    cursor?: DocumentoEstudianteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoEstudianteScalarFieldEnum | DocumentoEstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante.notificaciones
   */
  export type Estudiante$notificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    cursor?: NotificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Estudiante without action
   */
  export type EstudianteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
  }


  /**
   * Model Carrera
   */

  export type AggregateCarrera = {
    _count: CarreraCountAggregateOutputType | null
    _avg: CarreraAvgAggregateOutputType | null
    _sum: CarreraSumAggregateOutputType | null
    _min: CarreraMinAggregateOutputType | null
    _max: CarreraMaxAggregateOutputType | null
  }

  export type CarreraAvgAggregateOutputType = {
    duracionSemestres: number | null
    creditos: number | null
  }

  export type CarreraSumAggregateOutputType = {
    duracionSemestres: number | null
    creditos: number | null
  }

  export type CarreraMinAggregateOutputType = {
    id: string | null
    clave: string | null
    nombre: string | null
    descripcion: string | null
    duracionSemestres: number | null
    creditos: number | null
    modalidad: $Enums.Modalidad | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarreraMaxAggregateOutputType = {
    id: string | null
    clave: string | null
    nombre: string | null
    descripcion: string | null
    duracionSemestres: number | null
    creditos: number | null
    modalidad: $Enums.Modalidad | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarreraCountAggregateOutputType = {
    id: number
    clave: number
    nombre: number
    descripcion: number
    duracionSemestres: number
    creditos: number
    modalidad: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CarreraAvgAggregateInputType = {
    duracionSemestres?: true
    creditos?: true
  }

  export type CarreraSumAggregateInputType = {
    duracionSemestres?: true
    creditos?: true
  }

  export type CarreraMinAggregateInputType = {
    id?: true
    clave?: true
    nombre?: true
    descripcion?: true
    duracionSemestres?: true
    creditos?: true
    modalidad?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarreraMaxAggregateInputType = {
    id?: true
    clave?: true
    nombre?: true
    descripcion?: true
    duracionSemestres?: true
    creditos?: true
    modalidad?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarreraCountAggregateInputType = {
    id?: true
    clave?: true
    nombre?: true
    descripcion?: true
    duracionSemestres?: true
    creditos?: true
    modalidad?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CarreraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carrera to aggregate.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carreras
    **/
    _count?: true | CarreraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarreraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarreraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarreraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarreraMaxAggregateInputType
  }

  export type GetCarreraAggregateType<T extends CarreraAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrera]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrera[P]>
      : GetScalarType<T[P], AggregateCarrera[P]>
  }




  export type CarreraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarreraWhereInput
    orderBy?: CarreraOrderByWithAggregationInput | CarreraOrderByWithAggregationInput[]
    by: CarreraScalarFieldEnum[] | CarreraScalarFieldEnum
    having?: CarreraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarreraCountAggregateInputType | true
    _avg?: CarreraAvgAggregateInputType
    _sum?: CarreraSumAggregateInputType
    _min?: CarreraMinAggregateInputType
    _max?: CarreraMaxAggregateInputType
  }

  export type CarreraGroupByOutputType = {
    id: string
    clave: string
    nombre: string
    descripcion: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: CarreraCountAggregateOutputType | null
    _avg: CarreraAvgAggregateOutputType | null
    _sum: CarreraSumAggregateOutputType | null
    _min: CarreraMinAggregateOutputType | null
    _max: CarreraMaxAggregateOutputType | null
  }

  type GetCarreraGroupByPayload<T extends CarreraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarreraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarreraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarreraGroupByOutputType[P]>
            : GetScalarType<T[P], CarreraGroupByOutputType[P]>
        }
      >
    >


  export type CarreraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionSemestres?: boolean
    creditos?: boolean
    modalidad?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiantes?: boolean | Carrera$estudiantesArgs<ExtArgs>
    materias?: boolean | Carrera$materiasArgs<ExtArgs>
    _count?: boolean | CarreraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrera"]>

  export type CarreraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionSemestres?: boolean
    creditos?: boolean
    modalidad?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carrera"]>

  export type CarreraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionSemestres?: boolean
    creditos?: boolean
    modalidad?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["carrera"]>

  export type CarreraSelectScalar = {
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionSemestres?: boolean
    creditos?: boolean
    modalidad?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CarreraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clave" | "nombre" | "descripcion" | "duracionSemestres" | "creditos" | "modalidad" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["carrera"]>
  export type CarreraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | Carrera$estudiantesArgs<ExtArgs>
    materias?: boolean | Carrera$materiasArgs<ExtArgs>
    _count?: boolean | CarreraCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarreraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CarreraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CarreraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carrera"
    objects: {
      estudiantes: Prisma.$EstudiantePayload<ExtArgs>[]
      materias: Prisma.$MateriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clave: string
      nombre: string
      descripcion: string | null
      duracionSemestres: number
      creditos: number
      modalidad: $Enums.Modalidad
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["carrera"]>
    composites: {}
  }

  type CarreraGetPayload<S extends boolean | null | undefined | CarreraDefaultArgs> = $Result.GetResult<Prisma.$CarreraPayload, S>

  type CarreraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarreraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarreraCountAggregateInputType | true
    }

  export interface CarreraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carrera'], meta: { name: 'Carrera' } }
    /**
     * Find zero or one Carrera that matches the filter.
     * @param {CarreraFindUniqueArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarreraFindUniqueArgs>(args: SelectSubset<T, CarreraFindUniqueArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carrera that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarreraFindUniqueOrThrowArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarreraFindUniqueOrThrowArgs>(args: SelectSubset<T, CarreraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carrera that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraFindFirstArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarreraFindFirstArgs>(args?: SelectSubset<T, CarreraFindFirstArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carrera that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraFindFirstOrThrowArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarreraFindFirstOrThrowArgs>(args?: SelectSubset<T, CarreraFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carreras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carreras
     * const carreras = await prisma.carrera.findMany()
     * 
     * // Get first 10 Carreras
     * const carreras = await prisma.carrera.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carreraWithIdOnly = await prisma.carrera.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarreraFindManyArgs>(args?: SelectSubset<T, CarreraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carrera.
     * @param {CarreraCreateArgs} args - Arguments to create a Carrera.
     * @example
     * // Create one Carrera
     * const Carrera = await prisma.carrera.create({
     *   data: {
     *     // ... data to create a Carrera
     *   }
     * })
     * 
     */
    create<T extends CarreraCreateArgs>(args: SelectSubset<T, CarreraCreateArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carreras.
     * @param {CarreraCreateManyArgs} args - Arguments to create many Carreras.
     * @example
     * // Create many Carreras
     * const carrera = await prisma.carrera.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarreraCreateManyArgs>(args?: SelectSubset<T, CarreraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carreras and returns the data saved in the database.
     * @param {CarreraCreateManyAndReturnArgs} args - Arguments to create many Carreras.
     * @example
     * // Create many Carreras
     * const carrera = await prisma.carrera.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carreras and only return the `id`
     * const carreraWithIdOnly = await prisma.carrera.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarreraCreateManyAndReturnArgs>(args?: SelectSubset<T, CarreraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carrera.
     * @param {CarreraDeleteArgs} args - Arguments to delete one Carrera.
     * @example
     * // Delete one Carrera
     * const Carrera = await prisma.carrera.delete({
     *   where: {
     *     // ... filter to delete one Carrera
     *   }
     * })
     * 
     */
    delete<T extends CarreraDeleteArgs>(args: SelectSubset<T, CarreraDeleteArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carrera.
     * @param {CarreraUpdateArgs} args - Arguments to update one Carrera.
     * @example
     * // Update one Carrera
     * const carrera = await prisma.carrera.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarreraUpdateArgs>(args: SelectSubset<T, CarreraUpdateArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carreras.
     * @param {CarreraDeleteManyArgs} args - Arguments to filter Carreras to delete.
     * @example
     * // Delete a few Carreras
     * const { count } = await prisma.carrera.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarreraDeleteManyArgs>(args?: SelectSubset<T, CarreraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carreras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carreras
     * const carrera = await prisma.carrera.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarreraUpdateManyArgs>(args: SelectSubset<T, CarreraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carreras and returns the data updated in the database.
     * @param {CarreraUpdateManyAndReturnArgs} args - Arguments to update many Carreras.
     * @example
     * // Update many Carreras
     * const carrera = await prisma.carrera.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carreras and only return the `id`
     * const carreraWithIdOnly = await prisma.carrera.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarreraUpdateManyAndReturnArgs>(args: SelectSubset<T, CarreraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carrera.
     * @param {CarreraUpsertArgs} args - Arguments to update or create a Carrera.
     * @example
     * // Update or create a Carrera
     * const carrera = await prisma.carrera.upsert({
     *   create: {
     *     // ... data to create a Carrera
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carrera we want to update
     *   }
     * })
     */
    upsert<T extends CarreraUpsertArgs>(args: SelectSubset<T, CarreraUpsertArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carreras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraCountArgs} args - Arguments to filter Carreras to count.
     * @example
     * // Count the number of Carreras
     * const count = await prisma.carrera.count({
     *   where: {
     *     // ... the filter for the Carreras we want to count
     *   }
     * })
    **/
    count<T extends CarreraCountArgs>(
      args?: Subset<T, CarreraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarreraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carrera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarreraAggregateArgs>(args: Subset<T, CarreraAggregateArgs>): Prisma.PrismaPromise<GetCarreraAggregateType<T>>

    /**
     * Group by Carrera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarreraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarreraGroupByArgs['orderBy'] }
        : { orderBy?: CarreraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarreraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarreraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carrera model
   */
  readonly fields: CarreraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carrera.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarreraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiantes<T extends Carrera$estudiantesArgs<ExtArgs> = {}>(args?: Subset<T, Carrera$estudiantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materias<T extends Carrera$materiasArgs<ExtArgs> = {}>(args?: Subset<T, Carrera$materiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carrera model
   */
  interface CarreraFieldRefs {
    readonly id: FieldRef<"Carrera", 'String'>
    readonly clave: FieldRef<"Carrera", 'String'>
    readonly nombre: FieldRef<"Carrera", 'String'>
    readonly descripcion: FieldRef<"Carrera", 'String'>
    readonly duracionSemestres: FieldRef<"Carrera", 'Int'>
    readonly creditos: FieldRef<"Carrera", 'Int'>
    readonly modalidad: FieldRef<"Carrera", 'Modalidad'>
    readonly activo: FieldRef<"Carrera", 'Boolean'>
    readonly createdAt: FieldRef<"Carrera", 'DateTime'>
    readonly updatedAt: FieldRef<"Carrera", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Carrera findUnique
   */
  export type CarreraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera findUniqueOrThrow
   */
  export type CarreraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera findFirst
   */
  export type CarreraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carreras.
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carreras.
     */
    distinct?: CarreraScalarFieldEnum | CarreraScalarFieldEnum[]
  }

  /**
   * Carrera findFirstOrThrow
   */
  export type CarreraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carreras.
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carreras.
     */
    distinct?: CarreraScalarFieldEnum | CarreraScalarFieldEnum[]
  }

  /**
   * Carrera findMany
   */
  export type CarreraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carreras to fetch.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carreras.
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    distinct?: CarreraScalarFieldEnum | CarreraScalarFieldEnum[]
  }

  /**
   * Carrera create
   */
  export type CarreraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * The data needed to create a Carrera.
     */
    data: XOR<CarreraCreateInput, CarreraUncheckedCreateInput>
  }

  /**
   * Carrera createMany
   */
  export type CarreraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carreras.
     */
    data: CarreraCreateManyInput | CarreraCreateManyInput[]
  }

  /**
   * Carrera createManyAndReturn
   */
  export type CarreraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * The data used to create many Carreras.
     */
    data: CarreraCreateManyInput | CarreraCreateManyInput[]
  }

  /**
   * Carrera update
   */
  export type CarreraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * The data needed to update a Carrera.
     */
    data: XOR<CarreraUpdateInput, CarreraUncheckedUpdateInput>
    /**
     * Choose, which Carrera to update.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera updateMany
   */
  export type CarreraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carreras.
     */
    data: XOR<CarreraUpdateManyMutationInput, CarreraUncheckedUpdateManyInput>
    /**
     * Filter which Carreras to update
     */
    where?: CarreraWhereInput
    /**
     * Limit how many Carreras to update.
     */
    limit?: number
  }

  /**
   * Carrera updateManyAndReturn
   */
  export type CarreraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * The data used to update Carreras.
     */
    data: XOR<CarreraUpdateManyMutationInput, CarreraUncheckedUpdateManyInput>
    /**
     * Filter which Carreras to update
     */
    where?: CarreraWhereInput
    /**
     * Limit how many Carreras to update.
     */
    limit?: number
  }

  /**
   * Carrera upsert
   */
  export type CarreraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * The filter to search for the Carrera to update in case it exists.
     */
    where: CarreraWhereUniqueInput
    /**
     * In case the Carrera found by the `where` argument doesn't exist, create a new Carrera with this data.
     */
    create: XOR<CarreraCreateInput, CarreraUncheckedCreateInput>
    /**
     * In case the Carrera was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarreraUpdateInput, CarreraUncheckedUpdateInput>
  }

  /**
   * Carrera delete
   */
  export type CarreraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter which Carrera to delete.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera deleteMany
   */
  export type CarreraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carreras to delete
     */
    where?: CarreraWhereInput
    /**
     * Limit how many Carreras to delete.
     */
    limit?: number
  }

  /**
   * Carrera.estudiantes
   */
  export type Carrera$estudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    cursor?: EstudianteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Carrera.materias
   */
  export type Carrera$materiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    where?: MateriaWhereInput
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    cursor?: MateriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Carrera without action
   */
  export type CarreraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
  }


  /**
   * Model Materia
   */

  export type AggregateMateria = {
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  export type MateriaAvgAggregateOutputType = {
    creditos: number | null
    semestre: number | null
    horasTeoria: number | null
    horasPractica: number | null
  }

  export type MateriaSumAggregateOutputType = {
    creditos: number | null
    semestre: number | null
    horasTeoria: number | null
    horasPractica: number | null
  }

  export type MateriaMinAggregateOutputType = {
    id: string | null
    clave: string | null
    nombre: string | null
    descripcion: string | null
    creditos: number | null
    semestre: number | null
    horasTeoria: number | null
    horasPractica: number | null
    activo: boolean | null
    carreraId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MateriaMaxAggregateOutputType = {
    id: string | null
    clave: string | null
    nombre: string | null
    descripcion: string | null
    creditos: number | null
    semestre: number | null
    horasTeoria: number | null
    horasPractica: number | null
    activo: boolean | null
    carreraId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MateriaCountAggregateOutputType = {
    id: number
    clave: number
    nombre: number
    descripcion: number
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo: number
    carreraId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MateriaAvgAggregateInputType = {
    creditos?: true
    semestre?: true
    horasTeoria?: true
    horasPractica?: true
  }

  export type MateriaSumAggregateInputType = {
    creditos?: true
    semestre?: true
    horasTeoria?: true
    horasPractica?: true
  }

  export type MateriaMinAggregateInputType = {
    id?: true
    clave?: true
    nombre?: true
    descripcion?: true
    creditos?: true
    semestre?: true
    horasTeoria?: true
    horasPractica?: true
    activo?: true
    carreraId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MateriaMaxAggregateInputType = {
    id?: true
    clave?: true
    nombre?: true
    descripcion?: true
    creditos?: true
    semestre?: true
    horasTeoria?: true
    horasPractica?: true
    activo?: true
    carreraId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MateriaCountAggregateInputType = {
    id?: true
    clave?: true
    nombre?: true
    descripcion?: true
    creditos?: true
    semestre?: true
    horasTeoria?: true
    horasPractica?: true
    activo?: true
    carreraId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MateriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materia to aggregate.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materias
    **/
    _count?: true | MateriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MateriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MateriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MateriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MateriaMaxAggregateInputType
  }

  export type GetMateriaAggregateType<T extends MateriaAggregateArgs> = {
        [P in keyof T & keyof AggregateMateria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateria[P]>
      : GetScalarType<T[P], AggregateMateria[P]>
  }




  export type MateriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriaWhereInput
    orderBy?: MateriaOrderByWithAggregationInput | MateriaOrderByWithAggregationInput[]
    by: MateriaScalarFieldEnum[] | MateriaScalarFieldEnum
    having?: MateriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MateriaCountAggregateInputType | true
    _avg?: MateriaAvgAggregateInputType
    _sum?: MateriaSumAggregateInputType
    _min?: MateriaMinAggregateInputType
    _max?: MateriaMaxAggregateInputType
  }

  export type MateriaGroupByOutputType = {
    id: string
    clave: string
    nombre: string
    descripcion: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo: boolean
    carreraId: string
    createdAt: Date
    updatedAt: Date
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  type GetMateriaGroupByPayload<T extends MateriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MateriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MateriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MateriaGroupByOutputType[P]>
            : GetScalarType<T[P], MateriaGroupByOutputType[P]>
        }
      >
    >


  export type MateriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    creditos?: boolean
    semestre?: boolean
    horasTeoria?: boolean
    horasPractica?: boolean
    activo?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    grupos?: boolean | Materia$gruposArgs<ExtArgs>
    calificaciones?: boolean | Materia$calificacionesArgs<ExtArgs>
    _count?: boolean | MateriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia"]>

  export type MateriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    creditos?: boolean
    semestre?: boolean
    horasTeoria?: boolean
    horasPractica?: boolean
    activo?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    carrera?: boolean | CarreraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia"]>

  export type MateriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    creditos?: boolean
    semestre?: boolean
    horasTeoria?: boolean
    horasPractica?: boolean
    activo?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    carrera?: boolean | CarreraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia"]>

  export type MateriaSelectScalar = {
    id?: boolean
    clave?: boolean
    nombre?: boolean
    descripcion?: boolean
    creditos?: boolean
    semestre?: boolean
    horasTeoria?: boolean
    horasPractica?: boolean
    activo?: boolean
    carreraId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MateriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clave" | "nombre" | "descripcion" | "creditos" | "semestre" | "horasTeoria" | "horasPractica" | "activo" | "carreraId" | "createdAt" | "updatedAt", ExtArgs["result"]["materia"]>
  export type MateriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    grupos?: boolean | Materia$gruposArgs<ExtArgs>
    calificaciones?: boolean | Materia$calificacionesArgs<ExtArgs>
    _count?: boolean | MateriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MateriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrera?: boolean | CarreraDefaultArgs<ExtArgs>
  }
  export type MateriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrera?: boolean | CarreraDefaultArgs<ExtArgs>
  }

  export type $MateriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materia"
    objects: {
      carrera: Prisma.$CarreraPayload<ExtArgs>
      grupos: Prisma.$GrupoPayload<ExtArgs>[]
      calificaciones: Prisma.$CalificacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clave: string
      nombre: string
      descripcion: string | null
      creditos: number
      semestre: number
      horasTeoria: number
      horasPractica: number
      activo: boolean
      carreraId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materia"]>
    composites: {}
  }

  type MateriaGetPayload<S extends boolean | null | undefined | MateriaDefaultArgs> = $Result.GetResult<Prisma.$MateriaPayload, S>

  type MateriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MateriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MateriaCountAggregateInputType | true
    }

  export interface MateriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materia'], meta: { name: 'Materia' } }
    /**
     * Find zero or one Materia that matches the filter.
     * @param {MateriaFindUniqueArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MateriaFindUniqueArgs>(args: SelectSubset<T, MateriaFindUniqueArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MateriaFindUniqueOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MateriaFindUniqueOrThrowArgs>(args: SelectSubset<T, MateriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindFirstArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MateriaFindFirstArgs>(args?: SelectSubset<T, MateriaFindFirstArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindFirstOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MateriaFindFirstOrThrowArgs>(args?: SelectSubset<T, MateriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materias
     * const materias = await prisma.materia.findMany()
     * 
     * // Get first 10 Materias
     * const materias = await prisma.materia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materiaWithIdOnly = await prisma.materia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MateriaFindManyArgs>(args?: SelectSubset<T, MateriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materia.
     * @param {MateriaCreateArgs} args - Arguments to create a Materia.
     * @example
     * // Create one Materia
     * const Materia = await prisma.materia.create({
     *   data: {
     *     // ... data to create a Materia
     *   }
     * })
     * 
     */
    create<T extends MateriaCreateArgs>(args: SelectSubset<T, MateriaCreateArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materias.
     * @param {MateriaCreateManyArgs} args - Arguments to create many Materias.
     * @example
     * // Create many Materias
     * const materia = await prisma.materia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MateriaCreateManyArgs>(args?: SelectSubset<T, MateriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materias and returns the data saved in the database.
     * @param {MateriaCreateManyAndReturnArgs} args - Arguments to create many Materias.
     * @example
     * // Create many Materias
     * const materia = await prisma.materia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materias and only return the `id`
     * const materiaWithIdOnly = await prisma.materia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MateriaCreateManyAndReturnArgs>(args?: SelectSubset<T, MateriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Materia.
     * @param {MateriaDeleteArgs} args - Arguments to delete one Materia.
     * @example
     * // Delete one Materia
     * const Materia = await prisma.materia.delete({
     *   where: {
     *     // ... filter to delete one Materia
     *   }
     * })
     * 
     */
    delete<T extends MateriaDeleteArgs>(args: SelectSubset<T, MateriaDeleteArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materia.
     * @param {MateriaUpdateArgs} args - Arguments to update one Materia.
     * @example
     * // Update one Materia
     * const materia = await prisma.materia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MateriaUpdateArgs>(args: SelectSubset<T, MateriaUpdateArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materias.
     * @param {MateriaDeleteManyArgs} args - Arguments to filter Materias to delete.
     * @example
     * // Delete a few Materias
     * const { count } = await prisma.materia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MateriaDeleteManyArgs>(args?: SelectSubset<T, MateriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materias
     * const materia = await prisma.materia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MateriaUpdateManyArgs>(args: SelectSubset<T, MateriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias and returns the data updated in the database.
     * @param {MateriaUpdateManyAndReturnArgs} args - Arguments to update many Materias.
     * @example
     * // Update many Materias
     * const materia = await prisma.materia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materias and only return the `id`
     * const materiaWithIdOnly = await prisma.materia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MateriaUpdateManyAndReturnArgs>(args: SelectSubset<T, MateriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Materia.
     * @param {MateriaUpsertArgs} args - Arguments to update or create a Materia.
     * @example
     * // Update or create a Materia
     * const materia = await prisma.materia.upsert({
     *   create: {
     *     // ... data to create a Materia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materia we want to update
     *   }
     * })
     */
    upsert<T extends MateriaUpsertArgs>(args: SelectSubset<T, MateriaUpsertArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaCountArgs} args - Arguments to filter Materias to count.
     * @example
     * // Count the number of Materias
     * const count = await prisma.materia.count({
     *   where: {
     *     // ... the filter for the Materias we want to count
     *   }
     * })
    **/
    count<T extends MateriaCountArgs>(
      args?: Subset<T, MateriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MateriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MateriaAggregateArgs>(args: Subset<T, MateriaAggregateArgs>): Prisma.PrismaPromise<GetMateriaAggregateType<T>>

    /**
     * Group by Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MateriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MateriaGroupByArgs['orderBy'] }
        : { orderBy?: MateriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MateriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materia model
   */
  readonly fields: MateriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MateriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carrera<T extends CarreraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarreraDefaultArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grupos<T extends Materia$gruposArgs<ExtArgs> = {}>(args?: Subset<T, Materia$gruposArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calificaciones<T extends Materia$calificacionesArgs<ExtArgs> = {}>(args?: Subset<T, Materia$calificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materia model
   */
  interface MateriaFieldRefs {
    readonly id: FieldRef<"Materia", 'String'>
    readonly clave: FieldRef<"Materia", 'String'>
    readonly nombre: FieldRef<"Materia", 'String'>
    readonly descripcion: FieldRef<"Materia", 'String'>
    readonly creditos: FieldRef<"Materia", 'Int'>
    readonly semestre: FieldRef<"Materia", 'Int'>
    readonly horasTeoria: FieldRef<"Materia", 'Int'>
    readonly horasPractica: FieldRef<"Materia", 'Int'>
    readonly activo: FieldRef<"Materia", 'Boolean'>
    readonly carreraId: FieldRef<"Materia", 'String'>
    readonly createdAt: FieldRef<"Materia", 'DateTime'>
    readonly updatedAt: FieldRef<"Materia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Materia findUnique
   */
  export type MateriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia findUniqueOrThrow
   */
  export type MateriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia findFirst
   */
  export type MateriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materias.
     */
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia findFirstOrThrow
   */
  export type MateriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materias.
     */
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia findMany
   */
  export type MateriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materias to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia create
   */
  export type MateriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Materia.
     */
    data: XOR<MateriaCreateInput, MateriaUncheckedCreateInput>
  }

  /**
   * Materia createMany
   */
  export type MateriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materias.
     */
    data: MateriaCreateManyInput | MateriaCreateManyInput[]
  }

  /**
   * Materia createManyAndReturn
   */
  export type MateriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * The data used to create many Materias.
     */
    data: MateriaCreateManyInput | MateriaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Materia update
   */
  export type MateriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Materia.
     */
    data: XOR<MateriaUpdateInput, MateriaUncheckedUpdateInput>
    /**
     * Choose, which Materia to update.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia updateMany
   */
  export type MateriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materias.
     */
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyInput>
    /**
     * Filter which Materias to update
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to update.
     */
    limit?: number
  }

  /**
   * Materia updateManyAndReturn
   */
  export type MateriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * The data used to update Materias.
     */
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyInput>
    /**
     * Filter which Materias to update
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Materia upsert
   */
  export type MateriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Materia to update in case it exists.
     */
    where: MateriaWhereUniqueInput
    /**
     * In case the Materia found by the `where` argument doesn't exist, create a new Materia with this data.
     */
    create: XOR<MateriaCreateInput, MateriaUncheckedCreateInput>
    /**
     * In case the Materia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MateriaUpdateInput, MateriaUncheckedUpdateInput>
  }

  /**
   * Materia delete
   */
  export type MateriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter which Materia to delete.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia deleteMany
   */
  export type MateriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materias to delete
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to delete.
     */
    limit?: number
  }

  /**
   * Materia.grupos
   */
  export type Materia$gruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    where?: GrupoWhereInput
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    cursor?: GrupoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Materia.calificaciones
   */
  export type Materia$calificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    where?: CalificacionWhereInput
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    cursor?: CalificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Materia without action
   */
  export type MateriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
  }


  /**
   * Model Grupo
   */

  export type AggregateGrupo = {
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  export type GrupoAvgAggregateOutputType = {
    cupoMaximo: number | null
    cupoDisponible: number | null
  }

  export type GrupoSumAggregateOutputType = {
    cupoMaximo: number | null
    cupoDisponible: number | null
  }

  export type GrupoMinAggregateOutputType = {
    id: string | null
    clave: string | null
    periodo: string | null
    cupoMaximo: number | null
    cupoDisponible: number | null
    horario: string | null
    aula: string | null
    activo: boolean | null
    materiaId: string | null
    profesorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GrupoMaxAggregateOutputType = {
    id: string | null
    clave: string | null
    periodo: string | null
    cupoMaximo: number | null
    cupoDisponible: number | null
    horario: string | null
    aula: string | null
    activo: boolean | null
    materiaId: string | null
    profesorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GrupoCountAggregateOutputType = {
    id: number
    clave: number
    periodo: number
    cupoMaximo: number
    cupoDisponible: number
    horario: number
    aula: number
    activo: number
    materiaId: number
    profesorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GrupoAvgAggregateInputType = {
    cupoMaximo?: true
    cupoDisponible?: true
  }

  export type GrupoSumAggregateInputType = {
    cupoMaximo?: true
    cupoDisponible?: true
  }

  export type GrupoMinAggregateInputType = {
    id?: true
    clave?: true
    periodo?: true
    cupoMaximo?: true
    cupoDisponible?: true
    horario?: true
    aula?: true
    activo?: true
    materiaId?: true
    profesorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GrupoMaxAggregateInputType = {
    id?: true
    clave?: true
    periodo?: true
    cupoMaximo?: true
    cupoDisponible?: true
    horario?: true
    aula?: true
    activo?: true
    materiaId?: true
    profesorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GrupoCountAggregateInputType = {
    id?: true
    clave?: true
    periodo?: true
    cupoMaximo?: true
    cupoDisponible?: true
    horario?: true
    aula?: true
    activo?: true
    materiaId?: true
    profesorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GrupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grupo to aggregate.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grupos
    **/
    _count?: true | GrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrupoMaxAggregateInputType
  }

  export type GetGrupoAggregateType<T extends GrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupo[P]>
      : GetScalarType<T[P], AggregateGrupo[P]>
  }




  export type GrupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrupoWhereInput
    orderBy?: GrupoOrderByWithAggregationInput | GrupoOrderByWithAggregationInput[]
    by: GrupoScalarFieldEnum[] | GrupoScalarFieldEnum
    having?: GrupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrupoCountAggregateInputType | true
    _avg?: GrupoAvgAggregateInputType
    _sum?: GrupoSumAggregateInputType
    _min?: GrupoMinAggregateInputType
    _max?: GrupoMaxAggregateInputType
  }

  export type GrupoGroupByOutputType = {
    id: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula: string | null
    activo: boolean
    materiaId: string
    profesorId: string
    createdAt: Date
    updatedAt: Date
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  type GetGrupoGroupByPayload<T extends GrupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrupoGroupByOutputType[P]>
            : GetScalarType<T[P], GrupoGroupByOutputType[P]>
        }
      >
    >


  export type GrupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    periodo?: boolean
    cupoMaximo?: boolean
    cupoDisponible?: boolean
    horario?: boolean
    aula?: boolean
    activo?: boolean
    materiaId?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    inscripciones?: boolean | Grupo$inscripcionesArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupo"]>

  export type GrupoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    periodo?: boolean
    cupoMaximo?: boolean
    cupoDisponible?: boolean
    horario?: boolean
    aula?: boolean
    activo?: boolean
    materiaId?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupo"]>

  export type GrupoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    periodo?: boolean
    cupoMaximo?: boolean
    cupoDisponible?: boolean
    horario?: boolean
    aula?: boolean
    activo?: boolean
    materiaId?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupo"]>

  export type GrupoSelectScalar = {
    id?: boolean
    clave?: boolean
    periodo?: boolean
    cupoMaximo?: boolean
    cupoDisponible?: boolean
    horario?: boolean
    aula?: boolean
    activo?: boolean
    materiaId?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GrupoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clave" | "periodo" | "cupoMaximo" | "cupoDisponible" | "horario" | "aula" | "activo" | "materiaId" | "profesorId" | "createdAt" | "updatedAt", ExtArgs["result"]["grupo"]>
  export type GrupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    inscripciones?: boolean | Grupo$inscripcionesArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GrupoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }
  export type GrupoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
  }

  export type $GrupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grupo"
    objects: {
      materia: Prisma.$MateriaPayload<ExtArgs>
      profesor: Prisma.$ProfesorPayload<ExtArgs>
      inscripciones: Prisma.$InscripcionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clave: string
      periodo: string
      cupoMaximo: number
      cupoDisponible: number
      horario: string
      aula: string | null
      activo: boolean
      materiaId: string
      profesorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["grupo"]>
    composites: {}
  }

  type GrupoGetPayload<S extends boolean | null | undefined | GrupoDefaultArgs> = $Result.GetResult<Prisma.$GrupoPayload, S>

  type GrupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GrupoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GrupoCountAggregateInputType | true
    }

  export interface GrupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grupo'], meta: { name: 'Grupo' } }
    /**
     * Find zero or one Grupo that matches the filter.
     * @param {GrupoFindUniqueArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GrupoFindUniqueArgs>(args: SelectSubset<T, GrupoFindUniqueArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grupo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GrupoFindUniqueOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GrupoFindUniqueOrThrowArgs>(args: SelectSubset<T, GrupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoFindFirstArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GrupoFindFirstArgs>(args?: SelectSubset<T, GrupoFindFirstArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoFindFirstOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GrupoFindFirstOrThrowArgs>(args?: SelectSubset<T, GrupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos
     * const grupos = await prisma.grupo.findMany()
     * 
     * // Get first 10 Grupos
     * const grupos = await prisma.grupo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grupoWithIdOnly = await prisma.grupo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GrupoFindManyArgs>(args?: SelectSubset<T, GrupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grupo.
     * @param {GrupoCreateArgs} args - Arguments to create a Grupo.
     * @example
     * // Create one Grupo
     * const Grupo = await prisma.grupo.create({
     *   data: {
     *     // ... data to create a Grupo
     *   }
     * })
     * 
     */
    create<T extends GrupoCreateArgs>(args: SelectSubset<T, GrupoCreateArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grupos.
     * @param {GrupoCreateManyArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GrupoCreateManyArgs>(args?: SelectSubset<T, GrupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grupos and returns the data saved in the database.
     * @param {GrupoCreateManyAndReturnArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grupos and only return the `id`
     * const grupoWithIdOnly = await prisma.grupo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GrupoCreateManyAndReturnArgs>(args?: SelectSubset<T, GrupoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grupo.
     * @param {GrupoDeleteArgs} args - Arguments to delete one Grupo.
     * @example
     * // Delete one Grupo
     * const Grupo = await prisma.grupo.delete({
     *   where: {
     *     // ... filter to delete one Grupo
     *   }
     * })
     * 
     */
    delete<T extends GrupoDeleteArgs>(args: SelectSubset<T, GrupoDeleteArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grupo.
     * @param {GrupoUpdateArgs} args - Arguments to update one Grupo.
     * @example
     * // Update one Grupo
     * const grupo = await prisma.grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GrupoUpdateArgs>(args: SelectSubset<T, GrupoUpdateArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grupos.
     * @param {GrupoDeleteManyArgs} args - Arguments to filter Grupos to delete.
     * @example
     * // Delete a few Grupos
     * const { count } = await prisma.grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GrupoDeleteManyArgs>(args?: SelectSubset<T, GrupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GrupoUpdateManyArgs>(args: SelectSubset<T, GrupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos and returns the data updated in the database.
     * @param {GrupoUpdateManyAndReturnArgs} args - Arguments to update many Grupos.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grupos and only return the `id`
     * const grupoWithIdOnly = await prisma.grupo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GrupoUpdateManyAndReturnArgs>(args: SelectSubset<T, GrupoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grupo.
     * @param {GrupoUpsertArgs} args - Arguments to update or create a Grupo.
     * @example
     * // Update or create a Grupo
     * const grupo = await prisma.grupo.upsert({
     *   create: {
     *     // ... data to create a Grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupo we want to update
     *   }
     * })
     */
    upsert<T extends GrupoUpsertArgs>(args: SelectSubset<T, GrupoUpsertArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoCountArgs} args - Arguments to filter Grupos to count.
     * @example
     * // Count the number of Grupos
     * const count = await prisma.grupo.count({
     *   where: {
     *     // ... the filter for the Grupos we want to count
     *   }
     * })
    **/
    count<T extends GrupoCountArgs>(
      args?: Subset<T, GrupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrupoAggregateArgs>(args: Subset<T, GrupoAggregateArgs>): Prisma.PrismaPromise<GetGrupoAggregateType<T>>

    /**
     * Group by Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GrupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GrupoGroupByArgs['orderBy'] }
        : { orderBy?: GrupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GrupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grupo model
   */
  readonly fields: GrupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GrupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materia<T extends MateriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MateriaDefaultArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profesor<T extends ProfesorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfesorDefaultArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inscripciones<T extends Grupo$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, Grupo$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grupo model
   */
  interface GrupoFieldRefs {
    readonly id: FieldRef<"Grupo", 'String'>
    readonly clave: FieldRef<"Grupo", 'String'>
    readonly periodo: FieldRef<"Grupo", 'String'>
    readonly cupoMaximo: FieldRef<"Grupo", 'Int'>
    readonly cupoDisponible: FieldRef<"Grupo", 'Int'>
    readonly horario: FieldRef<"Grupo", 'String'>
    readonly aula: FieldRef<"Grupo", 'String'>
    readonly activo: FieldRef<"Grupo", 'Boolean'>
    readonly materiaId: FieldRef<"Grupo", 'String'>
    readonly profesorId: FieldRef<"Grupo", 'String'>
    readonly createdAt: FieldRef<"Grupo", 'DateTime'>
    readonly updatedAt: FieldRef<"Grupo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grupo findUnique
   */
  export type GrupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo findUniqueOrThrow
   */
  export type GrupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo findFirst
   */
  export type GrupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grupos.
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Grupo findFirstOrThrow
   */
  export type GrupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grupos.
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Grupo findMany
   */
  export type GrupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupos to fetch.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grupos.
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Grupo create
   */
  export type GrupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * The data needed to create a Grupo.
     */
    data: XOR<GrupoCreateInput, GrupoUncheckedCreateInput>
  }

  /**
   * Grupo createMany
   */
  export type GrupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grupos.
     */
    data: GrupoCreateManyInput | GrupoCreateManyInput[]
  }

  /**
   * Grupo createManyAndReturn
   */
  export type GrupoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * The data used to create many Grupos.
     */
    data: GrupoCreateManyInput | GrupoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grupo update
   */
  export type GrupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * The data needed to update a Grupo.
     */
    data: XOR<GrupoUpdateInput, GrupoUncheckedUpdateInput>
    /**
     * Choose, which Grupo to update.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo updateMany
   */
  export type GrupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grupos.
     */
    data: XOR<GrupoUpdateManyMutationInput, GrupoUncheckedUpdateManyInput>
    /**
     * Filter which Grupos to update
     */
    where?: GrupoWhereInput
    /**
     * Limit how many Grupos to update.
     */
    limit?: number
  }

  /**
   * Grupo updateManyAndReturn
   */
  export type GrupoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * The data used to update Grupos.
     */
    data: XOR<GrupoUpdateManyMutationInput, GrupoUncheckedUpdateManyInput>
    /**
     * Filter which Grupos to update
     */
    where?: GrupoWhereInput
    /**
     * Limit how many Grupos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grupo upsert
   */
  export type GrupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * The filter to search for the Grupo to update in case it exists.
     */
    where: GrupoWhereUniqueInput
    /**
     * In case the Grupo found by the `where` argument doesn't exist, create a new Grupo with this data.
     */
    create: XOR<GrupoCreateInput, GrupoUncheckedCreateInput>
    /**
     * In case the Grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GrupoUpdateInput, GrupoUncheckedUpdateInput>
  }

  /**
   * Grupo delete
   */
  export type GrupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter which Grupo to delete.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo deleteMany
   */
  export type GrupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grupos to delete
     */
    where?: GrupoWhereInput
    /**
     * Limit how many Grupos to delete.
     */
    limit?: number
  }

  /**
   * Grupo.inscripciones
   */
  export type Grupo$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    cursor?: InscripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Grupo without action
   */
  export type GrupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
  }


  /**
   * Model Inscripcion
   */

  export type AggregateInscripcion = {
    _count: InscripcionCountAggregateOutputType | null
    _min: InscripcionMinAggregateOutputType | null
    _max: InscripcionMaxAggregateOutputType | null
  }

  export type InscripcionMinAggregateOutputType = {
    id: string | null
    periodo: string | null
    estatus: $Enums.EstatusInscripcion | null
    fechaInscripcion: Date | null
    estudianteId: string | null
    grupoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InscripcionMaxAggregateOutputType = {
    id: string | null
    periodo: string | null
    estatus: $Enums.EstatusInscripcion | null
    fechaInscripcion: Date | null
    estudianteId: string | null
    grupoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InscripcionCountAggregateOutputType = {
    id: number
    periodo: number
    estatus: number
    fechaInscripcion: number
    estudianteId: number
    grupoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InscripcionMinAggregateInputType = {
    id?: true
    periodo?: true
    estatus?: true
    fechaInscripcion?: true
    estudianteId?: true
    grupoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InscripcionMaxAggregateInputType = {
    id?: true
    periodo?: true
    estatus?: true
    fechaInscripcion?: true
    estudianteId?: true
    grupoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InscripcionCountAggregateInputType = {
    id?: true
    periodo?: true
    estatus?: true
    fechaInscripcion?: true
    estudianteId?: true
    grupoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InscripcionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscripcion to aggregate.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inscripcions
    **/
    _count?: true | InscripcionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscripcionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscripcionMaxAggregateInputType
  }

  export type GetInscripcionAggregateType<T extends InscripcionAggregateArgs> = {
        [P in keyof T & keyof AggregateInscripcion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscripcion[P]>
      : GetScalarType<T[P], AggregateInscripcion[P]>
  }




  export type InscripcionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithAggregationInput | InscripcionOrderByWithAggregationInput[]
    by: InscripcionScalarFieldEnum[] | InscripcionScalarFieldEnum
    having?: InscripcionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscripcionCountAggregateInputType | true
    _min?: InscripcionMinAggregateInputType
    _max?: InscripcionMaxAggregateInputType
  }

  export type InscripcionGroupByOutputType = {
    id: string
    periodo: string
    estatus: $Enums.EstatusInscripcion
    fechaInscripcion: Date
    estudianteId: string
    grupoId: string
    createdAt: Date
    updatedAt: Date
    _count: InscripcionCountAggregateOutputType | null
    _min: InscripcionMinAggregateOutputType | null
    _max: InscripcionMaxAggregateOutputType | null
  }

  type GetInscripcionGroupByPayload<T extends InscripcionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscripcionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscripcionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscripcionGroupByOutputType[P]>
            : GetScalarType<T[P], InscripcionGroupByOutputType[P]>
        }
      >
    >


  export type InscripcionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodo?: boolean
    estatus?: boolean
    fechaInscripcion?: boolean
    estudianteId?: boolean
    grupoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    grupo?: boolean | GrupoDefaultArgs<ExtArgs>
    calificacion?: boolean | Inscripcion$calificacionArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion"]>

  export type InscripcionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodo?: boolean
    estatus?: boolean
    fechaInscripcion?: boolean
    estudianteId?: boolean
    grupoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    grupo?: boolean | GrupoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion"]>

  export type InscripcionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodo?: boolean
    estatus?: boolean
    fechaInscripcion?: boolean
    estudianteId?: boolean
    grupoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    grupo?: boolean | GrupoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion"]>

  export type InscripcionSelectScalar = {
    id?: boolean
    periodo?: boolean
    estatus?: boolean
    fechaInscripcion?: boolean
    estudianteId?: boolean
    grupoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InscripcionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "periodo" | "estatus" | "fechaInscripcion" | "estudianteId" | "grupoId" | "createdAt" | "updatedAt", ExtArgs["result"]["inscripcion"]>
  export type InscripcionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    grupo?: boolean | GrupoDefaultArgs<ExtArgs>
    calificacion?: boolean | Inscripcion$calificacionArgs<ExtArgs>
  }
  export type InscripcionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    grupo?: boolean | GrupoDefaultArgs<ExtArgs>
  }
  export type InscripcionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    grupo?: boolean | GrupoDefaultArgs<ExtArgs>
  }

  export type $InscripcionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inscripcion"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
      grupo: Prisma.$GrupoPayload<ExtArgs>
      calificacion: Prisma.$CalificacionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      periodo: string
      estatus: $Enums.EstatusInscripcion
      fechaInscripcion: Date
      estudianteId: string
      grupoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inscripcion"]>
    composites: {}
  }

  type InscripcionGetPayload<S extends boolean | null | undefined | InscripcionDefaultArgs> = $Result.GetResult<Prisma.$InscripcionPayload, S>

  type InscripcionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InscripcionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InscripcionCountAggregateInputType | true
    }

  export interface InscripcionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inscripcion'], meta: { name: 'Inscripcion' } }
    /**
     * Find zero or one Inscripcion that matches the filter.
     * @param {InscripcionFindUniqueArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InscripcionFindUniqueArgs>(args: SelectSubset<T, InscripcionFindUniqueArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inscripcion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InscripcionFindUniqueOrThrowArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InscripcionFindUniqueOrThrowArgs>(args: SelectSubset<T, InscripcionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripcion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindFirstArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InscripcionFindFirstArgs>(args?: SelectSubset<T, InscripcionFindFirstArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripcion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindFirstOrThrowArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InscripcionFindFirstOrThrowArgs>(args?: SelectSubset<T, InscripcionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inscripcions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripcions
     * const inscripcions = await prisma.inscripcion.findMany()
     * 
     * // Get first 10 Inscripcions
     * const inscripcions = await prisma.inscripcion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InscripcionFindManyArgs>(args?: SelectSubset<T, InscripcionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inscripcion.
     * @param {InscripcionCreateArgs} args - Arguments to create a Inscripcion.
     * @example
     * // Create one Inscripcion
     * const Inscripcion = await prisma.inscripcion.create({
     *   data: {
     *     // ... data to create a Inscripcion
     *   }
     * })
     * 
     */
    create<T extends InscripcionCreateArgs>(args: SelectSubset<T, InscripcionCreateArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inscripcions.
     * @param {InscripcionCreateManyArgs} args - Arguments to create many Inscripcions.
     * @example
     * // Create many Inscripcions
     * const inscripcion = await prisma.inscripcion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InscripcionCreateManyArgs>(args?: SelectSubset<T, InscripcionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inscripcions and returns the data saved in the database.
     * @param {InscripcionCreateManyAndReturnArgs} args - Arguments to create many Inscripcions.
     * @example
     * // Create many Inscripcions
     * const inscripcion = await prisma.inscripcion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inscripcions and only return the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InscripcionCreateManyAndReturnArgs>(args?: SelectSubset<T, InscripcionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inscripcion.
     * @param {InscripcionDeleteArgs} args - Arguments to delete one Inscripcion.
     * @example
     * // Delete one Inscripcion
     * const Inscripcion = await prisma.inscripcion.delete({
     *   where: {
     *     // ... filter to delete one Inscripcion
     *   }
     * })
     * 
     */
    delete<T extends InscripcionDeleteArgs>(args: SelectSubset<T, InscripcionDeleteArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inscripcion.
     * @param {InscripcionUpdateArgs} args - Arguments to update one Inscripcion.
     * @example
     * // Update one Inscripcion
     * const inscripcion = await prisma.inscripcion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InscripcionUpdateArgs>(args: SelectSubset<T, InscripcionUpdateArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inscripcions.
     * @param {InscripcionDeleteManyArgs} args - Arguments to filter Inscripcions to delete.
     * @example
     * // Delete a few Inscripcions
     * const { count } = await prisma.inscripcion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InscripcionDeleteManyArgs>(args?: SelectSubset<T, InscripcionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripcions
     * const inscripcion = await prisma.inscripcion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InscripcionUpdateManyArgs>(args: SelectSubset<T, InscripcionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripcions and returns the data updated in the database.
     * @param {InscripcionUpdateManyAndReturnArgs} args - Arguments to update many Inscripcions.
     * @example
     * // Update many Inscripcions
     * const inscripcion = await prisma.inscripcion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inscripcions and only return the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InscripcionUpdateManyAndReturnArgs>(args: SelectSubset<T, InscripcionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inscripcion.
     * @param {InscripcionUpsertArgs} args - Arguments to update or create a Inscripcion.
     * @example
     * // Update or create a Inscripcion
     * const inscripcion = await prisma.inscripcion.upsert({
     *   create: {
     *     // ... data to create a Inscripcion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripcion we want to update
     *   }
     * })
     */
    upsert<T extends InscripcionUpsertArgs>(args: SelectSubset<T, InscripcionUpsertArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionCountArgs} args - Arguments to filter Inscripcions to count.
     * @example
     * // Count the number of Inscripcions
     * const count = await prisma.inscripcion.count({
     *   where: {
     *     // ... the filter for the Inscripcions we want to count
     *   }
     * })
    **/
    count<T extends InscripcionCountArgs>(
      args?: Subset<T, InscripcionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscripcionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscripcionAggregateArgs>(args: Subset<T, InscripcionAggregateArgs>): Prisma.PrismaPromise<GetInscripcionAggregateType<T>>

    /**
     * Group by Inscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InscripcionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InscripcionGroupByArgs['orderBy'] }
        : { orderBy?: InscripcionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InscripcionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscripcionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inscripcion model
   */
  readonly fields: InscripcionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inscripcion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InscripcionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grupo<T extends GrupoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GrupoDefaultArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calificacion<T extends Inscripcion$calificacionArgs<ExtArgs> = {}>(args?: Subset<T, Inscripcion$calificacionArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inscripcion model
   */
  interface InscripcionFieldRefs {
    readonly id: FieldRef<"Inscripcion", 'String'>
    readonly periodo: FieldRef<"Inscripcion", 'String'>
    readonly estatus: FieldRef<"Inscripcion", 'EstatusInscripcion'>
    readonly fechaInscripcion: FieldRef<"Inscripcion", 'DateTime'>
    readonly estudianteId: FieldRef<"Inscripcion", 'String'>
    readonly grupoId: FieldRef<"Inscripcion", 'String'>
    readonly createdAt: FieldRef<"Inscripcion", 'DateTime'>
    readonly updatedAt: FieldRef<"Inscripcion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inscripcion findUnique
   */
  export type InscripcionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion findUniqueOrThrow
   */
  export type InscripcionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion findFirst
   */
  export type InscripcionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscripcions.
     */
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Inscripcion findFirstOrThrow
   */
  export type InscripcionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscripcions.
     */
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Inscripcion findMany
   */
  export type InscripcionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcions to fetch.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Inscripcion create
   */
  export type InscripcionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * The data needed to create a Inscripcion.
     */
    data: XOR<InscripcionCreateInput, InscripcionUncheckedCreateInput>
  }

  /**
   * Inscripcion createMany
   */
  export type InscripcionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inscripcions.
     */
    data: InscripcionCreateManyInput | InscripcionCreateManyInput[]
  }

  /**
   * Inscripcion createManyAndReturn
   */
  export type InscripcionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * The data used to create many Inscripcions.
     */
    data: InscripcionCreateManyInput | InscripcionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inscripcion update
   */
  export type InscripcionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * The data needed to update a Inscripcion.
     */
    data: XOR<InscripcionUpdateInput, InscripcionUncheckedUpdateInput>
    /**
     * Choose, which Inscripcion to update.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion updateMany
   */
  export type InscripcionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inscripcions.
     */
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyInput>
    /**
     * Filter which Inscripcions to update
     */
    where?: InscripcionWhereInput
    /**
     * Limit how many Inscripcions to update.
     */
    limit?: number
  }

  /**
   * Inscripcion updateManyAndReturn
   */
  export type InscripcionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * The data used to update Inscripcions.
     */
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyInput>
    /**
     * Filter which Inscripcions to update
     */
    where?: InscripcionWhereInput
    /**
     * Limit how many Inscripcions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inscripcion upsert
   */
  export type InscripcionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * The filter to search for the Inscripcion to update in case it exists.
     */
    where: InscripcionWhereUniqueInput
    /**
     * In case the Inscripcion found by the `where` argument doesn't exist, create a new Inscripcion with this data.
     */
    create: XOR<InscripcionCreateInput, InscripcionUncheckedCreateInput>
    /**
     * In case the Inscripcion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InscripcionUpdateInput, InscripcionUncheckedUpdateInput>
  }

  /**
   * Inscripcion delete
   */
  export type InscripcionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter which Inscripcion to delete.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion deleteMany
   */
  export type InscripcionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscripcions to delete
     */
    where?: InscripcionWhereInput
    /**
     * Limit how many Inscripcions to delete.
     */
    limit?: number
  }

  /**
   * Inscripcion.calificacion
   */
  export type Inscripcion$calificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    where?: CalificacionWhereInput
  }

  /**
   * Inscripcion without action
   */
  export type InscripcionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
  }


  /**
   * Model Calificacion
   */

  export type AggregateCalificacion = {
    _count: CalificacionCountAggregateOutputType | null
    _avg: CalificacionAvgAggregateOutputType | null
    _sum: CalificacionSumAggregateOutputType | null
    _min: CalificacionMinAggregateOutputType | null
    _max: CalificacionMaxAggregateOutputType | null
  }

  export type CalificacionAvgAggregateOutputType = {
    calificacion: number | null
  }

  export type CalificacionSumAggregateOutputType = {
    calificacion: number | null
  }

  export type CalificacionMinAggregateOutputType = {
    id: string | null
    calificacion: number | null
    estatus: string | null
    observaciones: string | null
    estudianteId: string | null
    materiaId: string | null
    inscripcionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalificacionMaxAggregateOutputType = {
    id: string | null
    calificacion: number | null
    estatus: string | null
    observaciones: string | null
    estudianteId: string | null
    materiaId: string | null
    inscripcionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalificacionCountAggregateOutputType = {
    id: number
    calificacion: number
    estatus: number
    observaciones: number
    estudianteId: number
    materiaId: number
    inscripcionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalificacionAvgAggregateInputType = {
    calificacion?: true
  }

  export type CalificacionSumAggregateInputType = {
    calificacion?: true
  }

  export type CalificacionMinAggregateInputType = {
    id?: true
    calificacion?: true
    estatus?: true
    observaciones?: true
    estudianteId?: true
    materiaId?: true
    inscripcionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalificacionMaxAggregateInputType = {
    id?: true
    calificacion?: true
    estatus?: true
    observaciones?: true
    estudianteId?: true
    materiaId?: true
    inscripcionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalificacionCountAggregateInputType = {
    id?: true
    calificacion?: true
    estatus?: true
    observaciones?: true
    estudianteId?: true
    materiaId?: true
    inscripcionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calificacion to aggregate.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calificacions
    **/
    _count?: true | CalificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalificacionMaxAggregateInputType
  }

  export type GetCalificacionAggregateType<T extends CalificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateCalificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalificacion[P]>
      : GetScalarType<T[P], AggregateCalificacion[P]>
  }




  export type CalificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalificacionWhereInput
    orderBy?: CalificacionOrderByWithAggregationInput | CalificacionOrderByWithAggregationInput[]
    by: CalificacionScalarFieldEnum[] | CalificacionScalarFieldEnum
    having?: CalificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalificacionCountAggregateInputType | true
    _avg?: CalificacionAvgAggregateInputType
    _sum?: CalificacionSumAggregateInputType
    _min?: CalificacionMinAggregateInputType
    _max?: CalificacionMaxAggregateInputType
  }

  export type CalificacionGroupByOutputType = {
    id: string
    calificacion: number
    estatus: string
    observaciones: string | null
    estudianteId: string
    materiaId: string
    inscripcionId: string
    createdAt: Date
    updatedAt: Date
    _count: CalificacionCountAggregateOutputType | null
    _avg: CalificacionAvgAggregateOutputType | null
    _sum: CalificacionSumAggregateOutputType | null
    _min: CalificacionMinAggregateOutputType | null
    _max: CalificacionMaxAggregateOutputType | null
  }

  type GetCalificacionGroupByPayload<T extends CalificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalificacionGroupByOutputType[P]>
            : GetScalarType<T[P], CalificacionGroupByOutputType[P]>
        }
      >
    >


  export type CalificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calificacion?: boolean
    estatus?: boolean
    observaciones?: boolean
    estudianteId?: boolean
    materiaId?: boolean
    inscripcionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificacion"]>

  export type CalificacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calificacion?: boolean
    estatus?: boolean
    observaciones?: boolean
    estudianteId?: boolean
    materiaId?: boolean
    inscripcionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificacion"]>

  export type CalificacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calificacion?: boolean
    estatus?: boolean
    observaciones?: boolean
    estudianteId?: boolean
    materiaId?: boolean
    inscripcionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificacion"]>

  export type CalificacionSelectScalar = {
    id?: boolean
    calificacion?: boolean
    estatus?: boolean
    observaciones?: boolean
    estudianteId?: boolean
    materiaId?: boolean
    inscripcionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "calificacion" | "estatus" | "observaciones" | "estudianteId" | "materiaId" | "inscripcionId" | "createdAt" | "updatedAt", ExtArgs["result"]["calificacion"]>
  export type CalificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
  }
  export type CalificacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
  }
  export type CalificacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    materia?: boolean | MateriaDefaultArgs<ExtArgs>
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
  }

  export type $CalificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Calificacion"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
      materia: Prisma.$MateriaPayload<ExtArgs>
      inscripcion: Prisma.$InscripcionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      calificacion: number
      estatus: string
      observaciones: string | null
      estudianteId: string
      materiaId: string
      inscripcionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calificacion"]>
    composites: {}
  }

  type CalificacionGetPayload<S extends boolean | null | undefined | CalificacionDefaultArgs> = $Result.GetResult<Prisma.$CalificacionPayload, S>

  type CalificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalificacionCountAggregateInputType | true
    }

  export interface CalificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Calificacion'], meta: { name: 'Calificacion' } }
    /**
     * Find zero or one Calificacion that matches the filter.
     * @param {CalificacionFindUniqueArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalificacionFindUniqueArgs>(args: SelectSubset<T, CalificacionFindUniqueArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalificacionFindUniqueOrThrowArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, CalificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionFindFirstArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalificacionFindFirstArgs>(args?: SelectSubset<T, CalificacionFindFirstArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionFindFirstOrThrowArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, CalificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calificacions
     * const calificacions = await prisma.calificacion.findMany()
     * 
     * // Get first 10 Calificacions
     * const calificacions = await prisma.calificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calificacionWithIdOnly = await prisma.calificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalificacionFindManyArgs>(args?: SelectSubset<T, CalificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calificacion.
     * @param {CalificacionCreateArgs} args - Arguments to create a Calificacion.
     * @example
     * // Create one Calificacion
     * const Calificacion = await prisma.calificacion.create({
     *   data: {
     *     // ... data to create a Calificacion
     *   }
     * })
     * 
     */
    create<T extends CalificacionCreateArgs>(args: SelectSubset<T, CalificacionCreateArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calificacions.
     * @param {CalificacionCreateManyArgs} args - Arguments to create many Calificacions.
     * @example
     * // Create many Calificacions
     * const calificacion = await prisma.calificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalificacionCreateManyArgs>(args?: SelectSubset<T, CalificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calificacions and returns the data saved in the database.
     * @param {CalificacionCreateManyAndReturnArgs} args - Arguments to create many Calificacions.
     * @example
     * // Create many Calificacions
     * const calificacion = await prisma.calificacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calificacions and only return the `id`
     * const calificacionWithIdOnly = await prisma.calificacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalificacionCreateManyAndReturnArgs>(args?: SelectSubset<T, CalificacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Calificacion.
     * @param {CalificacionDeleteArgs} args - Arguments to delete one Calificacion.
     * @example
     * // Delete one Calificacion
     * const Calificacion = await prisma.calificacion.delete({
     *   where: {
     *     // ... filter to delete one Calificacion
     *   }
     * })
     * 
     */
    delete<T extends CalificacionDeleteArgs>(args: SelectSubset<T, CalificacionDeleteArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calificacion.
     * @param {CalificacionUpdateArgs} args - Arguments to update one Calificacion.
     * @example
     * // Update one Calificacion
     * const calificacion = await prisma.calificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalificacionUpdateArgs>(args: SelectSubset<T, CalificacionUpdateArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calificacions.
     * @param {CalificacionDeleteManyArgs} args - Arguments to filter Calificacions to delete.
     * @example
     * // Delete a few Calificacions
     * const { count } = await prisma.calificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalificacionDeleteManyArgs>(args?: SelectSubset<T, CalificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calificacions
     * const calificacion = await prisma.calificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalificacionUpdateManyArgs>(args: SelectSubset<T, CalificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificacions and returns the data updated in the database.
     * @param {CalificacionUpdateManyAndReturnArgs} args - Arguments to update many Calificacions.
     * @example
     * // Update many Calificacions
     * const calificacion = await prisma.calificacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calificacions and only return the `id`
     * const calificacionWithIdOnly = await prisma.calificacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalificacionUpdateManyAndReturnArgs>(args: SelectSubset<T, CalificacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Calificacion.
     * @param {CalificacionUpsertArgs} args - Arguments to update or create a Calificacion.
     * @example
     * // Update or create a Calificacion
     * const calificacion = await prisma.calificacion.upsert({
     *   create: {
     *     // ... data to create a Calificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calificacion we want to update
     *   }
     * })
     */
    upsert<T extends CalificacionUpsertArgs>(args: SelectSubset<T, CalificacionUpsertArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionCountArgs} args - Arguments to filter Calificacions to count.
     * @example
     * // Count the number of Calificacions
     * const count = await prisma.calificacion.count({
     *   where: {
     *     // ... the filter for the Calificacions we want to count
     *   }
     * })
    **/
    count<T extends CalificacionCountArgs>(
      args?: Subset<T, CalificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalificacionAggregateArgs>(args: Subset<T, CalificacionAggregateArgs>): Prisma.PrismaPromise<GetCalificacionAggregateType<T>>

    /**
     * Group by Calificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalificacionGroupByArgs['orderBy'] }
        : { orderBy?: CalificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Calificacion model
   */
  readonly fields: CalificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materia<T extends MateriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MateriaDefaultArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inscripcion<T extends InscripcionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InscripcionDefaultArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Calificacion model
   */
  interface CalificacionFieldRefs {
    readonly id: FieldRef<"Calificacion", 'String'>
    readonly calificacion: FieldRef<"Calificacion", 'Float'>
    readonly estatus: FieldRef<"Calificacion", 'String'>
    readonly observaciones: FieldRef<"Calificacion", 'String'>
    readonly estudianteId: FieldRef<"Calificacion", 'String'>
    readonly materiaId: FieldRef<"Calificacion", 'String'>
    readonly inscripcionId: FieldRef<"Calificacion", 'String'>
    readonly createdAt: FieldRef<"Calificacion", 'DateTime'>
    readonly updatedAt: FieldRef<"Calificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Calificacion findUnique
   */
  export type CalificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion findUniqueOrThrow
   */
  export type CalificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion findFirst
   */
  export type CalificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calificacions.
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calificacions.
     */
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Calificacion findFirstOrThrow
   */
  export type CalificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calificacions.
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calificacions.
     */
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Calificacion findMany
   */
  export type CalificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacions to fetch.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calificacions.
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Calificacion create
   */
  export type CalificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Calificacion.
     */
    data: XOR<CalificacionCreateInput, CalificacionUncheckedCreateInput>
  }

  /**
   * Calificacion createMany
   */
  export type CalificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calificacions.
     */
    data: CalificacionCreateManyInput | CalificacionCreateManyInput[]
  }

  /**
   * Calificacion createManyAndReturn
   */
  export type CalificacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * The data used to create many Calificacions.
     */
    data: CalificacionCreateManyInput | CalificacionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calificacion update
   */
  export type CalificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Calificacion.
     */
    data: XOR<CalificacionUpdateInput, CalificacionUncheckedUpdateInput>
    /**
     * Choose, which Calificacion to update.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion updateMany
   */
  export type CalificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calificacions.
     */
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyInput>
    /**
     * Filter which Calificacions to update
     */
    where?: CalificacionWhereInput
    /**
     * Limit how many Calificacions to update.
     */
    limit?: number
  }

  /**
   * Calificacion updateManyAndReturn
   */
  export type CalificacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * The data used to update Calificacions.
     */
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyInput>
    /**
     * Filter which Calificacions to update
     */
    where?: CalificacionWhereInput
    /**
     * Limit how many Calificacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calificacion upsert
   */
  export type CalificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Calificacion to update in case it exists.
     */
    where: CalificacionWhereUniqueInput
    /**
     * In case the Calificacion found by the `where` argument doesn't exist, create a new Calificacion with this data.
     */
    create: XOR<CalificacionCreateInput, CalificacionUncheckedCreateInput>
    /**
     * In case the Calificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalificacionUpdateInput, CalificacionUncheckedUpdateInput>
  }

  /**
   * Calificacion delete
   */
  export type CalificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter which Calificacion to delete.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion deleteMany
   */
  export type CalificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calificacions to delete
     */
    where?: CalificacionWhereInput
    /**
     * Limit how many Calificacions to delete.
     */
    limit?: number
  }

  /**
   * Calificacion without action
   */
  export type CalificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
  }


  /**
   * Model Profesor
   */

  export type AggregateProfesor = {
    _count: ProfesorCountAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  export type ProfesorMinAggregateOutputType = {
    id: string | null
    numeroEmpleado: string | null
    especialidad: string | null
    grado: string | null
    departamento: string | null
    activo: boolean | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfesorMaxAggregateOutputType = {
    id: string | null
    numeroEmpleado: string | null
    especialidad: string | null
    grado: string | null
    departamento: string | null
    activo: boolean | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfesorCountAggregateOutputType = {
    id: number
    numeroEmpleado: number
    especialidad: number
    grado: number
    departamento: number
    activo: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfesorMinAggregateInputType = {
    id?: true
    numeroEmpleado?: true
    especialidad?: true
    grado?: true
    departamento?: true
    activo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfesorMaxAggregateInputType = {
    id?: true
    numeroEmpleado?: true
    especialidad?: true
    grado?: true
    departamento?: true
    activo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfesorCountAggregateInputType = {
    id?: true
    numeroEmpleado?: true
    especialidad?: true
    grado?: true
    departamento?: true
    activo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfesorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesor to aggregate.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profesors
    **/
    _count?: true | ProfesorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesorMaxAggregateInputType
  }

  export type GetProfesorAggregateType<T extends ProfesorAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesor[P]>
      : GetScalarType<T[P], AggregateProfesor[P]>
  }




  export type ProfesorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfesorWhereInput
    orderBy?: ProfesorOrderByWithAggregationInput | ProfesorOrderByWithAggregationInput[]
    by: ProfesorScalarFieldEnum[] | ProfesorScalarFieldEnum
    having?: ProfesorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesorCountAggregateInputType | true
    _min?: ProfesorMinAggregateInputType
    _max?: ProfesorMaxAggregateInputType
  }

  export type ProfesorGroupByOutputType = {
    id: string
    numeroEmpleado: string
    especialidad: string | null
    grado: string | null
    departamento: string | null
    activo: boolean
    usuarioId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfesorCountAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  type GetProfesorGroupByPayload<T extends ProfesorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfesorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
        }
      >
    >


  export type ProfesorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEmpleado?: boolean
    especialidad?: boolean
    grado?: boolean
    departamento?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    grupos?: boolean | Profesor$gruposArgs<ExtArgs>
    _count?: boolean | ProfesorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEmpleado?: boolean
    especialidad?: boolean
    grado?: boolean
    departamento?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEmpleado?: boolean
    especialidad?: boolean
    grado?: boolean
    departamento?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectScalar = {
    id?: boolean
    numeroEmpleado?: boolean
    especialidad?: boolean
    grado?: boolean
    departamento?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfesorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroEmpleado" | "especialidad" | "grado" | "departamento" | "activo" | "usuarioId" | "createdAt" | "updatedAt", ExtArgs["result"]["profesor"]>
  export type ProfesorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    grupos?: boolean | Profesor$gruposArgs<ExtArgs>
    _count?: boolean | ProfesorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfesorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ProfesorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ProfesorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profesor"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      grupos: Prisma.$GrupoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroEmpleado: string
      especialidad: string | null
      grado: string | null
      departamento: string | null
      activo: boolean
      usuarioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profesor"]>
    composites: {}
  }

  type ProfesorGetPayload<S extends boolean | null | undefined | ProfesorDefaultArgs> = $Result.GetResult<Prisma.$ProfesorPayload, S>

  type ProfesorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfesorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfesorCountAggregateInputType | true
    }

  export interface ProfesorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profesor'], meta: { name: 'Profesor' } }
    /**
     * Find zero or one Profesor that matches the filter.
     * @param {ProfesorFindUniqueArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfesorFindUniqueArgs>(args: SelectSubset<T, ProfesorFindUniqueArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profesor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfesorFindUniqueOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfesorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfesorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profesor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindFirstArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfesorFindFirstArgs>(args?: SelectSubset<T, ProfesorFindFirstArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profesor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindFirstOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfesorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfesorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profesors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profesors
     * const profesors = await prisma.profesor.findMany()
     * 
     * // Get first 10 Profesors
     * const profesors = await prisma.profesor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profesorWithIdOnly = await prisma.profesor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfesorFindManyArgs>(args?: SelectSubset<T, ProfesorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profesor.
     * @param {ProfesorCreateArgs} args - Arguments to create a Profesor.
     * @example
     * // Create one Profesor
     * const Profesor = await prisma.profesor.create({
     *   data: {
     *     // ... data to create a Profesor
     *   }
     * })
     * 
     */
    create<T extends ProfesorCreateArgs>(args: SelectSubset<T, ProfesorCreateArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profesors.
     * @param {ProfesorCreateManyArgs} args - Arguments to create many Profesors.
     * @example
     * // Create many Profesors
     * const profesor = await prisma.profesor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfesorCreateManyArgs>(args?: SelectSubset<T, ProfesorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profesors and returns the data saved in the database.
     * @param {ProfesorCreateManyAndReturnArgs} args - Arguments to create many Profesors.
     * @example
     * // Create many Profesors
     * const profesor = await prisma.profesor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profesors and only return the `id`
     * const profesorWithIdOnly = await prisma.profesor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfesorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfesorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profesor.
     * @param {ProfesorDeleteArgs} args - Arguments to delete one Profesor.
     * @example
     * // Delete one Profesor
     * const Profesor = await prisma.profesor.delete({
     *   where: {
     *     // ... filter to delete one Profesor
     *   }
     * })
     * 
     */
    delete<T extends ProfesorDeleteArgs>(args: SelectSubset<T, ProfesorDeleteArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profesor.
     * @param {ProfesorUpdateArgs} args - Arguments to update one Profesor.
     * @example
     * // Update one Profesor
     * const profesor = await prisma.profesor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfesorUpdateArgs>(args: SelectSubset<T, ProfesorUpdateArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profesors.
     * @param {ProfesorDeleteManyArgs} args - Arguments to filter Profesors to delete.
     * @example
     * // Delete a few Profesors
     * const { count } = await prisma.profesor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfesorDeleteManyArgs>(args?: SelectSubset<T, ProfesorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profesors
     * const profesor = await prisma.profesor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfesorUpdateManyArgs>(args: SelectSubset<T, ProfesorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesors and returns the data updated in the database.
     * @param {ProfesorUpdateManyAndReturnArgs} args - Arguments to update many Profesors.
     * @example
     * // Update many Profesors
     * const profesor = await prisma.profesor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profesors and only return the `id`
     * const profesorWithIdOnly = await prisma.profesor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfesorUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfesorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profesor.
     * @param {ProfesorUpsertArgs} args - Arguments to update or create a Profesor.
     * @example
     * // Update or create a Profesor
     * const profesor = await prisma.profesor.upsert({
     *   create: {
     *     // ... data to create a Profesor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profesor we want to update
     *   }
     * })
     */
    upsert<T extends ProfesorUpsertArgs>(args: SelectSubset<T, ProfesorUpsertArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorCountArgs} args - Arguments to filter Profesors to count.
     * @example
     * // Count the number of Profesors
     * const count = await prisma.profesor.count({
     *   where: {
     *     // ... the filter for the Profesors we want to count
     *   }
     * })
    **/
    count<T extends ProfesorCountArgs>(
      args?: Subset<T, ProfesorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesorAggregateArgs>(args: Subset<T, ProfesorAggregateArgs>): Prisma.PrismaPromise<GetProfesorAggregateType<T>>

    /**
     * Group by Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesorGroupByArgs['orderBy'] }
        : { orderBy?: ProfesorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profesor model
   */
  readonly fields: ProfesorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profesor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfesorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grupos<T extends Profesor$gruposArgs<ExtArgs> = {}>(args?: Subset<T, Profesor$gruposArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profesor model
   */
  interface ProfesorFieldRefs {
    readonly id: FieldRef<"Profesor", 'String'>
    readonly numeroEmpleado: FieldRef<"Profesor", 'String'>
    readonly especialidad: FieldRef<"Profesor", 'String'>
    readonly grado: FieldRef<"Profesor", 'String'>
    readonly departamento: FieldRef<"Profesor", 'String'>
    readonly activo: FieldRef<"Profesor", 'Boolean'>
    readonly usuarioId: FieldRef<"Profesor", 'String'>
    readonly createdAt: FieldRef<"Profesor", 'DateTime'>
    readonly updatedAt: FieldRef<"Profesor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profesor findUnique
   */
  export type ProfesorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor findUniqueOrThrow
   */
  export type ProfesorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor findFirst
   */
  export type ProfesorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesors.
     */
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor findFirstOrThrow
   */
  export type ProfesorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesors.
     */
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor findMany
   */
  export type ProfesorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesors to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor create
   */
  export type ProfesorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The data needed to create a Profesor.
     */
    data: XOR<ProfesorCreateInput, ProfesorUncheckedCreateInput>
  }

  /**
   * Profesor createMany
   */
  export type ProfesorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profesors.
     */
    data: ProfesorCreateManyInput | ProfesorCreateManyInput[]
  }

  /**
   * Profesor createManyAndReturn
   */
  export type ProfesorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * The data used to create many Profesors.
     */
    data: ProfesorCreateManyInput | ProfesorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profesor update
   */
  export type ProfesorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The data needed to update a Profesor.
     */
    data: XOR<ProfesorUpdateInput, ProfesorUncheckedUpdateInput>
    /**
     * Choose, which Profesor to update.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor updateMany
   */
  export type ProfesorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profesors.
     */
    data: XOR<ProfesorUpdateManyMutationInput, ProfesorUncheckedUpdateManyInput>
    /**
     * Filter which Profesors to update
     */
    where?: ProfesorWhereInput
    /**
     * Limit how many Profesors to update.
     */
    limit?: number
  }

  /**
   * Profesor updateManyAndReturn
   */
  export type ProfesorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * The data used to update Profesors.
     */
    data: XOR<ProfesorUpdateManyMutationInput, ProfesorUncheckedUpdateManyInput>
    /**
     * Filter which Profesors to update
     */
    where?: ProfesorWhereInput
    /**
     * Limit how many Profesors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profesor upsert
   */
  export type ProfesorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The filter to search for the Profesor to update in case it exists.
     */
    where: ProfesorWhereUniqueInput
    /**
     * In case the Profesor found by the `where` argument doesn't exist, create a new Profesor with this data.
     */
    create: XOR<ProfesorCreateInput, ProfesorUncheckedCreateInput>
    /**
     * In case the Profesor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfesorUpdateInput, ProfesorUncheckedUpdateInput>
  }

  /**
   * Profesor delete
   */
  export type ProfesorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter which Profesor to delete.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor deleteMany
   */
  export type ProfesorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesors to delete
     */
    where?: ProfesorWhereInput
    /**
     * Limit how many Profesors to delete.
     */
    limit?: number
  }

  /**
   * Profesor.grupos
   */
  export type Profesor$gruposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grupo
     */
    omit?: GrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    where?: GrupoWhereInput
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    cursor?: GrupoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Profesor without action
   */
  export type ProfesorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
  }


  /**
   * Model Administrador
   */

  export type AggregateAdministrador = {
    _count: AdministradorCountAggregateOutputType | null
    _min: AdministradorMinAggregateOutputType | null
    _max: AdministradorMaxAggregateOutputType | null
  }

  export type AdministradorMinAggregateOutputType = {
    id: string | null
    numeroEmpleado: string | null
    area: string | null
    cargo: string | null
    activo: boolean | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdministradorMaxAggregateOutputType = {
    id: string | null
    numeroEmpleado: string | null
    area: string | null
    cargo: string | null
    activo: boolean | null
    usuarioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdministradorCountAggregateOutputType = {
    id: number
    numeroEmpleado: number
    area: number
    cargo: number
    activo: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdministradorMinAggregateInputType = {
    id?: true
    numeroEmpleado?: true
    area?: true
    cargo?: true
    activo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdministradorMaxAggregateInputType = {
    id?: true
    numeroEmpleado?: true
    area?: true
    cargo?: true
    activo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdministradorCountAggregateInputType = {
    id?: true
    numeroEmpleado?: true
    area?: true
    cargo?: true
    activo?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdministradorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Administrador to aggregate.
     */
    where?: AdministradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administradors to fetch.
     */
    orderBy?: AdministradorOrderByWithRelationInput | AdministradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdministradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Administradors
    **/
    _count?: true | AdministradorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministradorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministradorMaxAggregateInputType
  }

  export type GetAdministradorAggregateType<T extends AdministradorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrador[P]>
      : GetScalarType<T[P], AggregateAdministrador[P]>
  }




  export type AdministradorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdministradorWhereInput
    orderBy?: AdministradorOrderByWithAggregationInput | AdministradorOrderByWithAggregationInput[]
    by: AdministradorScalarFieldEnum[] | AdministradorScalarFieldEnum
    having?: AdministradorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministradorCountAggregateInputType | true
    _min?: AdministradorMinAggregateInputType
    _max?: AdministradorMaxAggregateInputType
  }

  export type AdministradorGroupByOutputType = {
    id: string
    numeroEmpleado: string
    area: string | null
    cargo: string | null
    activo: boolean
    usuarioId: string
    createdAt: Date
    updatedAt: Date
    _count: AdministradorCountAggregateOutputType | null
    _min: AdministradorMinAggregateOutputType | null
    _max: AdministradorMaxAggregateOutputType | null
  }

  type GetAdministradorGroupByPayload<T extends AdministradorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministradorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministradorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministradorGroupByOutputType[P]>
            : GetScalarType<T[P], AdministradorGroupByOutputType[P]>
        }
      >
    >


  export type AdministradorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEmpleado?: boolean
    area?: boolean
    cargo?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type AdministradorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEmpleado?: boolean
    area?: boolean
    cargo?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type AdministradorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEmpleado?: boolean
    area?: boolean
    cargo?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type AdministradorSelectScalar = {
    id?: boolean
    numeroEmpleado?: boolean
    area?: boolean
    cargo?: boolean
    activo?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdministradorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroEmpleado" | "area" | "cargo" | "activo" | "usuarioId" | "createdAt" | "updatedAt", ExtArgs["result"]["administrador"]>
  export type AdministradorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type AdministradorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type AdministradorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AdministradorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Administrador"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroEmpleado: string
      area: string | null
      cargo: string | null
      activo: boolean
      usuarioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["administrador"]>
    composites: {}
  }

  type AdministradorGetPayload<S extends boolean | null | undefined | AdministradorDefaultArgs> = $Result.GetResult<Prisma.$AdministradorPayload, S>

  type AdministradorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdministradorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministradorCountAggregateInputType | true
    }

  export interface AdministradorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Administrador'], meta: { name: 'Administrador' } }
    /**
     * Find zero or one Administrador that matches the filter.
     * @param {AdministradorFindUniqueArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdministradorFindUniqueArgs>(args: SelectSubset<T, AdministradorFindUniqueArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Administrador that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdministradorFindUniqueOrThrowArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdministradorFindUniqueOrThrowArgs>(args: SelectSubset<T, AdministradorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorFindFirstArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdministradorFindFirstArgs>(args?: SelectSubset<T, AdministradorFindFirstArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorFindFirstOrThrowArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdministradorFindFirstOrThrowArgs>(args?: SelectSubset<T, AdministradorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Administradors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administradors
     * const administradors = await prisma.administrador.findMany()
     * 
     * // Get first 10 Administradors
     * const administradors = await prisma.administrador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const administradorWithIdOnly = await prisma.administrador.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdministradorFindManyArgs>(args?: SelectSubset<T, AdministradorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Administrador.
     * @param {AdministradorCreateArgs} args - Arguments to create a Administrador.
     * @example
     * // Create one Administrador
     * const Administrador = await prisma.administrador.create({
     *   data: {
     *     // ... data to create a Administrador
     *   }
     * })
     * 
     */
    create<T extends AdministradorCreateArgs>(args: SelectSubset<T, AdministradorCreateArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Administradors.
     * @param {AdministradorCreateManyArgs} args - Arguments to create many Administradors.
     * @example
     * // Create many Administradors
     * const administrador = await prisma.administrador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdministradorCreateManyArgs>(args?: SelectSubset<T, AdministradorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Administradors and returns the data saved in the database.
     * @param {AdministradorCreateManyAndReturnArgs} args - Arguments to create many Administradors.
     * @example
     * // Create many Administradors
     * const administrador = await prisma.administrador.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Administradors and only return the `id`
     * const administradorWithIdOnly = await prisma.administrador.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdministradorCreateManyAndReturnArgs>(args?: SelectSubset<T, AdministradorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Administrador.
     * @param {AdministradorDeleteArgs} args - Arguments to delete one Administrador.
     * @example
     * // Delete one Administrador
     * const Administrador = await prisma.administrador.delete({
     *   where: {
     *     // ... filter to delete one Administrador
     *   }
     * })
     * 
     */
    delete<T extends AdministradorDeleteArgs>(args: SelectSubset<T, AdministradorDeleteArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Administrador.
     * @param {AdministradorUpdateArgs} args - Arguments to update one Administrador.
     * @example
     * // Update one Administrador
     * const administrador = await prisma.administrador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdministradorUpdateArgs>(args: SelectSubset<T, AdministradorUpdateArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Administradors.
     * @param {AdministradorDeleteManyArgs} args - Arguments to filter Administradors to delete.
     * @example
     * // Delete a few Administradors
     * const { count } = await prisma.administrador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdministradorDeleteManyArgs>(args?: SelectSubset<T, AdministradorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administradors
     * const administrador = await prisma.administrador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdministradorUpdateManyArgs>(args: SelectSubset<T, AdministradorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administradors and returns the data updated in the database.
     * @param {AdministradorUpdateManyAndReturnArgs} args - Arguments to update many Administradors.
     * @example
     * // Update many Administradors
     * const administrador = await prisma.administrador.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Administradors and only return the `id`
     * const administradorWithIdOnly = await prisma.administrador.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdministradorUpdateManyAndReturnArgs>(args: SelectSubset<T, AdministradorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Administrador.
     * @param {AdministradorUpsertArgs} args - Arguments to update or create a Administrador.
     * @example
     * // Update or create a Administrador
     * const administrador = await prisma.administrador.upsert({
     *   create: {
     *     // ... data to create a Administrador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrador we want to update
     *   }
     * })
     */
    upsert<T extends AdministradorUpsertArgs>(args: SelectSubset<T, AdministradorUpsertArgs<ExtArgs>>): Prisma__AdministradorClient<$Result.GetResult<Prisma.$AdministradorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Administradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorCountArgs} args - Arguments to filter Administradors to count.
     * @example
     * // Count the number of Administradors
     * const count = await prisma.administrador.count({
     *   where: {
     *     // ... the filter for the Administradors we want to count
     *   }
     * })
    **/
    count<T extends AdministradorCountArgs>(
      args?: Subset<T, AdministradorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministradorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministradorAggregateArgs>(args: Subset<T, AdministradorAggregateArgs>): Prisma.PrismaPromise<GetAdministradorAggregateType<T>>

    /**
     * Group by Administrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministradorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministradorGroupByArgs['orderBy'] }
        : { orderBy?: AdministradorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministradorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministradorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Administrador model
   */
  readonly fields: AdministradorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Administrador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdministradorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Administrador model
   */
  interface AdministradorFieldRefs {
    readonly id: FieldRef<"Administrador", 'String'>
    readonly numeroEmpleado: FieldRef<"Administrador", 'String'>
    readonly area: FieldRef<"Administrador", 'String'>
    readonly cargo: FieldRef<"Administrador", 'String'>
    readonly activo: FieldRef<"Administrador", 'Boolean'>
    readonly usuarioId: FieldRef<"Administrador", 'String'>
    readonly createdAt: FieldRef<"Administrador", 'DateTime'>
    readonly updatedAt: FieldRef<"Administrador", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Administrador findUnique
   */
  export type AdministradorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * Filter, which Administrador to fetch.
     */
    where: AdministradorWhereUniqueInput
  }

  /**
   * Administrador findUniqueOrThrow
   */
  export type AdministradorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * Filter, which Administrador to fetch.
     */
    where: AdministradorWhereUniqueInput
  }

  /**
   * Administrador findFirst
   */
  export type AdministradorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * Filter, which Administrador to fetch.
     */
    where?: AdministradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administradors to fetch.
     */
    orderBy?: AdministradorOrderByWithRelationInput | AdministradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Administradors.
     */
    cursor?: AdministradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Administradors.
     */
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * Administrador findFirstOrThrow
   */
  export type AdministradorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * Filter, which Administrador to fetch.
     */
    where?: AdministradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administradors to fetch.
     */
    orderBy?: AdministradorOrderByWithRelationInput | AdministradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Administradors.
     */
    cursor?: AdministradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Administradors.
     */
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * Administrador findMany
   */
  export type AdministradorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * Filter, which Administradors to fetch.
     */
    where?: AdministradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administradors to fetch.
     */
    orderBy?: AdministradorOrderByWithRelationInput | AdministradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Administradors.
     */
    cursor?: AdministradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administradors.
     */
    skip?: number
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * Administrador create
   */
  export type AdministradorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * The data needed to create a Administrador.
     */
    data: XOR<AdministradorCreateInput, AdministradorUncheckedCreateInput>
  }

  /**
   * Administrador createMany
   */
  export type AdministradorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Administradors.
     */
    data: AdministradorCreateManyInput | AdministradorCreateManyInput[]
  }

  /**
   * Administrador createManyAndReturn
   */
  export type AdministradorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * The data used to create many Administradors.
     */
    data: AdministradorCreateManyInput | AdministradorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Administrador update
   */
  export type AdministradorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * The data needed to update a Administrador.
     */
    data: XOR<AdministradorUpdateInput, AdministradorUncheckedUpdateInput>
    /**
     * Choose, which Administrador to update.
     */
    where: AdministradorWhereUniqueInput
  }

  /**
   * Administrador updateMany
   */
  export type AdministradorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Administradors.
     */
    data: XOR<AdministradorUpdateManyMutationInput, AdministradorUncheckedUpdateManyInput>
    /**
     * Filter which Administradors to update
     */
    where?: AdministradorWhereInput
    /**
     * Limit how many Administradors to update.
     */
    limit?: number
  }

  /**
   * Administrador updateManyAndReturn
   */
  export type AdministradorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * The data used to update Administradors.
     */
    data: XOR<AdministradorUpdateManyMutationInput, AdministradorUncheckedUpdateManyInput>
    /**
     * Filter which Administradors to update
     */
    where?: AdministradorWhereInput
    /**
     * Limit how many Administradors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Administrador upsert
   */
  export type AdministradorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * The filter to search for the Administrador to update in case it exists.
     */
    where: AdministradorWhereUniqueInput
    /**
     * In case the Administrador found by the `where` argument doesn't exist, create a new Administrador with this data.
     */
    create: XOR<AdministradorCreateInput, AdministradorUncheckedCreateInput>
    /**
     * In case the Administrador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdministradorUpdateInput, AdministradorUncheckedUpdateInput>
  }

  /**
   * Administrador delete
   */
  export type AdministradorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
    /**
     * Filter which Administrador to delete.
     */
    where: AdministradorWhereUniqueInput
  }

  /**
   * Administrador deleteMany
   */
  export type AdministradorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Administradors to delete
     */
    where?: AdministradorWhereInput
    /**
     * Limit how many Administradors to delete.
     */
    limit?: number
  }

  /**
   * Administrador without action
   */
  export type AdministradorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrador
     */
    select?: AdministradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrador
     */
    omit?: AdministradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministradorInclude<ExtArgs> | null
  }


  /**
   * Model Documento
   */

  export type AggregateDocumento = {
    _count: DocumentoCountAggregateOutputType | null
    _avg: DocumentoAvgAggregateOutputType | null
    _sum: DocumentoSumAggregateOutputType | null
    _min: DocumentoMinAggregateOutputType | null
    _max: DocumentoMaxAggregateOutputType | null
  }

  export type DocumentoAvgAggregateOutputType = {
    tamanoBytes: number | null
  }

  export type DocumentoSumAggregateOutputType = {
    tamanoBytes: number | null
  }

  export type DocumentoMinAggregateOutputType = {
    id: string | null
    folio: string | null
    tipo: $Enums.TipoDocumento | null
    titulo: string | null
    descripcion: string | null
    rutaArchivo: string | null
    rutaArchivoFirmado: string | null
    hashArchivo: string | null
    tamanoBytes: number | null
    mimeType: string | null
    estatus: $Enums.EstatusDocumento | null
    fechaEmision: Date | null
    fechaVencimiento: Date | null
    validado: boolean | null
    firmado: boolean | null
    cadenaBlockchain: string | null
    qrCode: string | null
    creadoPorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentoMaxAggregateOutputType = {
    id: string | null
    folio: string | null
    tipo: $Enums.TipoDocumento | null
    titulo: string | null
    descripcion: string | null
    rutaArchivo: string | null
    rutaArchivoFirmado: string | null
    hashArchivo: string | null
    tamanoBytes: number | null
    mimeType: string | null
    estatus: $Enums.EstatusDocumento | null
    fechaEmision: Date | null
    fechaVencimiento: Date | null
    validado: boolean | null
    firmado: boolean | null
    cadenaBlockchain: string | null
    qrCode: string | null
    creadoPorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentoCountAggregateOutputType = {
    id: number
    folio: number
    tipo: number
    titulo: number
    descripcion: number
    rutaArchivo: number
    rutaArchivoFirmado: number
    hashArchivo: number
    tamanoBytes: number
    mimeType: number
    estatus: number
    fechaEmision: number
    fechaVencimiento: number
    validado: number
    firmado: number
    cadenaBlockchain: number
    qrCode: number
    creadoPorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentoAvgAggregateInputType = {
    tamanoBytes?: true
  }

  export type DocumentoSumAggregateInputType = {
    tamanoBytes?: true
  }

  export type DocumentoMinAggregateInputType = {
    id?: true
    folio?: true
    tipo?: true
    titulo?: true
    descripcion?: true
    rutaArchivo?: true
    rutaArchivoFirmado?: true
    hashArchivo?: true
    tamanoBytes?: true
    mimeType?: true
    estatus?: true
    fechaEmision?: true
    fechaVencimiento?: true
    validado?: true
    firmado?: true
    cadenaBlockchain?: true
    qrCode?: true
    creadoPorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentoMaxAggregateInputType = {
    id?: true
    folio?: true
    tipo?: true
    titulo?: true
    descripcion?: true
    rutaArchivo?: true
    rutaArchivoFirmado?: true
    hashArchivo?: true
    tamanoBytes?: true
    mimeType?: true
    estatus?: true
    fechaEmision?: true
    fechaVencimiento?: true
    validado?: true
    firmado?: true
    cadenaBlockchain?: true
    qrCode?: true
    creadoPorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentoCountAggregateInputType = {
    id?: true
    folio?: true
    tipo?: true
    titulo?: true
    descripcion?: true
    rutaArchivo?: true
    rutaArchivoFirmado?: true
    hashArchivo?: true
    tamanoBytes?: true
    mimeType?: true
    estatus?: true
    fechaEmision?: true
    fechaVencimiento?: true
    validado?: true
    firmado?: true
    cadenaBlockchain?: true
    qrCode?: true
    creadoPorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documento to aggregate.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documentos
    **/
    _count?: true | DocumentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentoMaxAggregateInputType
  }

  export type GetDocumentoAggregateType<T extends DocumentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumento[P]>
      : GetScalarType<T[P], AggregateDocumento[P]>
  }




  export type DocumentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithAggregationInput | DocumentoOrderByWithAggregationInput[]
    by: DocumentoScalarFieldEnum[] | DocumentoScalarFieldEnum
    having?: DocumentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentoCountAggregateInputType | true
    _avg?: DocumentoAvgAggregateInputType
    _sum?: DocumentoSumAggregateInputType
    _min?: DocumentoMinAggregateInputType
    _max?: DocumentoMaxAggregateInputType
  }

  export type DocumentoGroupByOutputType = {
    id: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion: string | null
    rutaArchivo: string
    rutaArchivoFirmado: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus: $Enums.EstatusDocumento
    fechaEmision: Date | null
    fechaVencimiento: Date | null
    validado: boolean
    firmado: boolean
    cadenaBlockchain: string | null
    qrCode: string | null
    creadoPorId: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentoCountAggregateOutputType | null
    _avg: DocumentoAvgAggregateOutputType | null
    _sum: DocumentoSumAggregateOutputType | null
    _min: DocumentoMinAggregateOutputType | null
    _max: DocumentoMaxAggregateOutputType | null
  }

  type GetDocumentoGroupByPayload<T extends DocumentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentoGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentoGroupByOutputType[P]>
        }
      >
    >


  export type DocumentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folio?: boolean
    tipo?: boolean
    titulo?: boolean
    descripcion?: boolean
    rutaArchivo?: boolean
    rutaArchivoFirmado?: boolean
    hashArchivo?: boolean
    tamanoBytes?: boolean
    mimeType?: boolean
    estatus?: boolean
    fechaEmision?: boolean
    fechaVencimiento?: boolean
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: boolean
    qrCode?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    documentosEstudiante?: boolean | Documento$documentosEstudianteArgs<ExtArgs>
    _count?: boolean | DocumentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documento"]>

  export type DocumentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folio?: boolean
    tipo?: boolean
    titulo?: boolean
    descripcion?: boolean
    rutaArchivo?: boolean
    rutaArchivoFirmado?: boolean
    hashArchivo?: boolean
    tamanoBytes?: boolean
    mimeType?: boolean
    estatus?: boolean
    fechaEmision?: boolean
    fechaVencimiento?: boolean
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: boolean
    qrCode?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documento"]>

  export type DocumentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folio?: boolean
    tipo?: boolean
    titulo?: boolean
    descripcion?: boolean
    rutaArchivo?: boolean
    rutaArchivoFirmado?: boolean
    hashArchivo?: boolean
    tamanoBytes?: boolean
    mimeType?: boolean
    estatus?: boolean
    fechaEmision?: boolean
    fechaVencimiento?: boolean
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: boolean
    qrCode?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documento"]>

  export type DocumentoSelectScalar = {
    id?: boolean
    folio?: boolean
    tipo?: boolean
    titulo?: boolean
    descripcion?: boolean
    rutaArchivo?: boolean
    rutaArchivoFirmado?: boolean
    hashArchivo?: boolean
    tamanoBytes?: boolean
    mimeType?: boolean
    estatus?: boolean
    fechaEmision?: boolean
    fechaVencimiento?: boolean
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: boolean
    qrCode?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "folio" | "tipo" | "titulo" | "descripcion" | "rutaArchivo" | "rutaArchivoFirmado" | "hashArchivo" | "tamanoBytes" | "mimeType" | "estatus" | "fechaEmision" | "fechaVencimiento" | "validado" | "firmado" | "cadenaBlockchain" | "qrCode" | "creadoPorId" | "createdAt" | "updatedAt", ExtArgs["result"]["documento"]>
  export type DocumentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    documentosEstudiante?: boolean | Documento$documentosEstudianteArgs<ExtArgs>
    _count?: boolean | DocumentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type DocumentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $DocumentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documento"
    objects: {
      creadoPor: Prisma.$UsuarioPayload<ExtArgs>
      documentosEstudiante: Prisma.$DocumentoEstudiantePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      folio: string
      tipo: $Enums.TipoDocumento
      titulo: string
      descripcion: string | null
      rutaArchivo: string
      rutaArchivoFirmado: string | null
      hashArchivo: string
      tamanoBytes: number
      mimeType: string
      estatus: $Enums.EstatusDocumento
      fechaEmision: Date | null
      fechaVencimiento: Date | null
      validado: boolean
      firmado: boolean
      cadenaBlockchain: string | null
      qrCode: string | null
      creadoPorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documento"]>
    composites: {}
  }

  type DocumentoGetPayload<S extends boolean | null | undefined | DocumentoDefaultArgs> = $Result.GetResult<Prisma.$DocumentoPayload, S>

  type DocumentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentoCountAggregateInputType | true
    }

  export interface DocumentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documento'], meta: { name: 'Documento' } }
    /**
     * Find zero or one Documento that matches the filter.
     * @param {DocumentoFindUniqueArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentoFindUniqueArgs>(args: SelectSubset<T, DocumentoFindUniqueArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentoFindUniqueOrThrowArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindFirstArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentoFindFirstArgs>(args?: SelectSubset<T, DocumentoFindFirstArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindFirstOrThrowArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentos
     * const documentos = await prisma.documento.findMany()
     * 
     * // Get first 10 Documentos
     * const documentos = await prisma.documento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentoWithIdOnly = await prisma.documento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentoFindManyArgs>(args?: SelectSubset<T, DocumentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documento.
     * @param {DocumentoCreateArgs} args - Arguments to create a Documento.
     * @example
     * // Create one Documento
     * const Documento = await prisma.documento.create({
     *   data: {
     *     // ... data to create a Documento
     *   }
     * })
     * 
     */
    create<T extends DocumentoCreateArgs>(args: SelectSubset<T, DocumentoCreateArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documentos.
     * @param {DocumentoCreateManyArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documento = await prisma.documento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentoCreateManyArgs>(args?: SelectSubset<T, DocumentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documentos and returns the data saved in the database.
     * @param {DocumentoCreateManyAndReturnArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documento = await prisma.documento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documentos and only return the `id`
     * const documentoWithIdOnly = await prisma.documento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentoCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documento.
     * @param {DocumentoDeleteArgs} args - Arguments to delete one Documento.
     * @example
     * // Delete one Documento
     * const Documento = await prisma.documento.delete({
     *   where: {
     *     // ... filter to delete one Documento
     *   }
     * })
     * 
     */
    delete<T extends DocumentoDeleteArgs>(args: SelectSubset<T, DocumentoDeleteArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documento.
     * @param {DocumentoUpdateArgs} args - Arguments to update one Documento.
     * @example
     * // Update one Documento
     * const documento = await prisma.documento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentoUpdateArgs>(args: SelectSubset<T, DocumentoUpdateArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documentos.
     * @param {DocumentoDeleteManyArgs} args - Arguments to filter Documentos to delete.
     * @example
     * // Delete a few Documentos
     * const { count } = await prisma.documento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentoDeleteManyArgs>(args?: SelectSubset<T, DocumentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentos
     * const documento = await prisma.documento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentoUpdateManyArgs>(args: SelectSubset<T, DocumentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos and returns the data updated in the database.
     * @param {DocumentoUpdateManyAndReturnArgs} args - Arguments to update many Documentos.
     * @example
     * // Update many Documentos
     * const documento = await prisma.documento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documentos and only return the `id`
     * const documentoWithIdOnly = await prisma.documento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentoUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documento.
     * @param {DocumentoUpsertArgs} args - Arguments to update or create a Documento.
     * @example
     * // Update or create a Documento
     * const documento = await prisma.documento.upsert({
     *   create: {
     *     // ... data to create a Documento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documento we want to update
     *   }
     * })
     */
    upsert<T extends DocumentoUpsertArgs>(args: SelectSubset<T, DocumentoUpsertArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoCountArgs} args - Arguments to filter Documentos to count.
     * @example
     * // Count the number of Documentos
     * const count = await prisma.documento.count({
     *   where: {
     *     // ... the filter for the Documentos we want to count
     *   }
     * })
    **/
    count<T extends DocumentoCountArgs>(
      args?: Subset<T, DocumentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentoAggregateArgs>(args: Subset<T, DocumentoAggregateArgs>): Prisma.PrismaPromise<GetDocumentoAggregateType<T>>

    /**
     * Group by Documento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentoGroupByArgs['orderBy'] }
        : { orderBy?: DocumentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documento model
   */
  readonly fields: DocumentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creadoPor<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documentosEstudiante<T extends Documento$documentosEstudianteArgs<ExtArgs> = {}>(args?: Subset<T, Documento$documentosEstudianteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documento model
   */
  interface DocumentoFieldRefs {
    readonly id: FieldRef<"Documento", 'String'>
    readonly folio: FieldRef<"Documento", 'String'>
    readonly tipo: FieldRef<"Documento", 'TipoDocumento'>
    readonly titulo: FieldRef<"Documento", 'String'>
    readonly descripcion: FieldRef<"Documento", 'String'>
    readonly rutaArchivo: FieldRef<"Documento", 'String'>
    readonly rutaArchivoFirmado: FieldRef<"Documento", 'String'>
    readonly hashArchivo: FieldRef<"Documento", 'String'>
    readonly tamanoBytes: FieldRef<"Documento", 'Int'>
    readonly mimeType: FieldRef<"Documento", 'String'>
    readonly estatus: FieldRef<"Documento", 'EstatusDocumento'>
    readonly fechaEmision: FieldRef<"Documento", 'DateTime'>
    readonly fechaVencimiento: FieldRef<"Documento", 'DateTime'>
    readonly validado: FieldRef<"Documento", 'Boolean'>
    readonly firmado: FieldRef<"Documento", 'Boolean'>
    readonly cadenaBlockchain: FieldRef<"Documento", 'String'>
    readonly qrCode: FieldRef<"Documento", 'String'>
    readonly creadoPorId: FieldRef<"Documento", 'String'>
    readonly createdAt: FieldRef<"Documento", 'DateTime'>
    readonly updatedAt: FieldRef<"Documento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Documento findUnique
   */
  export type DocumentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento findUniqueOrThrow
   */
  export type DocumentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento findFirst
   */
  export type DocumentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento findFirstOrThrow
   */
  export type DocumentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento findMany
   */
  export type DocumentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento create
   */
  export type DocumentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Documento.
     */
    data: XOR<DocumentoCreateInput, DocumentoUncheckedCreateInput>
  }

  /**
   * Documento createMany
   */
  export type DocumentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documentos.
     */
    data: DocumentoCreateManyInput | DocumentoCreateManyInput[]
  }

  /**
   * Documento createManyAndReturn
   */
  export type DocumentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * The data used to create many Documentos.
     */
    data: DocumentoCreateManyInput | DocumentoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Documento update
   */
  export type DocumentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Documento.
     */
    data: XOR<DocumentoUpdateInput, DocumentoUncheckedUpdateInput>
    /**
     * Choose, which Documento to update.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento updateMany
   */
  export type DocumentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documentos.
     */
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyInput>
    /**
     * Filter which Documentos to update
     */
    where?: DocumentoWhereInput
    /**
     * Limit how many Documentos to update.
     */
    limit?: number
  }

  /**
   * Documento updateManyAndReturn
   */
  export type DocumentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * The data used to update Documentos.
     */
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyInput>
    /**
     * Filter which Documentos to update
     */
    where?: DocumentoWhereInput
    /**
     * Limit how many Documentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Documento upsert
   */
  export type DocumentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Documento to update in case it exists.
     */
    where: DocumentoWhereUniqueInput
    /**
     * In case the Documento found by the `where` argument doesn't exist, create a new Documento with this data.
     */
    create: XOR<DocumentoCreateInput, DocumentoUncheckedCreateInput>
    /**
     * In case the Documento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentoUpdateInput, DocumentoUncheckedUpdateInput>
  }

  /**
   * Documento delete
   */
  export type DocumentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter which Documento to delete.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento deleteMany
   */
  export type DocumentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentos to delete
     */
    where?: DocumentoWhereInput
    /**
     * Limit how many Documentos to delete.
     */
    limit?: number
  }

  /**
   * Documento.documentosEstudiante
   */
  export type Documento$documentosEstudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    where?: DocumentoEstudianteWhereInput
    orderBy?: DocumentoEstudianteOrderByWithRelationInput | DocumentoEstudianteOrderByWithRelationInput[]
    cursor?: DocumentoEstudianteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoEstudianteScalarFieldEnum | DocumentoEstudianteScalarFieldEnum[]
  }

  /**
   * Documento without action
   */
  export type DocumentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documento
     */
    omit?: DocumentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
  }


  /**
   * Model DocumentoEstudiante
   */

  export type AggregateDocumentoEstudiante = {
    _count: DocumentoEstudianteCountAggregateOutputType | null
    _min: DocumentoEstudianteMinAggregateOutputType | null
    _max: DocumentoEstudianteMaxAggregateOutputType | null
  }

  export type DocumentoEstudianteMinAggregateOutputType = {
    id: string | null
    observaciones: string | null
    motivoRechazo: string | null
    revisadoPor: string | null
    fechaRevision: Date | null
    escaneoVirus: boolean | null
    virusDetectado: boolean | null
    nombreVirusDetectado: string | null
    documentoId: string | null
    estudianteId: string | null
    createdAt: Date | null
  }

  export type DocumentoEstudianteMaxAggregateOutputType = {
    id: string | null
    observaciones: string | null
    motivoRechazo: string | null
    revisadoPor: string | null
    fechaRevision: Date | null
    escaneoVirus: boolean | null
    virusDetectado: boolean | null
    nombreVirusDetectado: string | null
    documentoId: string | null
    estudianteId: string | null
    createdAt: Date | null
  }

  export type DocumentoEstudianteCountAggregateOutputType = {
    id: number
    observaciones: number
    motivoRechazo: number
    revisadoPor: number
    fechaRevision: number
    escaneoVirus: number
    virusDetectado: number
    nombreVirusDetectado: number
    documentoId: number
    estudianteId: number
    createdAt: number
    _all: number
  }


  export type DocumentoEstudianteMinAggregateInputType = {
    id?: true
    observaciones?: true
    motivoRechazo?: true
    revisadoPor?: true
    fechaRevision?: true
    escaneoVirus?: true
    virusDetectado?: true
    nombreVirusDetectado?: true
    documentoId?: true
    estudianteId?: true
    createdAt?: true
  }

  export type DocumentoEstudianteMaxAggregateInputType = {
    id?: true
    observaciones?: true
    motivoRechazo?: true
    revisadoPor?: true
    fechaRevision?: true
    escaneoVirus?: true
    virusDetectado?: true
    nombreVirusDetectado?: true
    documentoId?: true
    estudianteId?: true
    createdAt?: true
  }

  export type DocumentoEstudianteCountAggregateInputType = {
    id?: true
    observaciones?: true
    motivoRechazo?: true
    revisadoPor?: true
    fechaRevision?: true
    escaneoVirus?: true
    virusDetectado?: true
    nombreVirusDetectado?: true
    documentoId?: true
    estudianteId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentoEstudianteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentoEstudiante to aggregate.
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentoEstudiantes to fetch.
     */
    orderBy?: DocumentoEstudianteOrderByWithRelationInput | DocumentoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentoEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentoEstudiantes
    **/
    _count?: true | DocumentoEstudianteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentoEstudianteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentoEstudianteMaxAggregateInputType
  }

  export type GetDocumentoEstudianteAggregateType<T extends DocumentoEstudianteAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentoEstudiante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentoEstudiante[P]>
      : GetScalarType<T[P], AggregateDocumentoEstudiante[P]>
  }




  export type DocumentoEstudianteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoEstudianteWhereInput
    orderBy?: DocumentoEstudianteOrderByWithAggregationInput | DocumentoEstudianteOrderByWithAggregationInput[]
    by: DocumentoEstudianteScalarFieldEnum[] | DocumentoEstudianteScalarFieldEnum
    having?: DocumentoEstudianteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentoEstudianteCountAggregateInputType | true
    _min?: DocumentoEstudianteMinAggregateInputType
    _max?: DocumentoEstudianteMaxAggregateInputType
  }

  export type DocumentoEstudianteGroupByOutputType = {
    id: string
    observaciones: string | null
    motivoRechazo: string | null
    revisadoPor: string | null
    fechaRevision: Date | null
    escaneoVirus: boolean
    virusDetectado: boolean
    nombreVirusDetectado: string | null
    documentoId: string
    estudianteId: string
    createdAt: Date
    _count: DocumentoEstudianteCountAggregateOutputType | null
    _min: DocumentoEstudianteMinAggregateOutputType | null
    _max: DocumentoEstudianteMaxAggregateOutputType | null
  }

  type GetDocumentoEstudianteGroupByPayload<T extends DocumentoEstudianteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentoEstudianteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentoEstudianteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentoEstudianteGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentoEstudianteGroupByOutputType[P]>
        }
      >
    >


  export type DocumentoEstudianteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    observaciones?: boolean
    motivoRechazo?: boolean
    revisadoPor?: boolean
    fechaRevision?: boolean
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentoEstudiante"]>

  export type DocumentoEstudianteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    observaciones?: boolean
    motivoRechazo?: boolean
    revisadoPor?: boolean
    fechaRevision?: boolean
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentoEstudiante"]>

  export type DocumentoEstudianteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    observaciones?: boolean
    motivoRechazo?: boolean
    revisadoPor?: boolean
    fechaRevision?: boolean
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentoEstudiante"]>

  export type DocumentoEstudianteSelectScalar = {
    id?: boolean
    observaciones?: boolean
    motivoRechazo?: boolean
    revisadoPor?: boolean
    fechaRevision?: boolean
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
  }

  export type DocumentoEstudianteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "observaciones" | "motivoRechazo" | "revisadoPor" | "fechaRevision" | "escaneoVirus" | "virusDetectado" | "nombreVirusDetectado" | "documentoId" | "estudianteId" | "createdAt", ExtArgs["result"]["documentoEstudiante"]>
  export type DocumentoEstudianteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }
  export type DocumentoEstudianteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }
  export type DocumentoEstudianteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }

  export type $DocumentoEstudiantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentoEstudiante"
    objects: {
      documento: Prisma.$DocumentoPayload<ExtArgs>
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      observaciones: string | null
      motivoRechazo: string | null
      revisadoPor: string | null
      fechaRevision: Date | null
      escaneoVirus: boolean
      virusDetectado: boolean
      nombreVirusDetectado: string | null
      documentoId: string
      estudianteId: string
      createdAt: Date
    }, ExtArgs["result"]["documentoEstudiante"]>
    composites: {}
  }

  type DocumentoEstudianteGetPayload<S extends boolean | null | undefined | DocumentoEstudianteDefaultArgs> = $Result.GetResult<Prisma.$DocumentoEstudiantePayload, S>

  type DocumentoEstudianteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentoEstudianteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentoEstudianteCountAggregateInputType | true
    }

  export interface DocumentoEstudianteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentoEstudiante'], meta: { name: 'DocumentoEstudiante' } }
    /**
     * Find zero or one DocumentoEstudiante that matches the filter.
     * @param {DocumentoEstudianteFindUniqueArgs} args - Arguments to find a DocumentoEstudiante
     * @example
     * // Get one DocumentoEstudiante
     * const documentoEstudiante = await prisma.documentoEstudiante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentoEstudianteFindUniqueArgs>(args: SelectSubset<T, DocumentoEstudianteFindUniqueArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentoEstudiante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentoEstudianteFindUniqueOrThrowArgs} args - Arguments to find a DocumentoEstudiante
     * @example
     * // Get one DocumentoEstudiante
     * const documentoEstudiante = await prisma.documentoEstudiante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentoEstudianteFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentoEstudianteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentoEstudiante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteFindFirstArgs} args - Arguments to find a DocumentoEstudiante
     * @example
     * // Get one DocumentoEstudiante
     * const documentoEstudiante = await prisma.documentoEstudiante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentoEstudianteFindFirstArgs>(args?: SelectSubset<T, DocumentoEstudianteFindFirstArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentoEstudiante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteFindFirstOrThrowArgs} args - Arguments to find a DocumentoEstudiante
     * @example
     * // Get one DocumentoEstudiante
     * const documentoEstudiante = await prisma.documentoEstudiante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentoEstudianteFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentoEstudianteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentoEstudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentoEstudiantes
     * const documentoEstudiantes = await prisma.documentoEstudiante.findMany()
     * 
     * // Get first 10 DocumentoEstudiantes
     * const documentoEstudiantes = await prisma.documentoEstudiante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentoEstudianteWithIdOnly = await prisma.documentoEstudiante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentoEstudianteFindManyArgs>(args?: SelectSubset<T, DocumentoEstudianteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentoEstudiante.
     * @param {DocumentoEstudianteCreateArgs} args - Arguments to create a DocumentoEstudiante.
     * @example
     * // Create one DocumentoEstudiante
     * const DocumentoEstudiante = await prisma.documentoEstudiante.create({
     *   data: {
     *     // ... data to create a DocumentoEstudiante
     *   }
     * })
     * 
     */
    create<T extends DocumentoEstudianteCreateArgs>(args: SelectSubset<T, DocumentoEstudianteCreateArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentoEstudiantes.
     * @param {DocumentoEstudianteCreateManyArgs} args - Arguments to create many DocumentoEstudiantes.
     * @example
     * // Create many DocumentoEstudiantes
     * const documentoEstudiante = await prisma.documentoEstudiante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentoEstudianteCreateManyArgs>(args?: SelectSubset<T, DocumentoEstudianteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentoEstudiantes and returns the data saved in the database.
     * @param {DocumentoEstudianteCreateManyAndReturnArgs} args - Arguments to create many DocumentoEstudiantes.
     * @example
     * // Create many DocumentoEstudiantes
     * const documentoEstudiante = await prisma.documentoEstudiante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentoEstudiantes and only return the `id`
     * const documentoEstudianteWithIdOnly = await prisma.documentoEstudiante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentoEstudianteCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentoEstudianteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentoEstudiante.
     * @param {DocumentoEstudianteDeleteArgs} args - Arguments to delete one DocumentoEstudiante.
     * @example
     * // Delete one DocumentoEstudiante
     * const DocumentoEstudiante = await prisma.documentoEstudiante.delete({
     *   where: {
     *     // ... filter to delete one DocumentoEstudiante
     *   }
     * })
     * 
     */
    delete<T extends DocumentoEstudianteDeleteArgs>(args: SelectSubset<T, DocumentoEstudianteDeleteArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentoEstudiante.
     * @param {DocumentoEstudianteUpdateArgs} args - Arguments to update one DocumentoEstudiante.
     * @example
     * // Update one DocumentoEstudiante
     * const documentoEstudiante = await prisma.documentoEstudiante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentoEstudianteUpdateArgs>(args: SelectSubset<T, DocumentoEstudianteUpdateArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentoEstudiantes.
     * @param {DocumentoEstudianteDeleteManyArgs} args - Arguments to filter DocumentoEstudiantes to delete.
     * @example
     * // Delete a few DocumentoEstudiantes
     * const { count } = await prisma.documentoEstudiante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentoEstudianteDeleteManyArgs>(args?: SelectSubset<T, DocumentoEstudianteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentoEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentoEstudiantes
     * const documentoEstudiante = await prisma.documentoEstudiante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentoEstudianteUpdateManyArgs>(args: SelectSubset<T, DocumentoEstudianteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentoEstudiantes and returns the data updated in the database.
     * @param {DocumentoEstudianteUpdateManyAndReturnArgs} args - Arguments to update many DocumentoEstudiantes.
     * @example
     * // Update many DocumentoEstudiantes
     * const documentoEstudiante = await prisma.documentoEstudiante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentoEstudiantes and only return the `id`
     * const documentoEstudianteWithIdOnly = await prisma.documentoEstudiante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentoEstudianteUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentoEstudianteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentoEstudiante.
     * @param {DocumentoEstudianteUpsertArgs} args - Arguments to update or create a DocumentoEstudiante.
     * @example
     * // Update or create a DocumentoEstudiante
     * const documentoEstudiante = await prisma.documentoEstudiante.upsert({
     *   create: {
     *     // ... data to create a DocumentoEstudiante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentoEstudiante we want to update
     *   }
     * })
     */
    upsert<T extends DocumentoEstudianteUpsertArgs>(args: SelectSubset<T, DocumentoEstudianteUpsertArgs<ExtArgs>>): Prisma__DocumentoEstudianteClient<$Result.GetResult<Prisma.$DocumentoEstudiantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentoEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteCountArgs} args - Arguments to filter DocumentoEstudiantes to count.
     * @example
     * // Count the number of DocumentoEstudiantes
     * const count = await prisma.documentoEstudiante.count({
     *   where: {
     *     // ... the filter for the DocumentoEstudiantes we want to count
     *   }
     * })
    **/
    count<T extends DocumentoEstudianteCountArgs>(
      args?: Subset<T, DocumentoEstudianteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentoEstudianteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentoEstudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentoEstudianteAggregateArgs>(args: Subset<T, DocumentoEstudianteAggregateArgs>): Prisma.PrismaPromise<GetDocumentoEstudianteAggregateType<T>>

    /**
     * Group by DocumentoEstudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoEstudianteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentoEstudianteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentoEstudianteGroupByArgs['orderBy'] }
        : { orderBy?: DocumentoEstudianteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentoEstudianteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentoEstudianteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentoEstudiante model
   */
  readonly fields: DocumentoEstudianteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentoEstudiante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentoEstudianteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documento<T extends DocumentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentoDefaultArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentoEstudiante model
   */
  interface DocumentoEstudianteFieldRefs {
    readonly id: FieldRef<"DocumentoEstudiante", 'String'>
    readonly observaciones: FieldRef<"DocumentoEstudiante", 'String'>
    readonly motivoRechazo: FieldRef<"DocumentoEstudiante", 'String'>
    readonly revisadoPor: FieldRef<"DocumentoEstudiante", 'String'>
    readonly fechaRevision: FieldRef<"DocumentoEstudiante", 'DateTime'>
    readonly escaneoVirus: FieldRef<"DocumentoEstudiante", 'Boolean'>
    readonly virusDetectado: FieldRef<"DocumentoEstudiante", 'Boolean'>
    readonly nombreVirusDetectado: FieldRef<"DocumentoEstudiante", 'String'>
    readonly documentoId: FieldRef<"DocumentoEstudiante", 'String'>
    readonly estudianteId: FieldRef<"DocumentoEstudiante", 'String'>
    readonly createdAt: FieldRef<"DocumentoEstudiante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentoEstudiante findUnique
   */
  export type DocumentoEstudianteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which DocumentoEstudiante to fetch.
     */
    where: DocumentoEstudianteWhereUniqueInput
  }

  /**
   * DocumentoEstudiante findUniqueOrThrow
   */
  export type DocumentoEstudianteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which DocumentoEstudiante to fetch.
     */
    where: DocumentoEstudianteWhereUniqueInput
  }

  /**
   * DocumentoEstudiante findFirst
   */
  export type DocumentoEstudianteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which DocumentoEstudiante to fetch.
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentoEstudiantes to fetch.
     */
    orderBy?: DocumentoEstudianteOrderByWithRelationInput | DocumentoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentoEstudiantes.
     */
    cursor?: DocumentoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentoEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentoEstudiantes.
     */
    distinct?: DocumentoEstudianteScalarFieldEnum | DocumentoEstudianteScalarFieldEnum[]
  }

  /**
   * DocumentoEstudiante findFirstOrThrow
   */
  export type DocumentoEstudianteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which DocumentoEstudiante to fetch.
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentoEstudiantes to fetch.
     */
    orderBy?: DocumentoEstudianteOrderByWithRelationInput | DocumentoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentoEstudiantes.
     */
    cursor?: DocumentoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentoEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentoEstudiantes.
     */
    distinct?: DocumentoEstudianteScalarFieldEnum | DocumentoEstudianteScalarFieldEnum[]
  }

  /**
   * DocumentoEstudiante findMany
   */
  export type DocumentoEstudianteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * Filter, which DocumentoEstudiantes to fetch.
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentoEstudiantes to fetch.
     */
    orderBy?: DocumentoEstudianteOrderByWithRelationInput | DocumentoEstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentoEstudiantes.
     */
    cursor?: DocumentoEstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentoEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentoEstudiantes.
     */
    skip?: number
    distinct?: DocumentoEstudianteScalarFieldEnum | DocumentoEstudianteScalarFieldEnum[]
  }

  /**
   * DocumentoEstudiante create
   */
  export type DocumentoEstudianteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentoEstudiante.
     */
    data: XOR<DocumentoEstudianteCreateInput, DocumentoEstudianteUncheckedCreateInput>
  }

  /**
   * DocumentoEstudiante createMany
   */
  export type DocumentoEstudianteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentoEstudiantes.
     */
    data: DocumentoEstudianteCreateManyInput | DocumentoEstudianteCreateManyInput[]
  }

  /**
   * DocumentoEstudiante createManyAndReturn
   */
  export type DocumentoEstudianteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentoEstudiantes.
     */
    data: DocumentoEstudianteCreateManyInput | DocumentoEstudianteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentoEstudiante update
   */
  export type DocumentoEstudianteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentoEstudiante.
     */
    data: XOR<DocumentoEstudianteUpdateInput, DocumentoEstudianteUncheckedUpdateInput>
    /**
     * Choose, which DocumentoEstudiante to update.
     */
    where: DocumentoEstudianteWhereUniqueInput
  }

  /**
   * DocumentoEstudiante updateMany
   */
  export type DocumentoEstudianteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentoEstudiantes.
     */
    data: XOR<DocumentoEstudianteUpdateManyMutationInput, DocumentoEstudianteUncheckedUpdateManyInput>
    /**
     * Filter which DocumentoEstudiantes to update
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * Limit how many DocumentoEstudiantes to update.
     */
    limit?: number
  }

  /**
   * DocumentoEstudiante updateManyAndReturn
   */
  export type DocumentoEstudianteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * The data used to update DocumentoEstudiantes.
     */
    data: XOR<DocumentoEstudianteUpdateManyMutationInput, DocumentoEstudianteUncheckedUpdateManyInput>
    /**
     * Filter which DocumentoEstudiantes to update
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * Limit how many DocumentoEstudiantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentoEstudiante upsert
   */
  export type DocumentoEstudianteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentoEstudiante to update in case it exists.
     */
    where: DocumentoEstudianteWhereUniqueInput
    /**
     * In case the DocumentoEstudiante found by the `where` argument doesn't exist, create a new DocumentoEstudiante with this data.
     */
    create: XOR<DocumentoEstudianteCreateInput, DocumentoEstudianteUncheckedCreateInput>
    /**
     * In case the DocumentoEstudiante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentoEstudianteUpdateInput, DocumentoEstudianteUncheckedUpdateInput>
  }

  /**
   * DocumentoEstudiante delete
   */
  export type DocumentoEstudianteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
    /**
     * Filter which DocumentoEstudiante to delete.
     */
    where: DocumentoEstudianteWhereUniqueInput
  }

  /**
   * DocumentoEstudiante deleteMany
   */
  export type DocumentoEstudianteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentoEstudiantes to delete
     */
    where?: DocumentoEstudianteWhereInput
    /**
     * Limit how many DocumentoEstudiantes to delete.
     */
    limit?: number
  }

  /**
   * DocumentoEstudiante without action
   */
  export type DocumentoEstudianteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoEstudiante
     */
    select?: DocumentoEstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentoEstudiante
     */
    omit?: DocumentoEstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoEstudianteInclude<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: string | null
    tipo: $Enums.TipoNotificacion | null
    titulo: string | null
    mensaje: string | null
    leida: boolean | null
    documentoId: string | null
    estudianteId: string | null
    createdAt: Date | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: string | null
    tipo: $Enums.TipoNotificacion | null
    titulo: string | null
    mensaje: string | null
    leida: boolean | null
    documentoId: string | null
    estudianteId: string | null
    createdAt: Date | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    tipo: number
    titulo: number
    mensaje: number
    leida: number
    documentoId: number
    estudianteId: number
    createdAt: number
    _all: number
  }


  export type NotificacionMinAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    leida?: true
    documentoId?: true
    estudianteId?: true
    createdAt?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    leida?: true
    documentoId?: true
    estudianteId?: true
    createdAt?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    leida?: true
    documentoId?: true
    estudianteId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida: boolean
    documentoId: string | null
    estudianteId: string
    createdAt: Date
    _count: NotificacionCountAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    leida?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    leida?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    leida?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectScalar = {
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    leida?: boolean
    documentoId?: boolean
    estudianteId?: boolean
    createdAt?: boolean
  }

  export type NotificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "titulo" | "mensaje" | "leida" | "documentoId" | "estudianteId" | "createdAt", ExtArgs["result"]["notificacion"]>
  export type NotificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }
  export type NotificacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }
  export type NotificacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
  }

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: $Enums.TipoNotificacion
      titulo: string
      mensaje: string
      leida: boolean
      documentoId: string | null
      estudianteId: string
      createdAt: Date
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificacions and returns the data saved in the database.
     * @param {NotificacionCreateManyAndReturnArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificacionCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions and returns the data updated in the database.
     * @param {NotificacionUpdateManyAndReturnArgs} args - Arguments to update many Notificacions.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificacionUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'String'>
    readonly tipo: FieldRef<"Notificacion", 'TipoNotificacion'>
    readonly titulo: FieldRef<"Notificacion", 'String'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly leida: FieldRef<"Notificacion", 'Boolean'>
    readonly documentoId: FieldRef<"Notificacion", 'String'>
    readonly estudianteId: FieldRef<"Notificacion", 'String'>
    readonly createdAt: FieldRef<"Notificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
  }

  /**
   * Notificacion createManyAndReturn
   */
  export type NotificacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
  }

  /**
   * Notificacion updateManyAndReturn
   */
  export type NotificacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to delete.
     */
    limit?: number
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
  }


  /**
   * Model ActividadUsuario
   */

  export type AggregateActividadUsuario = {
    _count: ActividadUsuarioCountAggregateOutputType | null
    _min: ActividadUsuarioMinAggregateOutputType | null
    _max: ActividadUsuarioMaxAggregateOutputType | null
  }

  export type ActividadUsuarioMinAggregateOutputType = {
    id: string | null
    accion: string | null
    entidad: string | null
    entidadId: string | null
    descripcion: string | null
    ipAddress: string | null
    userAgent: string | null
    usuarioId: string | null
    createdAt: Date | null
  }

  export type ActividadUsuarioMaxAggregateOutputType = {
    id: string | null
    accion: string | null
    entidad: string | null
    entidadId: string | null
    descripcion: string | null
    ipAddress: string | null
    userAgent: string | null
    usuarioId: string | null
    createdAt: Date | null
  }

  export type ActividadUsuarioCountAggregateOutputType = {
    id: number
    accion: number
    entidad: number
    entidadId: number
    descripcion: number
    ipAddress: number
    userAgent: number
    usuarioId: number
    createdAt: number
    _all: number
  }


  export type ActividadUsuarioMinAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    descripcion?: true
    ipAddress?: true
    userAgent?: true
    usuarioId?: true
    createdAt?: true
  }

  export type ActividadUsuarioMaxAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    descripcion?: true
    ipAddress?: true
    userAgent?: true
    usuarioId?: true
    createdAt?: true
  }

  export type ActividadUsuarioCountAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    descripcion?: true
    ipAddress?: true
    userAgent?: true
    usuarioId?: true
    createdAt?: true
    _all?: true
  }

  export type ActividadUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActividadUsuario to aggregate.
     */
    where?: ActividadUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadUsuarios to fetch.
     */
    orderBy?: ActividadUsuarioOrderByWithRelationInput | ActividadUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActividadUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActividadUsuarios
    **/
    _count?: true | ActividadUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadUsuarioMaxAggregateInputType
  }

  export type GetActividadUsuarioAggregateType<T extends ActividadUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateActividadUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividadUsuario[P]>
      : GetScalarType<T[P], AggregateActividadUsuario[P]>
  }




  export type ActividadUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadUsuarioWhereInput
    orderBy?: ActividadUsuarioOrderByWithAggregationInput | ActividadUsuarioOrderByWithAggregationInput[]
    by: ActividadUsuarioScalarFieldEnum[] | ActividadUsuarioScalarFieldEnum
    having?: ActividadUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadUsuarioCountAggregateInputType | true
    _min?: ActividadUsuarioMinAggregateInputType
    _max?: ActividadUsuarioMaxAggregateInputType
  }

  export type ActividadUsuarioGroupByOutputType = {
    id: string
    accion: string
    entidad: string | null
    entidadId: string | null
    descripcion: string | null
    ipAddress: string | null
    userAgent: string | null
    usuarioId: string
    createdAt: Date
    _count: ActividadUsuarioCountAggregateOutputType | null
    _min: ActividadUsuarioMinAggregateOutputType | null
    _max: ActividadUsuarioMaxAggregateOutputType | null
  }

  type GetActividadUsuarioGroupByPayload<T extends ActividadUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActividadUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type ActividadUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    descripcion?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividadUsuario"]>

  export type ActividadUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    descripcion?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividadUsuario"]>

  export type ActividadUsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    descripcion?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividadUsuario"]>

  export type ActividadUsuarioSelectScalar = {
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    descripcion?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usuarioId?: boolean
    createdAt?: boolean
  }

  export type ActividadUsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accion" | "entidad" | "entidadId" | "descripcion" | "ipAddress" | "userAgent" | "usuarioId" | "createdAt", ExtArgs["result"]["actividadUsuario"]>
  export type ActividadUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ActividadUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ActividadUsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ActividadUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActividadUsuario"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accion: string
      entidad: string | null
      entidadId: string | null
      descripcion: string | null
      ipAddress: string | null
      userAgent: string | null
      usuarioId: string
      createdAt: Date
    }, ExtArgs["result"]["actividadUsuario"]>
    composites: {}
  }

  type ActividadUsuarioGetPayload<S extends boolean | null | undefined | ActividadUsuarioDefaultArgs> = $Result.GetResult<Prisma.$ActividadUsuarioPayload, S>

  type ActividadUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActividadUsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActividadUsuarioCountAggregateInputType | true
    }

  export interface ActividadUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActividadUsuario'], meta: { name: 'ActividadUsuario' } }
    /**
     * Find zero or one ActividadUsuario that matches the filter.
     * @param {ActividadUsuarioFindUniqueArgs} args - Arguments to find a ActividadUsuario
     * @example
     * // Get one ActividadUsuario
     * const actividadUsuario = await prisma.actividadUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActividadUsuarioFindUniqueArgs>(args: SelectSubset<T, ActividadUsuarioFindUniqueArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActividadUsuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActividadUsuarioFindUniqueOrThrowArgs} args - Arguments to find a ActividadUsuario
     * @example
     * // Get one ActividadUsuario
     * const actividadUsuario = await prisma.actividadUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActividadUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ActividadUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActividadUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioFindFirstArgs} args - Arguments to find a ActividadUsuario
     * @example
     * // Get one ActividadUsuario
     * const actividadUsuario = await prisma.actividadUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActividadUsuarioFindFirstArgs>(args?: SelectSubset<T, ActividadUsuarioFindFirstArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActividadUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioFindFirstOrThrowArgs} args - Arguments to find a ActividadUsuario
     * @example
     * // Get one ActividadUsuario
     * const actividadUsuario = await prisma.actividadUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActividadUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ActividadUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActividadUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActividadUsuarios
     * const actividadUsuarios = await prisma.actividadUsuario.findMany()
     * 
     * // Get first 10 ActividadUsuarios
     * const actividadUsuarios = await prisma.actividadUsuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actividadUsuarioWithIdOnly = await prisma.actividadUsuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActividadUsuarioFindManyArgs>(args?: SelectSubset<T, ActividadUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActividadUsuario.
     * @param {ActividadUsuarioCreateArgs} args - Arguments to create a ActividadUsuario.
     * @example
     * // Create one ActividadUsuario
     * const ActividadUsuario = await prisma.actividadUsuario.create({
     *   data: {
     *     // ... data to create a ActividadUsuario
     *   }
     * })
     * 
     */
    create<T extends ActividadUsuarioCreateArgs>(args: SelectSubset<T, ActividadUsuarioCreateArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActividadUsuarios.
     * @param {ActividadUsuarioCreateManyArgs} args - Arguments to create many ActividadUsuarios.
     * @example
     * // Create many ActividadUsuarios
     * const actividadUsuario = await prisma.actividadUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActividadUsuarioCreateManyArgs>(args?: SelectSubset<T, ActividadUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActividadUsuarios and returns the data saved in the database.
     * @param {ActividadUsuarioCreateManyAndReturnArgs} args - Arguments to create many ActividadUsuarios.
     * @example
     * // Create many ActividadUsuarios
     * const actividadUsuario = await prisma.actividadUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActividadUsuarios and only return the `id`
     * const actividadUsuarioWithIdOnly = await prisma.actividadUsuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActividadUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ActividadUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActividadUsuario.
     * @param {ActividadUsuarioDeleteArgs} args - Arguments to delete one ActividadUsuario.
     * @example
     * // Delete one ActividadUsuario
     * const ActividadUsuario = await prisma.actividadUsuario.delete({
     *   where: {
     *     // ... filter to delete one ActividadUsuario
     *   }
     * })
     * 
     */
    delete<T extends ActividadUsuarioDeleteArgs>(args: SelectSubset<T, ActividadUsuarioDeleteArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActividadUsuario.
     * @param {ActividadUsuarioUpdateArgs} args - Arguments to update one ActividadUsuario.
     * @example
     * // Update one ActividadUsuario
     * const actividadUsuario = await prisma.actividadUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActividadUsuarioUpdateArgs>(args: SelectSubset<T, ActividadUsuarioUpdateArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActividadUsuarios.
     * @param {ActividadUsuarioDeleteManyArgs} args - Arguments to filter ActividadUsuarios to delete.
     * @example
     * // Delete a few ActividadUsuarios
     * const { count } = await prisma.actividadUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActividadUsuarioDeleteManyArgs>(args?: SelectSubset<T, ActividadUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActividadUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActividadUsuarios
     * const actividadUsuario = await prisma.actividadUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActividadUsuarioUpdateManyArgs>(args: SelectSubset<T, ActividadUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActividadUsuarios and returns the data updated in the database.
     * @param {ActividadUsuarioUpdateManyAndReturnArgs} args - Arguments to update many ActividadUsuarios.
     * @example
     * // Update many ActividadUsuarios
     * const actividadUsuario = await prisma.actividadUsuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActividadUsuarios and only return the `id`
     * const actividadUsuarioWithIdOnly = await prisma.actividadUsuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActividadUsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ActividadUsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActividadUsuario.
     * @param {ActividadUsuarioUpsertArgs} args - Arguments to update or create a ActividadUsuario.
     * @example
     * // Update or create a ActividadUsuario
     * const actividadUsuario = await prisma.actividadUsuario.upsert({
     *   create: {
     *     // ... data to create a ActividadUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActividadUsuario we want to update
     *   }
     * })
     */
    upsert<T extends ActividadUsuarioUpsertArgs>(args: SelectSubset<T, ActividadUsuarioUpsertArgs<ExtArgs>>): Prisma__ActividadUsuarioClient<$Result.GetResult<Prisma.$ActividadUsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActividadUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioCountArgs} args - Arguments to filter ActividadUsuarios to count.
     * @example
     * // Count the number of ActividadUsuarios
     * const count = await prisma.actividadUsuario.count({
     *   where: {
     *     // ... the filter for the ActividadUsuarios we want to count
     *   }
     * })
    **/
    count<T extends ActividadUsuarioCountArgs>(
      args?: Subset<T, ActividadUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActividadUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadUsuarioAggregateArgs>(args: Subset<T, ActividadUsuarioAggregateArgs>): Prisma.PrismaPromise<GetActividadUsuarioAggregateType<T>>

    /**
     * Group by ActividadUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActividadUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActividadUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: ActividadUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActividadUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActividadUsuario model
   */
  readonly fields: ActividadUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActividadUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActividadUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActividadUsuario model
   */
  interface ActividadUsuarioFieldRefs {
    readonly id: FieldRef<"ActividadUsuario", 'String'>
    readonly accion: FieldRef<"ActividadUsuario", 'String'>
    readonly entidad: FieldRef<"ActividadUsuario", 'String'>
    readonly entidadId: FieldRef<"ActividadUsuario", 'String'>
    readonly descripcion: FieldRef<"ActividadUsuario", 'String'>
    readonly ipAddress: FieldRef<"ActividadUsuario", 'String'>
    readonly userAgent: FieldRef<"ActividadUsuario", 'String'>
    readonly usuarioId: FieldRef<"ActividadUsuario", 'String'>
    readonly createdAt: FieldRef<"ActividadUsuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActividadUsuario findUnique
   */
  export type ActividadUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ActividadUsuario to fetch.
     */
    where: ActividadUsuarioWhereUniqueInput
  }

  /**
   * ActividadUsuario findUniqueOrThrow
   */
  export type ActividadUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ActividadUsuario to fetch.
     */
    where: ActividadUsuarioWhereUniqueInput
  }

  /**
   * ActividadUsuario findFirst
   */
  export type ActividadUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ActividadUsuario to fetch.
     */
    where?: ActividadUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadUsuarios to fetch.
     */
    orderBy?: ActividadUsuarioOrderByWithRelationInput | ActividadUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActividadUsuarios.
     */
    cursor?: ActividadUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActividadUsuarios.
     */
    distinct?: ActividadUsuarioScalarFieldEnum | ActividadUsuarioScalarFieldEnum[]
  }

  /**
   * ActividadUsuario findFirstOrThrow
   */
  export type ActividadUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ActividadUsuario to fetch.
     */
    where?: ActividadUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadUsuarios to fetch.
     */
    orderBy?: ActividadUsuarioOrderByWithRelationInput | ActividadUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActividadUsuarios.
     */
    cursor?: ActividadUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActividadUsuarios.
     */
    distinct?: ActividadUsuarioScalarFieldEnum | ActividadUsuarioScalarFieldEnum[]
  }

  /**
   * ActividadUsuario findMany
   */
  export type ActividadUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ActividadUsuarios to fetch.
     */
    where?: ActividadUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadUsuarios to fetch.
     */
    orderBy?: ActividadUsuarioOrderByWithRelationInput | ActividadUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActividadUsuarios.
     */
    cursor?: ActividadUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadUsuarios.
     */
    skip?: number
    distinct?: ActividadUsuarioScalarFieldEnum | ActividadUsuarioScalarFieldEnum[]
  }

  /**
   * ActividadUsuario create
   */
  export type ActividadUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a ActividadUsuario.
     */
    data: XOR<ActividadUsuarioCreateInput, ActividadUsuarioUncheckedCreateInput>
  }

  /**
   * ActividadUsuario createMany
   */
  export type ActividadUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActividadUsuarios.
     */
    data: ActividadUsuarioCreateManyInput | ActividadUsuarioCreateManyInput[]
  }

  /**
   * ActividadUsuario createManyAndReturn
   */
  export type ActividadUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many ActividadUsuarios.
     */
    data: ActividadUsuarioCreateManyInput | ActividadUsuarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActividadUsuario update
   */
  export type ActividadUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a ActividadUsuario.
     */
    data: XOR<ActividadUsuarioUpdateInput, ActividadUsuarioUncheckedUpdateInput>
    /**
     * Choose, which ActividadUsuario to update.
     */
    where: ActividadUsuarioWhereUniqueInput
  }

  /**
   * ActividadUsuario updateMany
   */
  export type ActividadUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActividadUsuarios.
     */
    data: XOR<ActividadUsuarioUpdateManyMutationInput, ActividadUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which ActividadUsuarios to update
     */
    where?: ActividadUsuarioWhereInput
    /**
     * Limit how many ActividadUsuarios to update.
     */
    limit?: number
  }

  /**
   * ActividadUsuario updateManyAndReturn
   */
  export type ActividadUsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * The data used to update ActividadUsuarios.
     */
    data: XOR<ActividadUsuarioUpdateManyMutationInput, ActividadUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which ActividadUsuarios to update
     */
    where?: ActividadUsuarioWhereInput
    /**
     * Limit how many ActividadUsuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActividadUsuario upsert
   */
  export type ActividadUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the ActividadUsuario to update in case it exists.
     */
    where: ActividadUsuarioWhereUniqueInput
    /**
     * In case the ActividadUsuario found by the `where` argument doesn't exist, create a new ActividadUsuario with this data.
     */
    create: XOR<ActividadUsuarioCreateInput, ActividadUsuarioUncheckedCreateInput>
    /**
     * In case the ActividadUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActividadUsuarioUpdateInput, ActividadUsuarioUncheckedUpdateInput>
  }

  /**
   * ActividadUsuario delete
   */
  export type ActividadUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
    /**
     * Filter which ActividadUsuario to delete.
     */
    where: ActividadUsuarioWhereUniqueInput
  }

  /**
   * ActividadUsuario deleteMany
   */
  export type ActividadUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActividadUsuarios to delete
     */
    where?: ActividadUsuarioWhereInput
    /**
     * Limit how many ActividadUsuarios to delete.
     */
    limit?: number
  }

  /**
   * ActividadUsuario without action
   */
  export type ActividadUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadUsuario
     */
    select?: ActividadUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActividadUsuario
     */
    omit?: ActividadUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadUsuarioInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    nombre: 'nombre',
    apellidoPaterno: 'apellidoPaterno',
    apellidoMaterno: 'apellidoMaterno',
    telefono: 'telefono',
    rol: 'rol',
    activo: 'activo',
    emailVerificado: 'emailVerificado',
    primerLogin: 'primerLogin',
    intentosFallidos: 'intentosFallidos',
    bloqueadoHasta: 'bloqueadoHasta',
    ultimoAcceso: 'ultimoAcceso',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const TokenSesionScalarFieldEnum: {
    id: 'id',
    token: 'token',
    tipo: 'tipo',
    expiraEn: 'expiraEn',
    revocado: 'revocado',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt'
  };

  export type TokenSesionScalarFieldEnum = (typeof TokenSesionScalarFieldEnum)[keyof typeof TokenSesionScalarFieldEnum]


  export const EstudianteScalarFieldEnum: {
    id: 'id',
    matricula: 'matricula',
    fechaNacimiento: 'fechaNacimiento',
    curp: 'curp',
    nss: 'nss',
    direccion: 'direccion',
    ciudad: 'ciudad',
    estado: 'estado',
    codigoPostal: 'codigoPostal',
    tutorNombre: 'tutorNombre',
    tutorTelefono: 'tutorTelefono',
    tutorEmail: 'tutorEmail',
    estatus: 'estatus',
    fechaIngreso: 'fechaIngreso',
    fechaEgreso: 'fechaEgreso',
    usuarioId: 'usuarioId',
    carreraId: 'carreraId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EstudianteScalarFieldEnum = (typeof EstudianteScalarFieldEnum)[keyof typeof EstudianteScalarFieldEnum]


  export const CarreraScalarFieldEnum: {
    id: 'id',
    clave: 'clave',
    nombre: 'nombre',
    descripcion: 'descripcion',
    duracionSemestres: 'duracionSemestres',
    creditos: 'creditos',
    modalidad: 'modalidad',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CarreraScalarFieldEnum = (typeof CarreraScalarFieldEnum)[keyof typeof CarreraScalarFieldEnum]


  export const MateriaScalarFieldEnum: {
    id: 'id',
    clave: 'clave',
    nombre: 'nombre',
    descripcion: 'descripcion',
    creditos: 'creditos',
    semestre: 'semestre',
    horasTeoria: 'horasTeoria',
    horasPractica: 'horasPractica',
    activo: 'activo',
    carreraId: 'carreraId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MateriaScalarFieldEnum = (typeof MateriaScalarFieldEnum)[keyof typeof MateriaScalarFieldEnum]


  export const GrupoScalarFieldEnum: {
    id: 'id',
    clave: 'clave',
    periodo: 'periodo',
    cupoMaximo: 'cupoMaximo',
    cupoDisponible: 'cupoDisponible',
    horario: 'horario',
    aula: 'aula',
    activo: 'activo',
    materiaId: 'materiaId',
    profesorId: 'profesorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GrupoScalarFieldEnum = (typeof GrupoScalarFieldEnum)[keyof typeof GrupoScalarFieldEnum]


  export const InscripcionScalarFieldEnum: {
    id: 'id',
    periodo: 'periodo',
    estatus: 'estatus',
    fechaInscripcion: 'fechaInscripcion',
    estudianteId: 'estudianteId',
    grupoId: 'grupoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InscripcionScalarFieldEnum = (typeof InscripcionScalarFieldEnum)[keyof typeof InscripcionScalarFieldEnum]


  export const CalificacionScalarFieldEnum: {
    id: 'id',
    calificacion: 'calificacion',
    estatus: 'estatus',
    observaciones: 'observaciones',
    estudianteId: 'estudianteId',
    materiaId: 'materiaId',
    inscripcionId: 'inscripcionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalificacionScalarFieldEnum = (typeof CalificacionScalarFieldEnum)[keyof typeof CalificacionScalarFieldEnum]


  export const ProfesorScalarFieldEnum: {
    id: 'id',
    numeroEmpleado: 'numeroEmpleado',
    especialidad: 'especialidad',
    grado: 'grado',
    departamento: 'departamento',
    activo: 'activo',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfesorScalarFieldEnum = (typeof ProfesorScalarFieldEnum)[keyof typeof ProfesorScalarFieldEnum]


  export const AdministradorScalarFieldEnum: {
    id: 'id',
    numeroEmpleado: 'numeroEmpleado',
    area: 'area',
    cargo: 'cargo',
    activo: 'activo',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdministradorScalarFieldEnum = (typeof AdministradorScalarFieldEnum)[keyof typeof AdministradorScalarFieldEnum]


  export const DocumentoScalarFieldEnum: {
    id: 'id',
    folio: 'folio',
    tipo: 'tipo',
    titulo: 'titulo',
    descripcion: 'descripcion',
    rutaArchivo: 'rutaArchivo',
    rutaArchivoFirmado: 'rutaArchivoFirmado',
    hashArchivo: 'hashArchivo',
    tamanoBytes: 'tamanoBytes',
    mimeType: 'mimeType',
    estatus: 'estatus',
    fechaEmision: 'fechaEmision',
    fechaVencimiento: 'fechaVencimiento',
    validado: 'validado',
    firmado: 'firmado',
    cadenaBlockchain: 'cadenaBlockchain',
    qrCode: 'qrCode',
    creadoPorId: 'creadoPorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentoScalarFieldEnum = (typeof DocumentoScalarFieldEnum)[keyof typeof DocumentoScalarFieldEnum]


  export const DocumentoEstudianteScalarFieldEnum: {
    id: 'id',
    observaciones: 'observaciones',
    motivoRechazo: 'motivoRechazo',
    revisadoPor: 'revisadoPor',
    fechaRevision: 'fechaRevision',
    escaneoVirus: 'escaneoVirus',
    virusDetectado: 'virusDetectado',
    nombreVirusDetectado: 'nombreVirusDetectado',
    documentoId: 'documentoId',
    estudianteId: 'estudianteId',
    createdAt: 'createdAt'
  };

  export type DocumentoEstudianteScalarFieldEnum = (typeof DocumentoEstudianteScalarFieldEnum)[keyof typeof DocumentoEstudianteScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    titulo: 'titulo',
    mensaje: 'mensaje',
    leida: 'leida',
    documentoId: 'documentoId',
    estudianteId: 'estudianteId',
    createdAt: 'createdAt'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const ActividadUsuarioScalarFieldEnum: {
    id: 'id',
    accion: 'accion',
    entidad: 'entidad',
    entidadId: 'entidadId',
    descripcion: 'descripcion',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt'
  };

  export type ActividadUsuarioScalarFieldEnum = (typeof ActividadUsuarioScalarFieldEnum)[keyof typeof ActividadUsuarioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'TipoToken'
   */
  export type EnumTipoTokenFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoToken'>
    


  /**
   * Reference to a field of type 'EstatusEstudiante'
   */
  export type EnumEstatusEstudianteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstatusEstudiante'>
    


  /**
   * Reference to a field of type 'Modalidad'
   */
  export type EnumModalidadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Modalidad'>
    


  /**
   * Reference to a field of type 'EstatusInscripcion'
   */
  export type EnumEstatusInscripcionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstatusInscripcion'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'TipoDocumento'
   */
  export type EnumTipoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDocumento'>
    


  /**
   * Reference to a field of type 'EstatusDocumento'
   */
  export type EnumEstatusDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstatusDocumento'>
    


  /**
   * Reference to a field of type 'TipoNotificacion'
   */
  export type EnumTipoNotificacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoNotificacion'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    password?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellidoPaterno?: StringFilter<"Usuario"> | string
    apellidoMaterno?: StringNullableFilter<"Usuario"> | string | null
    telefono?: StringNullableFilter<"Usuario"> | string | null
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    activo?: BoolFilter<"Usuario"> | boolean
    emailVerificado?: BoolFilter<"Usuario"> | boolean
    primerLogin?: BoolFilter<"Usuario"> | boolean
    intentosFallidos?: IntFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
    profesor?: XOR<ProfesorNullableScalarRelationFilter, ProfesorWhereInput> | null
    administrador?: XOR<AdministradorNullableScalarRelationFilter, AdministradorWhereInput> | null
    tokens?: TokenSesionListRelationFilter
    actividades?: ActividadUsuarioListRelationFilter
    documentosCreados?: DocumentoListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    apellidoPaterno?: SortOrder
    apellidoMaterno?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    rol?: SortOrder
    activo?: SortOrder
    emailVerificado?: SortOrder
    primerLogin?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrderInput | SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    profesor?: ProfesorOrderByWithRelationInput
    administrador?: AdministradorOrderByWithRelationInput
    tokens?: TokenSesionOrderByRelationAggregateInput
    actividades?: ActividadUsuarioOrderByRelationAggregateInput
    documentosCreados?: DocumentoOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    password?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellidoPaterno?: StringFilter<"Usuario"> | string
    apellidoMaterno?: StringNullableFilter<"Usuario"> | string | null
    telefono?: StringNullableFilter<"Usuario"> | string | null
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    activo?: BoolFilter<"Usuario"> | boolean
    emailVerificado?: BoolFilter<"Usuario"> | boolean
    primerLogin?: BoolFilter<"Usuario"> | boolean
    intentosFallidos?: IntFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
    profesor?: XOR<ProfesorNullableScalarRelationFilter, ProfesorWhereInput> | null
    administrador?: XOR<AdministradorNullableScalarRelationFilter, AdministradorWhereInput> | null
    tokens?: TokenSesionListRelationFilter
    actividades?: ActividadUsuarioListRelationFilter
    documentosCreados?: DocumentoListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    apellidoPaterno?: SortOrder
    apellidoMaterno?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    rol?: SortOrder
    activo?: SortOrder
    emailVerificado?: SortOrder
    primerLogin?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrderInput | SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    password?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellidoPaterno?: StringWithAggregatesFilter<"Usuario"> | string
    apellidoMaterno?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    activo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    emailVerificado?: BoolWithAggregatesFilter<"Usuario"> | boolean
    primerLogin?: BoolWithAggregatesFilter<"Usuario"> | boolean
    intentosFallidos?: IntWithAggregatesFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type TokenSesionWhereInput = {
    AND?: TokenSesionWhereInput | TokenSesionWhereInput[]
    OR?: TokenSesionWhereInput[]
    NOT?: TokenSesionWhereInput | TokenSesionWhereInput[]
    id?: StringFilter<"TokenSesion"> | string
    token?: StringFilter<"TokenSesion"> | string
    tipo?: EnumTipoTokenFilter<"TokenSesion"> | $Enums.TipoToken
    expiraEn?: DateTimeFilter<"TokenSesion"> | Date | string
    revocado?: BoolFilter<"TokenSesion"> | boolean
    ipAddress?: StringNullableFilter<"TokenSesion"> | string | null
    userAgent?: StringNullableFilter<"TokenSesion"> | string | null
    usuarioId?: StringFilter<"TokenSesion"> | string
    createdAt?: DateTimeFilter<"TokenSesion"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type TokenSesionOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    tipo?: SortOrder
    expiraEn?: SortOrder
    revocado?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type TokenSesionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TokenSesionWhereInput | TokenSesionWhereInput[]
    OR?: TokenSesionWhereInput[]
    NOT?: TokenSesionWhereInput | TokenSesionWhereInput[]
    tipo?: EnumTipoTokenFilter<"TokenSesion"> | $Enums.TipoToken
    expiraEn?: DateTimeFilter<"TokenSesion"> | Date | string
    revocado?: BoolFilter<"TokenSesion"> | boolean
    ipAddress?: StringNullableFilter<"TokenSesion"> | string | null
    userAgent?: StringNullableFilter<"TokenSesion"> | string | null
    usuarioId?: StringFilter<"TokenSesion"> | string
    createdAt?: DateTimeFilter<"TokenSesion"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "token">

  export type TokenSesionOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    tipo?: SortOrder
    expiraEn?: SortOrder
    revocado?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    _count?: TokenSesionCountOrderByAggregateInput
    _max?: TokenSesionMaxOrderByAggregateInput
    _min?: TokenSesionMinOrderByAggregateInput
  }

  export type TokenSesionScalarWhereWithAggregatesInput = {
    AND?: TokenSesionScalarWhereWithAggregatesInput | TokenSesionScalarWhereWithAggregatesInput[]
    OR?: TokenSesionScalarWhereWithAggregatesInput[]
    NOT?: TokenSesionScalarWhereWithAggregatesInput | TokenSesionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenSesion"> | string
    token?: StringWithAggregatesFilter<"TokenSesion"> | string
    tipo?: EnumTipoTokenWithAggregatesFilter<"TokenSesion"> | $Enums.TipoToken
    expiraEn?: DateTimeWithAggregatesFilter<"TokenSesion"> | Date | string
    revocado?: BoolWithAggregatesFilter<"TokenSesion"> | boolean
    ipAddress?: StringNullableWithAggregatesFilter<"TokenSesion"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"TokenSesion"> | string | null
    usuarioId?: StringWithAggregatesFilter<"TokenSesion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TokenSesion"> | Date | string
  }

  export type EstudianteWhereInput = {
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    id?: StringFilter<"Estudiante"> | string
    matricula?: StringFilter<"Estudiante"> | string
    fechaNacimiento?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    curp?: StringNullableFilter<"Estudiante"> | string | null
    nss?: StringNullableFilter<"Estudiante"> | string | null
    direccion?: StringNullableFilter<"Estudiante"> | string | null
    ciudad?: StringNullableFilter<"Estudiante"> | string | null
    estado?: StringNullableFilter<"Estudiante"> | string | null
    codigoPostal?: StringNullableFilter<"Estudiante"> | string | null
    tutorNombre?: StringNullableFilter<"Estudiante"> | string | null
    tutorTelefono?: StringNullableFilter<"Estudiante"> | string | null
    tutorEmail?: StringNullableFilter<"Estudiante"> | string | null
    estatus?: EnumEstatusEstudianteFilter<"Estudiante"> | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFilter<"Estudiante"> | Date | string
    fechaEgreso?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    usuarioId?: StringFilter<"Estudiante"> | string
    carreraId?: StringNullableFilter<"Estudiante"> | string | null
    createdAt?: DateTimeFilter<"Estudiante"> | Date | string
    updatedAt?: DateTimeFilter<"Estudiante"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    carrera?: XOR<CarreraNullableScalarRelationFilter, CarreraWhereInput> | null
    inscripciones?: InscripcionListRelationFilter
    calificaciones?: CalificacionListRelationFilter
    documentos?: DocumentoEstudianteListRelationFilter
    notificaciones?: NotificacionListRelationFilter
  }

  export type EstudianteOrderByWithRelationInput = {
    id?: SortOrder
    matricula?: SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    curp?: SortOrderInput | SortOrder
    nss?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    ciudad?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    codigoPostal?: SortOrderInput | SortOrder
    tutorNombre?: SortOrderInput | SortOrder
    tutorTelefono?: SortOrderInput | SortOrder
    tutorEmail?: SortOrderInput | SortOrder
    estatus?: SortOrder
    fechaIngreso?: SortOrder
    fechaEgreso?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    carreraId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    carrera?: CarreraOrderByWithRelationInput
    inscripciones?: InscripcionOrderByRelationAggregateInput
    calificaciones?: CalificacionOrderByRelationAggregateInput
    documentos?: DocumentoEstudianteOrderByRelationAggregateInput
    notificaciones?: NotificacionOrderByRelationAggregateInput
  }

  export type EstudianteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    matricula?: string
    curp?: string
    usuarioId?: string
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    fechaNacimiento?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    nss?: StringNullableFilter<"Estudiante"> | string | null
    direccion?: StringNullableFilter<"Estudiante"> | string | null
    ciudad?: StringNullableFilter<"Estudiante"> | string | null
    estado?: StringNullableFilter<"Estudiante"> | string | null
    codigoPostal?: StringNullableFilter<"Estudiante"> | string | null
    tutorNombre?: StringNullableFilter<"Estudiante"> | string | null
    tutorTelefono?: StringNullableFilter<"Estudiante"> | string | null
    tutorEmail?: StringNullableFilter<"Estudiante"> | string | null
    estatus?: EnumEstatusEstudianteFilter<"Estudiante"> | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFilter<"Estudiante"> | Date | string
    fechaEgreso?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    carreraId?: StringNullableFilter<"Estudiante"> | string | null
    createdAt?: DateTimeFilter<"Estudiante"> | Date | string
    updatedAt?: DateTimeFilter<"Estudiante"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    carrera?: XOR<CarreraNullableScalarRelationFilter, CarreraWhereInput> | null
    inscripciones?: InscripcionListRelationFilter
    calificaciones?: CalificacionListRelationFilter
    documentos?: DocumentoEstudianteListRelationFilter
    notificaciones?: NotificacionListRelationFilter
  }, "id" | "matricula" | "curp" | "usuarioId">

  export type EstudianteOrderByWithAggregationInput = {
    id?: SortOrder
    matricula?: SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    curp?: SortOrderInput | SortOrder
    nss?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    ciudad?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    codigoPostal?: SortOrderInput | SortOrder
    tutorNombre?: SortOrderInput | SortOrder
    tutorTelefono?: SortOrderInput | SortOrder
    tutorEmail?: SortOrderInput | SortOrder
    estatus?: SortOrder
    fechaIngreso?: SortOrder
    fechaEgreso?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    carreraId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EstudianteCountOrderByAggregateInput
    _max?: EstudianteMaxOrderByAggregateInput
    _min?: EstudianteMinOrderByAggregateInput
  }

  export type EstudianteScalarWhereWithAggregatesInput = {
    AND?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    OR?: EstudianteScalarWhereWithAggregatesInput[]
    NOT?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Estudiante"> | string
    matricula?: StringWithAggregatesFilter<"Estudiante"> | string
    fechaNacimiento?: DateTimeNullableWithAggregatesFilter<"Estudiante"> | Date | string | null
    curp?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    nss?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    ciudad?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    estado?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    codigoPostal?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    tutorNombre?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    tutorTelefono?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    tutorEmail?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    estatus?: EnumEstatusEstudianteWithAggregatesFilter<"Estudiante"> | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
    fechaEgreso?: DateTimeNullableWithAggregatesFilter<"Estudiante"> | Date | string | null
    usuarioId?: StringWithAggregatesFilter<"Estudiante"> | string
    carreraId?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
  }

  export type CarreraWhereInput = {
    AND?: CarreraWhereInput | CarreraWhereInput[]
    OR?: CarreraWhereInput[]
    NOT?: CarreraWhereInput | CarreraWhereInput[]
    id?: StringFilter<"Carrera"> | string
    clave?: StringFilter<"Carrera"> | string
    nombre?: StringFilter<"Carrera"> | string
    descripcion?: StringNullableFilter<"Carrera"> | string | null
    duracionSemestres?: IntFilter<"Carrera"> | number
    creditos?: IntFilter<"Carrera"> | number
    modalidad?: EnumModalidadFilter<"Carrera"> | $Enums.Modalidad
    activo?: BoolFilter<"Carrera"> | boolean
    createdAt?: DateTimeFilter<"Carrera"> | Date | string
    updatedAt?: DateTimeFilter<"Carrera"> | Date | string
    estudiantes?: EstudianteListRelationFilter
    materias?: MateriaListRelationFilter
  }

  export type CarreraOrderByWithRelationInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    duracionSemestres?: SortOrder
    creditos?: SortOrder
    modalidad?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estudiantes?: EstudianteOrderByRelationAggregateInput
    materias?: MateriaOrderByRelationAggregateInput
  }

  export type CarreraWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clave?: string
    AND?: CarreraWhereInput | CarreraWhereInput[]
    OR?: CarreraWhereInput[]
    NOT?: CarreraWhereInput | CarreraWhereInput[]
    nombre?: StringFilter<"Carrera"> | string
    descripcion?: StringNullableFilter<"Carrera"> | string | null
    duracionSemestres?: IntFilter<"Carrera"> | number
    creditos?: IntFilter<"Carrera"> | number
    modalidad?: EnumModalidadFilter<"Carrera"> | $Enums.Modalidad
    activo?: BoolFilter<"Carrera"> | boolean
    createdAt?: DateTimeFilter<"Carrera"> | Date | string
    updatedAt?: DateTimeFilter<"Carrera"> | Date | string
    estudiantes?: EstudianteListRelationFilter
    materias?: MateriaListRelationFilter
  }, "id" | "clave">

  export type CarreraOrderByWithAggregationInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    duracionSemestres?: SortOrder
    creditos?: SortOrder
    modalidad?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CarreraCountOrderByAggregateInput
    _avg?: CarreraAvgOrderByAggregateInput
    _max?: CarreraMaxOrderByAggregateInput
    _min?: CarreraMinOrderByAggregateInput
    _sum?: CarreraSumOrderByAggregateInput
  }

  export type CarreraScalarWhereWithAggregatesInput = {
    AND?: CarreraScalarWhereWithAggregatesInput | CarreraScalarWhereWithAggregatesInput[]
    OR?: CarreraScalarWhereWithAggregatesInput[]
    NOT?: CarreraScalarWhereWithAggregatesInput | CarreraScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Carrera"> | string
    clave?: StringWithAggregatesFilter<"Carrera"> | string
    nombre?: StringWithAggregatesFilter<"Carrera"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Carrera"> | string | null
    duracionSemestres?: IntWithAggregatesFilter<"Carrera"> | number
    creditos?: IntWithAggregatesFilter<"Carrera"> | number
    modalidad?: EnumModalidadWithAggregatesFilter<"Carrera"> | $Enums.Modalidad
    activo?: BoolWithAggregatesFilter<"Carrera"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Carrera"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Carrera"> | Date | string
  }

  export type MateriaWhereInput = {
    AND?: MateriaWhereInput | MateriaWhereInput[]
    OR?: MateriaWhereInput[]
    NOT?: MateriaWhereInput | MateriaWhereInput[]
    id?: StringFilter<"Materia"> | string
    clave?: StringFilter<"Materia"> | string
    nombre?: StringFilter<"Materia"> | string
    descripcion?: StringNullableFilter<"Materia"> | string | null
    creditos?: IntFilter<"Materia"> | number
    semestre?: IntFilter<"Materia"> | number
    horasTeoria?: IntFilter<"Materia"> | number
    horasPractica?: IntFilter<"Materia"> | number
    activo?: BoolFilter<"Materia"> | boolean
    carreraId?: StringFilter<"Materia"> | string
    createdAt?: DateTimeFilter<"Materia"> | Date | string
    updatedAt?: DateTimeFilter<"Materia"> | Date | string
    carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    grupos?: GrupoListRelationFilter
    calificaciones?: CalificacionListRelationFilter
  }

  export type MateriaOrderByWithRelationInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
    activo?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    carrera?: CarreraOrderByWithRelationInput
    grupos?: GrupoOrderByRelationAggregateInput
    calificaciones?: CalificacionOrderByRelationAggregateInput
  }

  export type MateriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clave?: string
    AND?: MateriaWhereInput | MateriaWhereInput[]
    OR?: MateriaWhereInput[]
    NOT?: MateriaWhereInput | MateriaWhereInput[]
    nombre?: StringFilter<"Materia"> | string
    descripcion?: StringNullableFilter<"Materia"> | string | null
    creditos?: IntFilter<"Materia"> | number
    semestre?: IntFilter<"Materia"> | number
    horasTeoria?: IntFilter<"Materia"> | number
    horasPractica?: IntFilter<"Materia"> | number
    activo?: BoolFilter<"Materia"> | boolean
    carreraId?: StringFilter<"Materia"> | string
    createdAt?: DateTimeFilter<"Materia"> | Date | string
    updatedAt?: DateTimeFilter<"Materia"> | Date | string
    carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    grupos?: GrupoListRelationFilter
    calificaciones?: CalificacionListRelationFilter
  }, "id" | "clave">

  export type MateriaOrderByWithAggregationInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
    activo?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MateriaCountOrderByAggregateInput
    _avg?: MateriaAvgOrderByAggregateInput
    _max?: MateriaMaxOrderByAggregateInput
    _min?: MateriaMinOrderByAggregateInput
    _sum?: MateriaSumOrderByAggregateInput
  }

  export type MateriaScalarWhereWithAggregatesInput = {
    AND?: MateriaScalarWhereWithAggregatesInput | MateriaScalarWhereWithAggregatesInput[]
    OR?: MateriaScalarWhereWithAggregatesInput[]
    NOT?: MateriaScalarWhereWithAggregatesInput | MateriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Materia"> | string
    clave?: StringWithAggregatesFilter<"Materia"> | string
    nombre?: StringWithAggregatesFilter<"Materia"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Materia"> | string | null
    creditos?: IntWithAggregatesFilter<"Materia"> | number
    semestre?: IntWithAggregatesFilter<"Materia"> | number
    horasTeoria?: IntWithAggregatesFilter<"Materia"> | number
    horasPractica?: IntWithAggregatesFilter<"Materia"> | number
    activo?: BoolWithAggregatesFilter<"Materia"> | boolean
    carreraId?: StringWithAggregatesFilter<"Materia"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Materia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Materia"> | Date | string
  }

  export type GrupoWhereInput = {
    AND?: GrupoWhereInput | GrupoWhereInput[]
    OR?: GrupoWhereInput[]
    NOT?: GrupoWhereInput | GrupoWhereInput[]
    id?: StringFilter<"Grupo"> | string
    clave?: StringFilter<"Grupo"> | string
    periodo?: StringFilter<"Grupo"> | string
    cupoMaximo?: IntFilter<"Grupo"> | number
    cupoDisponible?: IntFilter<"Grupo"> | number
    horario?: StringFilter<"Grupo"> | string
    aula?: StringNullableFilter<"Grupo"> | string | null
    activo?: BoolFilter<"Grupo"> | boolean
    materiaId?: StringFilter<"Grupo"> | string
    profesorId?: StringFilter<"Grupo"> | string
    createdAt?: DateTimeFilter<"Grupo"> | Date | string
    updatedAt?: DateTimeFilter<"Grupo"> | Date | string
    materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    profesor?: XOR<ProfesorScalarRelationFilter, ProfesorWhereInput>
    inscripciones?: InscripcionListRelationFilter
  }

  export type GrupoOrderByWithRelationInput = {
    id?: SortOrder
    clave?: SortOrder
    periodo?: SortOrder
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
    horario?: SortOrder
    aula?: SortOrderInput | SortOrder
    activo?: SortOrder
    materiaId?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materia?: MateriaOrderByWithRelationInput
    profesor?: ProfesorOrderByWithRelationInput
    inscripciones?: InscripcionOrderByRelationAggregateInput
  }

  export type GrupoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clave?: string
    AND?: GrupoWhereInput | GrupoWhereInput[]
    OR?: GrupoWhereInput[]
    NOT?: GrupoWhereInput | GrupoWhereInput[]
    periodo?: StringFilter<"Grupo"> | string
    cupoMaximo?: IntFilter<"Grupo"> | number
    cupoDisponible?: IntFilter<"Grupo"> | number
    horario?: StringFilter<"Grupo"> | string
    aula?: StringNullableFilter<"Grupo"> | string | null
    activo?: BoolFilter<"Grupo"> | boolean
    materiaId?: StringFilter<"Grupo"> | string
    profesorId?: StringFilter<"Grupo"> | string
    createdAt?: DateTimeFilter<"Grupo"> | Date | string
    updatedAt?: DateTimeFilter<"Grupo"> | Date | string
    materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    profesor?: XOR<ProfesorScalarRelationFilter, ProfesorWhereInput>
    inscripciones?: InscripcionListRelationFilter
  }, "id" | "clave">

  export type GrupoOrderByWithAggregationInput = {
    id?: SortOrder
    clave?: SortOrder
    periodo?: SortOrder
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
    horario?: SortOrder
    aula?: SortOrderInput | SortOrder
    activo?: SortOrder
    materiaId?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GrupoCountOrderByAggregateInput
    _avg?: GrupoAvgOrderByAggregateInput
    _max?: GrupoMaxOrderByAggregateInput
    _min?: GrupoMinOrderByAggregateInput
    _sum?: GrupoSumOrderByAggregateInput
  }

  export type GrupoScalarWhereWithAggregatesInput = {
    AND?: GrupoScalarWhereWithAggregatesInput | GrupoScalarWhereWithAggregatesInput[]
    OR?: GrupoScalarWhereWithAggregatesInput[]
    NOT?: GrupoScalarWhereWithAggregatesInput | GrupoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grupo"> | string
    clave?: StringWithAggregatesFilter<"Grupo"> | string
    periodo?: StringWithAggregatesFilter<"Grupo"> | string
    cupoMaximo?: IntWithAggregatesFilter<"Grupo"> | number
    cupoDisponible?: IntWithAggregatesFilter<"Grupo"> | number
    horario?: StringWithAggregatesFilter<"Grupo"> | string
    aula?: StringNullableWithAggregatesFilter<"Grupo"> | string | null
    activo?: BoolWithAggregatesFilter<"Grupo"> | boolean
    materiaId?: StringWithAggregatesFilter<"Grupo"> | string
    profesorId?: StringWithAggregatesFilter<"Grupo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Grupo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Grupo"> | Date | string
  }

  export type InscripcionWhereInput = {
    AND?: InscripcionWhereInput | InscripcionWhereInput[]
    OR?: InscripcionWhereInput[]
    NOT?: InscripcionWhereInput | InscripcionWhereInput[]
    id?: StringFilter<"Inscripcion"> | string
    periodo?: StringFilter<"Inscripcion"> | string
    estatus?: EnumEstatusInscripcionFilter<"Inscripcion"> | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFilter<"Inscripcion"> | Date | string
    estudianteId?: StringFilter<"Inscripcion"> | string
    grupoId?: StringFilter<"Inscripcion"> | string
    createdAt?: DateTimeFilter<"Inscripcion"> | Date | string
    updatedAt?: DateTimeFilter<"Inscripcion"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    grupo?: XOR<GrupoScalarRelationFilter, GrupoWhereInput>
    calificacion?: XOR<CalificacionNullableScalarRelationFilter, CalificacionWhereInput> | null
  }

  export type InscripcionOrderByWithRelationInput = {
    id?: SortOrder
    periodo?: SortOrder
    estatus?: SortOrder
    fechaInscripcion?: SortOrder
    estudianteId?: SortOrder
    grupoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    grupo?: GrupoOrderByWithRelationInput
    calificacion?: CalificacionOrderByWithRelationInput
  }

  export type InscripcionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    estudianteId_grupoId_periodo?: InscripcionEstudianteIdGrupoIdPeriodoCompoundUniqueInput
    AND?: InscripcionWhereInput | InscripcionWhereInput[]
    OR?: InscripcionWhereInput[]
    NOT?: InscripcionWhereInput | InscripcionWhereInput[]
    periodo?: StringFilter<"Inscripcion"> | string
    estatus?: EnumEstatusInscripcionFilter<"Inscripcion"> | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFilter<"Inscripcion"> | Date | string
    estudianteId?: StringFilter<"Inscripcion"> | string
    grupoId?: StringFilter<"Inscripcion"> | string
    createdAt?: DateTimeFilter<"Inscripcion"> | Date | string
    updatedAt?: DateTimeFilter<"Inscripcion"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    grupo?: XOR<GrupoScalarRelationFilter, GrupoWhereInput>
    calificacion?: XOR<CalificacionNullableScalarRelationFilter, CalificacionWhereInput> | null
  }, "id" | "estudianteId_grupoId_periodo">

  export type InscripcionOrderByWithAggregationInput = {
    id?: SortOrder
    periodo?: SortOrder
    estatus?: SortOrder
    fechaInscripcion?: SortOrder
    estudianteId?: SortOrder
    grupoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InscripcionCountOrderByAggregateInput
    _max?: InscripcionMaxOrderByAggregateInput
    _min?: InscripcionMinOrderByAggregateInput
  }

  export type InscripcionScalarWhereWithAggregatesInput = {
    AND?: InscripcionScalarWhereWithAggregatesInput | InscripcionScalarWhereWithAggregatesInput[]
    OR?: InscripcionScalarWhereWithAggregatesInput[]
    NOT?: InscripcionScalarWhereWithAggregatesInput | InscripcionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inscripcion"> | string
    periodo?: StringWithAggregatesFilter<"Inscripcion"> | string
    estatus?: EnumEstatusInscripcionWithAggregatesFilter<"Inscripcion"> | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeWithAggregatesFilter<"Inscripcion"> | Date | string
    estudianteId?: StringWithAggregatesFilter<"Inscripcion"> | string
    grupoId?: StringWithAggregatesFilter<"Inscripcion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inscripcion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inscripcion"> | Date | string
  }

  export type CalificacionWhereInput = {
    AND?: CalificacionWhereInput | CalificacionWhereInput[]
    OR?: CalificacionWhereInput[]
    NOT?: CalificacionWhereInput | CalificacionWhereInput[]
    id?: StringFilter<"Calificacion"> | string
    calificacion?: FloatFilter<"Calificacion"> | number
    estatus?: StringFilter<"Calificacion"> | string
    observaciones?: StringNullableFilter<"Calificacion"> | string | null
    estudianteId?: StringFilter<"Calificacion"> | string
    materiaId?: StringFilter<"Calificacion"> | string
    inscripcionId?: StringFilter<"Calificacion"> | string
    createdAt?: DateTimeFilter<"Calificacion"> | Date | string
    updatedAt?: DateTimeFilter<"Calificacion"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    inscripcion?: XOR<InscripcionScalarRelationFilter, InscripcionWhereInput>
  }

  export type CalificacionOrderByWithRelationInput = {
    id?: SortOrder
    calificacion?: SortOrder
    estatus?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    materiaId?: SortOrder
    inscripcionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    materia?: MateriaOrderByWithRelationInput
    inscripcion?: InscripcionOrderByWithRelationInput
  }

  export type CalificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inscripcionId?: string
    AND?: CalificacionWhereInput | CalificacionWhereInput[]
    OR?: CalificacionWhereInput[]
    NOT?: CalificacionWhereInput | CalificacionWhereInput[]
    calificacion?: FloatFilter<"Calificacion"> | number
    estatus?: StringFilter<"Calificacion"> | string
    observaciones?: StringNullableFilter<"Calificacion"> | string | null
    estudianteId?: StringFilter<"Calificacion"> | string
    materiaId?: StringFilter<"Calificacion"> | string
    createdAt?: DateTimeFilter<"Calificacion"> | Date | string
    updatedAt?: DateTimeFilter<"Calificacion"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    inscripcion?: XOR<InscripcionScalarRelationFilter, InscripcionWhereInput>
  }, "id" | "inscripcionId">

  export type CalificacionOrderByWithAggregationInput = {
    id?: SortOrder
    calificacion?: SortOrder
    estatus?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    materiaId?: SortOrder
    inscripcionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalificacionCountOrderByAggregateInput
    _avg?: CalificacionAvgOrderByAggregateInput
    _max?: CalificacionMaxOrderByAggregateInput
    _min?: CalificacionMinOrderByAggregateInput
    _sum?: CalificacionSumOrderByAggregateInput
  }

  export type CalificacionScalarWhereWithAggregatesInput = {
    AND?: CalificacionScalarWhereWithAggregatesInput | CalificacionScalarWhereWithAggregatesInput[]
    OR?: CalificacionScalarWhereWithAggregatesInput[]
    NOT?: CalificacionScalarWhereWithAggregatesInput | CalificacionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Calificacion"> | string
    calificacion?: FloatWithAggregatesFilter<"Calificacion"> | number
    estatus?: StringWithAggregatesFilter<"Calificacion"> | string
    observaciones?: StringNullableWithAggregatesFilter<"Calificacion"> | string | null
    estudianteId?: StringWithAggregatesFilter<"Calificacion"> | string
    materiaId?: StringWithAggregatesFilter<"Calificacion"> | string
    inscripcionId?: StringWithAggregatesFilter<"Calificacion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Calificacion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Calificacion"> | Date | string
  }

  export type ProfesorWhereInput = {
    AND?: ProfesorWhereInput | ProfesorWhereInput[]
    OR?: ProfesorWhereInput[]
    NOT?: ProfesorWhereInput | ProfesorWhereInput[]
    id?: StringFilter<"Profesor"> | string
    numeroEmpleado?: StringFilter<"Profesor"> | string
    especialidad?: StringNullableFilter<"Profesor"> | string | null
    grado?: StringNullableFilter<"Profesor"> | string | null
    departamento?: StringNullableFilter<"Profesor"> | string | null
    activo?: BoolFilter<"Profesor"> | boolean
    usuarioId?: StringFilter<"Profesor"> | string
    createdAt?: DateTimeFilter<"Profesor"> | Date | string
    updatedAt?: DateTimeFilter<"Profesor"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    grupos?: GrupoListRelationFilter
  }

  export type ProfesorOrderByWithRelationInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    especialidad?: SortOrderInput | SortOrder
    grado?: SortOrderInput | SortOrder
    departamento?: SortOrderInput | SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    grupos?: GrupoOrderByRelationAggregateInput
  }

  export type ProfesorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroEmpleado?: string
    usuarioId?: string
    AND?: ProfesorWhereInput | ProfesorWhereInput[]
    OR?: ProfesorWhereInput[]
    NOT?: ProfesorWhereInput | ProfesorWhereInput[]
    especialidad?: StringNullableFilter<"Profesor"> | string | null
    grado?: StringNullableFilter<"Profesor"> | string | null
    departamento?: StringNullableFilter<"Profesor"> | string | null
    activo?: BoolFilter<"Profesor"> | boolean
    createdAt?: DateTimeFilter<"Profesor"> | Date | string
    updatedAt?: DateTimeFilter<"Profesor"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    grupos?: GrupoListRelationFilter
  }, "id" | "numeroEmpleado" | "usuarioId">

  export type ProfesorOrderByWithAggregationInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    especialidad?: SortOrderInput | SortOrder
    grado?: SortOrderInput | SortOrder
    departamento?: SortOrderInput | SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfesorCountOrderByAggregateInput
    _max?: ProfesorMaxOrderByAggregateInput
    _min?: ProfesorMinOrderByAggregateInput
  }

  export type ProfesorScalarWhereWithAggregatesInput = {
    AND?: ProfesorScalarWhereWithAggregatesInput | ProfesorScalarWhereWithAggregatesInput[]
    OR?: ProfesorScalarWhereWithAggregatesInput[]
    NOT?: ProfesorScalarWhereWithAggregatesInput | ProfesorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profesor"> | string
    numeroEmpleado?: StringWithAggregatesFilter<"Profesor"> | string
    especialidad?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    grado?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    departamento?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    activo?: BoolWithAggregatesFilter<"Profesor"> | boolean
    usuarioId?: StringWithAggregatesFilter<"Profesor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Profesor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profesor"> | Date | string
  }

  export type AdministradorWhereInput = {
    AND?: AdministradorWhereInput | AdministradorWhereInput[]
    OR?: AdministradorWhereInput[]
    NOT?: AdministradorWhereInput | AdministradorWhereInput[]
    id?: StringFilter<"Administrador"> | string
    numeroEmpleado?: StringFilter<"Administrador"> | string
    area?: StringNullableFilter<"Administrador"> | string | null
    cargo?: StringNullableFilter<"Administrador"> | string | null
    activo?: BoolFilter<"Administrador"> | boolean
    usuarioId?: StringFilter<"Administrador"> | string
    createdAt?: DateTimeFilter<"Administrador"> | Date | string
    updatedAt?: DateTimeFilter<"Administrador"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type AdministradorOrderByWithRelationInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    area?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type AdministradorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroEmpleado?: string
    usuarioId?: string
    AND?: AdministradorWhereInput | AdministradorWhereInput[]
    OR?: AdministradorWhereInput[]
    NOT?: AdministradorWhereInput | AdministradorWhereInput[]
    area?: StringNullableFilter<"Administrador"> | string | null
    cargo?: StringNullableFilter<"Administrador"> | string | null
    activo?: BoolFilter<"Administrador"> | boolean
    createdAt?: DateTimeFilter<"Administrador"> | Date | string
    updatedAt?: DateTimeFilter<"Administrador"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "numeroEmpleado" | "usuarioId">

  export type AdministradorOrderByWithAggregationInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    area?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdministradorCountOrderByAggregateInput
    _max?: AdministradorMaxOrderByAggregateInput
    _min?: AdministradorMinOrderByAggregateInput
  }

  export type AdministradorScalarWhereWithAggregatesInput = {
    AND?: AdministradorScalarWhereWithAggregatesInput | AdministradorScalarWhereWithAggregatesInput[]
    OR?: AdministradorScalarWhereWithAggregatesInput[]
    NOT?: AdministradorScalarWhereWithAggregatesInput | AdministradorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Administrador"> | string
    numeroEmpleado?: StringWithAggregatesFilter<"Administrador"> | string
    area?: StringNullableWithAggregatesFilter<"Administrador"> | string | null
    cargo?: StringNullableWithAggregatesFilter<"Administrador"> | string | null
    activo?: BoolWithAggregatesFilter<"Administrador"> | boolean
    usuarioId?: StringWithAggregatesFilter<"Administrador"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Administrador"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Administrador"> | Date | string
  }

  export type DocumentoWhereInput = {
    AND?: DocumentoWhereInput | DocumentoWhereInput[]
    OR?: DocumentoWhereInput[]
    NOT?: DocumentoWhereInput | DocumentoWhereInput[]
    id?: StringFilter<"Documento"> | string
    folio?: StringFilter<"Documento"> | string
    tipo?: EnumTipoDocumentoFilter<"Documento"> | $Enums.TipoDocumento
    titulo?: StringFilter<"Documento"> | string
    descripcion?: StringNullableFilter<"Documento"> | string | null
    rutaArchivo?: StringFilter<"Documento"> | string
    rutaArchivoFirmado?: StringNullableFilter<"Documento"> | string | null
    hashArchivo?: StringFilter<"Documento"> | string
    tamanoBytes?: IntFilter<"Documento"> | number
    mimeType?: StringFilter<"Documento"> | string
    estatus?: EnumEstatusDocumentoFilter<"Documento"> | $Enums.EstatusDocumento
    fechaEmision?: DateTimeNullableFilter<"Documento"> | Date | string | null
    fechaVencimiento?: DateTimeNullableFilter<"Documento"> | Date | string | null
    validado?: BoolFilter<"Documento"> | boolean
    firmado?: BoolFilter<"Documento"> | boolean
    cadenaBlockchain?: StringNullableFilter<"Documento"> | string | null
    qrCode?: StringNullableFilter<"Documento"> | string | null
    creadoPorId?: StringFilter<"Documento"> | string
    createdAt?: DateTimeFilter<"Documento"> | Date | string
    updatedAt?: DateTimeFilter<"Documento"> | Date | string
    creadoPor?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    documentosEstudiante?: DocumentoEstudianteListRelationFilter
  }

  export type DocumentoOrderByWithRelationInput = {
    id?: SortOrder
    folio?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    rutaArchivo?: SortOrder
    rutaArchivoFirmado?: SortOrderInput | SortOrder
    hashArchivo?: SortOrder
    tamanoBytes?: SortOrder
    mimeType?: SortOrder
    estatus?: SortOrder
    fechaEmision?: SortOrderInput | SortOrder
    fechaVencimiento?: SortOrderInput | SortOrder
    validado?: SortOrder
    firmado?: SortOrder
    cadenaBlockchain?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creadoPor?: UsuarioOrderByWithRelationInput
    documentosEstudiante?: DocumentoEstudianteOrderByRelationAggregateInput
  }

  export type DocumentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    folio?: string
    AND?: DocumentoWhereInput | DocumentoWhereInput[]
    OR?: DocumentoWhereInput[]
    NOT?: DocumentoWhereInput | DocumentoWhereInput[]
    tipo?: EnumTipoDocumentoFilter<"Documento"> | $Enums.TipoDocumento
    titulo?: StringFilter<"Documento"> | string
    descripcion?: StringNullableFilter<"Documento"> | string | null
    rutaArchivo?: StringFilter<"Documento"> | string
    rutaArchivoFirmado?: StringNullableFilter<"Documento"> | string | null
    hashArchivo?: StringFilter<"Documento"> | string
    tamanoBytes?: IntFilter<"Documento"> | number
    mimeType?: StringFilter<"Documento"> | string
    estatus?: EnumEstatusDocumentoFilter<"Documento"> | $Enums.EstatusDocumento
    fechaEmision?: DateTimeNullableFilter<"Documento"> | Date | string | null
    fechaVencimiento?: DateTimeNullableFilter<"Documento"> | Date | string | null
    validado?: BoolFilter<"Documento"> | boolean
    firmado?: BoolFilter<"Documento"> | boolean
    cadenaBlockchain?: StringNullableFilter<"Documento"> | string | null
    qrCode?: StringNullableFilter<"Documento"> | string | null
    creadoPorId?: StringFilter<"Documento"> | string
    createdAt?: DateTimeFilter<"Documento"> | Date | string
    updatedAt?: DateTimeFilter<"Documento"> | Date | string
    creadoPor?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    documentosEstudiante?: DocumentoEstudianteListRelationFilter
  }, "id" | "folio">

  export type DocumentoOrderByWithAggregationInput = {
    id?: SortOrder
    folio?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    rutaArchivo?: SortOrder
    rutaArchivoFirmado?: SortOrderInput | SortOrder
    hashArchivo?: SortOrder
    tamanoBytes?: SortOrder
    mimeType?: SortOrder
    estatus?: SortOrder
    fechaEmision?: SortOrderInput | SortOrder
    fechaVencimiento?: SortOrderInput | SortOrder
    validado?: SortOrder
    firmado?: SortOrder
    cadenaBlockchain?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentoCountOrderByAggregateInput
    _avg?: DocumentoAvgOrderByAggregateInput
    _max?: DocumentoMaxOrderByAggregateInput
    _min?: DocumentoMinOrderByAggregateInput
    _sum?: DocumentoSumOrderByAggregateInput
  }

  export type DocumentoScalarWhereWithAggregatesInput = {
    AND?: DocumentoScalarWhereWithAggregatesInput | DocumentoScalarWhereWithAggregatesInput[]
    OR?: DocumentoScalarWhereWithAggregatesInput[]
    NOT?: DocumentoScalarWhereWithAggregatesInput | DocumentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Documento"> | string
    folio?: StringWithAggregatesFilter<"Documento"> | string
    tipo?: EnumTipoDocumentoWithAggregatesFilter<"Documento"> | $Enums.TipoDocumento
    titulo?: StringWithAggregatesFilter<"Documento"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Documento"> | string | null
    rutaArchivo?: StringWithAggregatesFilter<"Documento"> | string
    rutaArchivoFirmado?: StringNullableWithAggregatesFilter<"Documento"> | string | null
    hashArchivo?: StringWithAggregatesFilter<"Documento"> | string
    tamanoBytes?: IntWithAggregatesFilter<"Documento"> | number
    mimeType?: StringWithAggregatesFilter<"Documento"> | string
    estatus?: EnumEstatusDocumentoWithAggregatesFilter<"Documento"> | $Enums.EstatusDocumento
    fechaEmision?: DateTimeNullableWithAggregatesFilter<"Documento"> | Date | string | null
    fechaVencimiento?: DateTimeNullableWithAggregatesFilter<"Documento"> | Date | string | null
    validado?: BoolWithAggregatesFilter<"Documento"> | boolean
    firmado?: BoolWithAggregatesFilter<"Documento"> | boolean
    cadenaBlockchain?: StringNullableWithAggregatesFilter<"Documento"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Documento"> | string | null
    creadoPorId?: StringWithAggregatesFilter<"Documento"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Documento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Documento"> | Date | string
  }

  export type DocumentoEstudianteWhereInput = {
    AND?: DocumentoEstudianteWhereInput | DocumentoEstudianteWhereInput[]
    OR?: DocumentoEstudianteWhereInput[]
    NOT?: DocumentoEstudianteWhereInput | DocumentoEstudianteWhereInput[]
    id?: StringFilter<"DocumentoEstudiante"> | string
    observaciones?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    motivoRechazo?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    revisadoPor?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    fechaRevision?: DateTimeNullableFilter<"DocumentoEstudiante"> | Date | string | null
    escaneoVirus?: BoolFilter<"DocumentoEstudiante"> | boolean
    virusDetectado?: BoolFilter<"DocumentoEstudiante"> | boolean
    nombreVirusDetectado?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    documentoId?: StringFilter<"DocumentoEstudiante"> | string
    estudianteId?: StringFilter<"DocumentoEstudiante"> | string
    createdAt?: DateTimeFilter<"DocumentoEstudiante"> | Date | string
    documento?: XOR<DocumentoScalarRelationFilter, DocumentoWhereInput>
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
  }

  export type DocumentoEstudianteOrderByWithRelationInput = {
    id?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    motivoRechazo?: SortOrderInput | SortOrder
    revisadoPor?: SortOrderInput | SortOrder
    fechaRevision?: SortOrderInput | SortOrder
    escaneoVirus?: SortOrder
    virusDetectado?: SortOrder
    nombreVirusDetectado?: SortOrderInput | SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
    documento?: DocumentoOrderByWithRelationInput
    estudiante?: EstudianteOrderByWithRelationInput
  }

  export type DocumentoEstudianteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentoId_estudianteId?: DocumentoEstudianteDocumentoIdEstudianteIdCompoundUniqueInput
    AND?: DocumentoEstudianteWhereInput | DocumentoEstudianteWhereInput[]
    OR?: DocumentoEstudianteWhereInput[]
    NOT?: DocumentoEstudianteWhereInput | DocumentoEstudianteWhereInput[]
    observaciones?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    motivoRechazo?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    revisadoPor?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    fechaRevision?: DateTimeNullableFilter<"DocumentoEstudiante"> | Date | string | null
    escaneoVirus?: BoolFilter<"DocumentoEstudiante"> | boolean
    virusDetectado?: BoolFilter<"DocumentoEstudiante"> | boolean
    nombreVirusDetectado?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    documentoId?: StringFilter<"DocumentoEstudiante"> | string
    estudianteId?: StringFilter<"DocumentoEstudiante"> | string
    createdAt?: DateTimeFilter<"DocumentoEstudiante"> | Date | string
    documento?: XOR<DocumentoScalarRelationFilter, DocumentoWhereInput>
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
  }, "id" | "documentoId_estudianteId">

  export type DocumentoEstudianteOrderByWithAggregationInput = {
    id?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    motivoRechazo?: SortOrderInput | SortOrder
    revisadoPor?: SortOrderInput | SortOrder
    fechaRevision?: SortOrderInput | SortOrder
    escaneoVirus?: SortOrder
    virusDetectado?: SortOrder
    nombreVirusDetectado?: SortOrderInput | SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentoEstudianteCountOrderByAggregateInput
    _max?: DocumentoEstudianteMaxOrderByAggregateInput
    _min?: DocumentoEstudianteMinOrderByAggregateInput
  }

  export type DocumentoEstudianteScalarWhereWithAggregatesInput = {
    AND?: DocumentoEstudianteScalarWhereWithAggregatesInput | DocumentoEstudianteScalarWhereWithAggregatesInput[]
    OR?: DocumentoEstudianteScalarWhereWithAggregatesInput[]
    NOT?: DocumentoEstudianteScalarWhereWithAggregatesInput | DocumentoEstudianteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentoEstudiante"> | string
    observaciones?: StringNullableWithAggregatesFilter<"DocumentoEstudiante"> | string | null
    motivoRechazo?: StringNullableWithAggregatesFilter<"DocumentoEstudiante"> | string | null
    revisadoPor?: StringNullableWithAggregatesFilter<"DocumentoEstudiante"> | string | null
    fechaRevision?: DateTimeNullableWithAggregatesFilter<"DocumentoEstudiante"> | Date | string | null
    escaneoVirus?: BoolWithAggregatesFilter<"DocumentoEstudiante"> | boolean
    virusDetectado?: BoolWithAggregatesFilter<"DocumentoEstudiante"> | boolean
    nombreVirusDetectado?: StringNullableWithAggregatesFilter<"DocumentoEstudiante"> | string | null
    documentoId?: StringWithAggregatesFilter<"DocumentoEstudiante"> | string
    estudianteId?: StringWithAggregatesFilter<"DocumentoEstudiante"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentoEstudiante"> | Date | string
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: StringFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionFilter<"Notificacion"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    documentoId?: StringNullableFilter<"Notificacion"> | string | null
    estudianteId?: StringFilter<"Notificacion"> | string
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    documentoId?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    tipo?: EnumTipoNotificacionFilter<"Notificacion"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    documentoId?: StringNullableFilter<"Notificacion"> | string | null
    estudianteId?: StringFilter<"Notificacion"> | string
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    documentoId?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionWithAggregatesFilter<"Notificacion"> | $Enums.TipoNotificacion
    titulo?: StringWithAggregatesFilter<"Notificacion"> | string
    mensaje?: StringWithAggregatesFilter<"Notificacion"> | string
    leida?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    documentoId?: StringNullableWithAggregatesFilter<"Notificacion"> | string | null
    estudianteId?: StringWithAggregatesFilter<"Notificacion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
  }

  export type ActividadUsuarioWhereInput = {
    AND?: ActividadUsuarioWhereInput | ActividadUsuarioWhereInput[]
    OR?: ActividadUsuarioWhereInput[]
    NOT?: ActividadUsuarioWhereInput | ActividadUsuarioWhereInput[]
    id?: StringFilter<"ActividadUsuario"> | string
    accion?: StringFilter<"ActividadUsuario"> | string
    entidad?: StringNullableFilter<"ActividadUsuario"> | string | null
    entidadId?: StringNullableFilter<"ActividadUsuario"> | string | null
    descripcion?: StringNullableFilter<"ActividadUsuario"> | string | null
    ipAddress?: StringNullableFilter<"ActividadUsuario"> | string | null
    userAgent?: StringNullableFilter<"ActividadUsuario"> | string | null
    usuarioId?: StringFilter<"ActividadUsuario"> | string
    createdAt?: DateTimeFilter<"ActividadUsuario"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type ActividadUsuarioOrderByWithRelationInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrderInput | SortOrder
    entidadId?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ActividadUsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActividadUsuarioWhereInput | ActividadUsuarioWhereInput[]
    OR?: ActividadUsuarioWhereInput[]
    NOT?: ActividadUsuarioWhereInput | ActividadUsuarioWhereInput[]
    accion?: StringFilter<"ActividadUsuario"> | string
    entidad?: StringNullableFilter<"ActividadUsuario"> | string | null
    entidadId?: StringNullableFilter<"ActividadUsuario"> | string | null
    descripcion?: StringNullableFilter<"ActividadUsuario"> | string | null
    ipAddress?: StringNullableFilter<"ActividadUsuario"> | string | null
    userAgent?: StringNullableFilter<"ActividadUsuario"> | string | null
    usuarioId?: StringFilter<"ActividadUsuario"> | string
    createdAt?: DateTimeFilter<"ActividadUsuario"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ActividadUsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrderInput | SortOrder
    entidadId?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    _count?: ActividadUsuarioCountOrderByAggregateInput
    _max?: ActividadUsuarioMaxOrderByAggregateInput
    _min?: ActividadUsuarioMinOrderByAggregateInput
  }

  export type ActividadUsuarioScalarWhereWithAggregatesInput = {
    AND?: ActividadUsuarioScalarWhereWithAggregatesInput | ActividadUsuarioScalarWhereWithAggregatesInput[]
    OR?: ActividadUsuarioScalarWhereWithAggregatesInput[]
    NOT?: ActividadUsuarioScalarWhereWithAggregatesInput | ActividadUsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActividadUsuario"> | string
    accion?: StringWithAggregatesFilter<"ActividadUsuario"> | string
    entidad?: StringNullableWithAggregatesFilter<"ActividadUsuario"> | string | null
    entidadId?: StringNullableWithAggregatesFilter<"ActividadUsuario"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"ActividadUsuario"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ActividadUsuario"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActividadUsuario"> | string | null
    usuarioId?: StringWithAggregatesFilter<"ActividadUsuario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ActividadUsuario"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorUncheckedCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenSesionCreateInput = {
    id?: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date | string
    revocado?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutTokensInput
  }

  export type TokenSesionUncheckedCreateInput = {
    id?: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date | string
    revocado?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    usuarioId: string
    createdAt?: Date | string
  }

  export type TokenSesionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokenSesionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenSesionCreateManyInput = {
    id?: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date | string
    revocado?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    usuarioId: string
    createdAt?: Date | string
  }

  export type TokenSesionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenSesionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    carrera?: CarreraCreateNestedOneWithoutEstudiantesInput
    inscripciones?: InscripcionCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    carrera?: CarreraUpdateOneWithoutEstudiantesNestedInput
    inscripciones?: InscripcionUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteCreateManyInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EstudianteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarreraCreateInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiantes?: EstudianteCreateNestedManyWithoutCarreraInput
    materias?: MateriaCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiantes?: EstudianteUncheckedCreateNestedManyWithoutCarreraInput
    materias?: MateriaUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: EstudianteUpdateManyWithoutCarreraNestedInput
    materias?: MateriaUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: EstudianteUncheckedUpdateManyWithoutCarreraNestedInput
    materias?: MateriaUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraCreateManyInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarreraUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarreraUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriaCreateInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    carrera: CarreraCreateNestedOneWithoutMateriasInput
    grupos?: GrupoCreateNestedManyWithoutMateriaInput
    calificaciones?: CalificacionCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    carreraId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoUncheckedCreateNestedManyWithoutMateriaInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carrera?: CarreraUpdateOneRequiredWithoutMateriasNestedInput
    grupos?: GrupoUpdateManyWithoutMateriaNestedInput
    calificaciones?: CalificacionUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    carreraId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUncheckedUpdateManyWithoutMateriaNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaCreateManyInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    carreraId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    carreraId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoCreateInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materia: MateriaCreateNestedOneWithoutGruposInput
    profesor: ProfesorCreateNestedOneWithoutGruposInput
    inscripciones?: InscripcionCreateNestedManyWithoutGrupoInput
  }

  export type GrupoUncheckedCreateInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    materiaId: string
    profesorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type GrupoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materia?: MateriaUpdateOneRequiredWithoutGruposNestedInput
    profesor?: ProfesorUpdateOneRequiredWithoutGruposNestedInput
    inscripciones?: InscripcionUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    materiaId?: StringFieldUpdateOperationsInput | string
    profesorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoCreateManyInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    materiaId: string
    profesorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GrupoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    materiaId?: StringFieldUpdateOperationsInput | string
    profesorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscripcionCreateInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutInscripcionesInput
    grupo: GrupoCreateNestedOneWithoutInscripcionesInput
    calificacion?: CalificacionCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    estudianteId: string
    grupoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calificacion?: CalificacionUncheckedCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutInscripcionesNestedInput
    grupo?: GrupoUpdateOneRequiredWithoutInscripcionesNestedInput
    calificacion?: CalificacionUpdateOneWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    grupoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calificacion?: CalificacionUncheckedUpdateOneWithoutInscripcionNestedInput
  }

  export type InscripcionCreateManyInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    estudianteId: string
    grupoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscripcionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscripcionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    grupoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionCreateInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutCalificacionesInput
    materia: MateriaCreateNestedOneWithoutCalificacionesInput
    inscripcion: InscripcionCreateNestedOneWithoutCalificacionInput
  }

  export type CalificacionUncheckedCreateInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    estudianteId: string
    materiaId: string
    inscripcionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutCalificacionesNestedInput
    materia?: MateriaUpdateOneRequiredWithoutCalificacionesNestedInput
    inscripcion?: InscripcionUpdateOneRequiredWithoutCalificacionNestedInput
  }

  export type CalificacionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    materiaId?: StringFieldUpdateOperationsInput | string
    inscripcionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionCreateManyInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    estudianteId: string
    materiaId: string
    inscripcionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    materiaId?: StringFieldUpdateOperationsInput | string
    inscripcionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesorCreateInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutProfesorInput
    grupos?: GrupoCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutProfesorNestedInput
    grupos?: GrupoUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorCreateManyInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfesorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministradorCreateInput = {
    id?: string
    numeroEmpleado: string
    area?: string | null
    cargo?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutAdministradorInput
  }

  export type AdministradorUncheckedCreateInput = {
    id?: string
    numeroEmpleado: string
    area?: string | null
    cargo?: string | null
    activo?: boolean
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministradorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutAdministradorNestedInput
  }

  export type AdministradorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministradorCreateManyInput = {
    id?: string
    numeroEmpleado: string
    area?: string | null
    cargo?: string | null
    activo?: boolean
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministradorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministradorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoCreateInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creadoPor: UsuarioCreateNestedOneWithoutDocumentosCreadosInput
    documentosEstudiante?: DocumentoEstudianteCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    creadoPorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentosEstudiante?: DocumentoEstudianteUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCreadosNestedInput
    documentosEstudiante?: DocumentoEstudianteUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    creadoPorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentosEstudiante?: DocumentoEstudianteUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoCreateManyInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    creadoPorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    creadoPorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteCreateInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    createdAt?: Date | string
    documento: DocumentoCreateNestedOneWithoutDocumentosEstudianteInput
    estudiante: EstudianteCreateNestedOneWithoutDocumentosInput
  }

  export type DocumentoEstudianteUncheckedCreateInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    documentoId: string
    estudianteId: string
    createdAt?: Date | string
  }

  export type DocumentoEstudianteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documento?: DocumentoUpdateOneRequiredWithoutDocumentosEstudianteNestedInput
    estudiante?: EstudianteUpdateOneRequiredWithoutDocumentosNestedInput
  }

  export type DocumentoEstudianteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    documentoId?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteCreateManyInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    documentoId: string
    estudianteId: string
    createdAt?: Date | string
  }

  export type DocumentoEstudianteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    documentoId?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateInput = {
    id?: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida?: boolean
    documentoId?: string | null
    createdAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutNotificacionesInput
  }

  export type NotificacionUncheckedCreateInput = {
    id?: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida?: boolean
    documentoId?: string | null
    estudianteId: string
    createdAt?: Date | string
  }

  export type NotificacionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutNotificacionesNestedInput
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateManyInput = {
    id?: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida?: boolean
    documentoId?: string | null
    estudianteId: string
    createdAt?: Date | string
  }

  export type NotificacionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActividadUsuarioCreateInput = {
    id?: string
    accion: string
    entidad?: string | null
    entidadId?: string | null
    descripcion?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutActividadesInput
  }

  export type ActividadUsuarioUncheckedCreateInput = {
    id?: string
    accion: string
    entidad?: string | null
    entidadId?: string | null
    descripcion?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    usuarioId: string
    createdAt?: Date | string
  }

  export type ActividadUsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutActividadesNestedInput
  }

  export type ActividadUsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActividadUsuarioCreateManyInput = {
    id?: string
    accion: string
    entidad?: string | null
    entidadId?: string | null
    descripcion?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    usuarioId: string
    createdAt?: Date | string
  }

  export type ActividadUsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActividadUsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EstudianteNullableScalarRelationFilter = {
    is?: EstudianteWhereInput | null
    isNot?: EstudianteWhereInput | null
  }

  export type ProfesorNullableScalarRelationFilter = {
    is?: ProfesorWhereInput | null
    isNot?: ProfesorWhereInput | null
  }

  export type AdministradorNullableScalarRelationFilter = {
    is?: AdministradorWhereInput | null
    isNot?: AdministradorWhereInput | null
  }

  export type TokenSesionListRelationFilter = {
    every?: TokenSesionWhereInput
    some?: TokenSesionWhereInput
    none?: TokenSesionWhereInput
  }

  export type ActividadUsuarioListRelationFilter = {
    every?: ActividadUsuarioWhereInput
    some?: ActividadUsuarioWhereInput
    none?: ActividadUsuarioWhereInput
  }

  export type DocumentoListRelationFilter = {
    every?: DocumentoWhereInput
    some?: DocumentoWhereInput
    none?: DocumentoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TokenSesionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActividadUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    apellidoPaterno?: SortOrder
    apellidoMaterno?: SortOrder
    telefono?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    emailVerificado?: SortOrder
    primerLogin?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrder
    ultimoAcceso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    intentosFallidos?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    apellidoPaterno?: SortOrder
    apellidoMaterno?: SortOrder
    telefono?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    emailVerificado?: SortOrder
    primerLogin?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrder
    ultimoAcceso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    apellidoPaterno?: SortOrder
    apellidoMaterno?: SortOrder
    telefono?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    emailVerificado?: SortOrder
    primerLogin?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrder
    ultimoAcceso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    intentosFallidos?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTipoTokenFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoToken | EnumTipoTokenFieldRefInput<$PrismaModel>
    in?: $Enums.TipoToken[]
    notIn?: $Enums.TipoToken[]
    not?: NestedEnumTipoTokenFilter<$PrismaModel> | $Enums.TipoToken
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type TokenSesionCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    tipo?: SortOrder
    expiraEn?: SortOrder
    revocado?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenSesionMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    tipo?: SortOrder
    expiraEn?: SortOrder
    revocado?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenSesionMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    tipo?: SortOrder
    expiraEn?: SortOrder
    revocado?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTipoTokenWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoToken | EnumTipoTokenFieldRefInput<$PrismaModel>
    in?: $Enums.TipoToken[]
    notIn?: $Enums.TipoToken[]
    not?: NestedEnumTipoTokenWithAggregatesFilter<$PrismaModel> | $Enums.TipoToken
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoTokenFilter<$PrismaModel>
    _max?: NestedEnumTipoTokenFilter<$PrismaModel>
  }

  export type EnumEstatusEstudianteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusEstudiante | EnumEstatusEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusEstudiante[]
    notIn?: $Enums.EstatusEstudiante[]
    not?: NestedEnumEstatusEstudianteFilter<$PrismaModel> | $Enums.EstatusEstudiante
  }

  export type CarreraNullableScalarRelationFilter = {
    is?: CarreraWhereInput | null
    isNot?: CarreraWhereInput | null
  }

  export type InscripcionListRelationFilter = {
    every?: InscripcionWhereInput
    some?: InscripcionWhereInput
    none?: InscripcionWhereInput
  }

  export type CalificacionListRelationFilter = {
    every?: CalificacionWhereInput
    some?: CalificacionWhereInput
    none?: CalificacionWhereInput
  }

  export type DocumentoEstudianteListRelationFilter = {
    every?: DocumentoEstudianteWhereInput
    some?: DocumentoEstudianteWhereInput
    none?: DocumentoEstudianteWhereInput
  }

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput
    some?: NotificacionWhereInput
    none?: NotificacionWhereInput
  }

  export type InscripcionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentoEstudianteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstudianteCountOrderByAggregateInput = {
    id?: SortOrder
    matricula?: SortOrder
    fechaNacimiento?: SortOrder
    curp?: SortOrder
    nss?: SortOrder
    direccion?: SortOrder
    ciudad?: SortOrder
    estado?: SortOrder
    codigoPostal?: SortOrder
    tutorNombre?: SortOrder
    tutorTelefono?: SortOrder
    tutorEmail?: SortOrder
    estatus?: SortOrder
    fechaIngreso?: SortOrder
    fechaEgreso?: SortOrder
    usuarioId?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EstudianteMaxOrderByAggregateInput = {
    id?: SortOrder
    matricula?: SortOrder
    fechaNacimiento?: SortOrder
    curp?: SortOrder
    nss?: SortOrder
    direccion?: SortOrder
    ciudad?: SortOrder
    estado?: SortOrder
    codigoPostal?: SortOrder
    tutorNombre?: SortOrder
    tutorTelefono?: SortOrder
    tutorEmail?: SortOrder
    estatus?: SortOrder
    fechaIngreso?: SortOrder
    fechaEgreso?: SortOrder
    usuarioId?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EstudianteMinOrderByAggregateInput = {
    id?: SortOrder
    matricula?: SortOrder
    fechaNacimiento?: SortOrder
    curp?: SortOrder
    nss?: SortOrder
    direccion?: SortOrder
    ciudad?: SortOrder
    estado?: SortOrder
    codigoPostal?: SortOrder
    tutorNombre?: SortOrder
    tutorTelefono?: SortOrder
    tutorEmail?: SortOrder
    estatus?: SortOrder
    fechaIngreso?: SortOrder
    fechaEgreso?: SortOrder
    usuarioId?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEstatusEstudianteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusEstudiante | EnumEstatusEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusEstudiante[]
    notIn?: $Enums.EstatusEstudiante[]
    not?: NestedEnumEstatusEstudianteWithAggregatesFilter<$PrismaModel> | $Enums.EstatusEstudiante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstatusEstudianteFilter<$PrismaModel>
    _max?: NestedEnumEstatusEstudianteFilter<$PrismaModel>
  }

  export type EnumModalidadFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[]
    notIn?: $Enums.Modalidad[]
    not?: NestedEnumModalidadFilter<$PrismaModel> | $Enums.Modalidad
  }

  export type EstudianteListRelationFilter = {
    every?: EstudianteWhereInput
    some?: EstudianteWhereInput
    none?: EstudianteWhereInput
  }

  export type MateriaListRelationFilter = {
    every?: MateriaWhereInput
    some?: MateriaWhereInput
    none?: MateriaWhereInput
  }

  export type EstudianteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MateriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarreraCountOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionSemestres?: SortOrder
    creditos?: SortOrder
    modalidad?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarreraAvgOrderByAggregateInput = {
    duracionSemestres?: SortOrder
    creditos?: SortOrder
  }

  export type CarreraMaxOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionSemestres?: SortOrder
    creditos?: SortOrder
    modalidad?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarreraMinOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionSemestres?: SortOrder
    creditos?: SortOrder
    modalidad?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarreraSumOrderByAggregateInput = {
    duracionSemestres?: SortOrder
    creditos?: SortOrder
  }

  export type EnumModalidadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[]
    notIn?: $Enums.Modalidad[]
    not?: NestedEnumModalidadWithAggregatesFilter<$PrismaModel> | $Enums.Modalidad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModalidadFilter<$PrismaModel>
    _max?: NestedEnumModalidadFilter<$PrismaModel>
  }

  export type CarreraScalarRelationFilter = {
    is?: CarreraWhereInput
    isNot?: CarreraWhereInput
  }

  export type GrupoListRelationFilter = {
    every?: GrupoWhereInput
    some?: GrupoWhereInput
    none?: GrupoWhereInput
  }

  export type GrupoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MateriaCountOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
    activo?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MateriaAvgOrderByAggregateInput = {
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
  }

  export type MateriaMaxOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
    activo?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MateriaMinOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
    activo?: SortOrder
    carreraId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MateriaSumOrderByAggregateInput = {
    creditos?: SortOrder
    semestre?: SortOrder
    horasTeoria?: SortOrder
    horasPractica?: SortOrder
  }

  export type MateriaScalarRelationFilter = {
    is?: MateriaWhereInput
    isNot?: MateriaWhereInput
  }

  export type ProfesorScalarRelationFilter = {
    is?: ProfesorWhereInput
    isNot?: ProfesorWhereInput
  }

  export type GrupoCountOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    periodo?: SortOrder
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    activo?: SortOrder
    materiaId?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrupoAvgOrderByAggregateInput = {
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
  }

  export type GrupoMaxOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    periodo?: SortOrder
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    activo?: SortOrder
    materiaId?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrupoMinOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    periodo?: SortOrder
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    activo?: SortOrder
    materiaId?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrupoSumOrderByAggregateInput = {
    cupoMaximo?: SortOrder
    cupoDisponible?: SortOrder
  }

  export type EnumEstatusInscripcionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusInscripcion | EnumEstatusInscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusInscripcion[]
    notIn?: $Enums.EstatusInscripcion[]
    not?: NestedEnumEstatusInscripcionFilter<$PrismaModel> | $Enums.EstatusInscripcion
  }

  export type EstudianteScalarRelationFilter = {
    is?: EstudianteWhereInput
    isNot?: EstudianteWhereInput
  }

  export type GrupoScalarRelationFilter = {
    is?: GrupoWhereInput
    isNot?: GrupoWhereInput
  }

  export type CalificacionNullableScalarRelationFilter = {
    is?: CalificacionWhereInput | null
    isNot?: CalificacionWhereInput | null
  }

  export type InscripcionEstudianteIdGrupoIdPeriodoCompoundUniqueInput = {
    estudianteId: string
    grupoId: string
    periodo: string
  }

  export type InscripcionCountOrderByAggregateInput = {
    id?: SortOrder
    periodo?: SortOrder
    estatus?: SortOrder
    fechaInscripcion?: SortOrder
    estudianteId?: SortOrder
    grupoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InscripcionMaxOrderByAggregateInput = {
    id?: SortOrder
    periodo?: SortOrder
    estatus?: SortOrder
    fechaInscripcion?: SortOrder
    estudianteId?: SortOrder
    grupoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InscripcionMinOrderByAggregateInput = {
    id?: SortOrder
    periodo?: SortOrder
    estatus?: SortOrder
    fechaInscripcion?: SortOrder
    estudianteId?: SortOrder
    grupoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEstatusInscripcionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusInscripcion | EnumEstatusInscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusInscripcion[]
    notIn?: $Enums.EstatusInscripcion[]
    not?: NestedEnumEstatusInscripcionWithAggregatesFilter<$PrismaModel> | $Enums.EstatusInscripcion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstatusInscripcionFilter<$PrismaModel>
    _max?: NestedEnumEstatusInscripcionFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InscripcionScalarRelationFilter = {
    is?: InscripcionWhereInput
    isNot?: InscripcionWhereInput
  }

  export type CalificacionCountOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    estatus?: SortOrder
    observaciones?: SortOrder
    estudianteId?: SortOrder
    materiaId?: SortOrder
    inscripcionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalificacionAvgOrderByAggregateInput = {
    calificacion?: SortOrder
  }

  export type CalificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    estatus?: SortOrder
    observaciones?: SortOrder
    estudianteId?: SortOrder
    materiaId?: SortOrder
    inscripcionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalificacionMinOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    estatus?: SortOrder
    observaciones?: SortOrder
    estudianteId?: SortOrder
    materiaId?: SortOrder
    inscripcionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalificacionSumOrderByAggregateInput = {
    calificacion?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProfesorCountOrderByAggregateInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    especialidad?: SortOrder
    grado?: SortOrder
    departamento?: SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfesorMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    especialidad?: SortOrder
    grado?: SortOrder
    departamento?: SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfesorMinOrderByAggregateInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    especialidad?: SortOrder
    grado?: SortOrder
    departamento?: SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministradorCountOrderByAggregateInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    area?: SortOrder
    cargo?: SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministradorMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    area?: SortOrder
    cargo?: SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministradorMinOrderByAggregateInput = {
    id?: SortOrder
    numeroEmpleado?: SortOrder
    area?: SortOrder
    cargo?: SortOrder
    activo?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTipoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[]
    notIn?: $Enums.TipoDocumento[]
    not?: NestedEnumTipoDocumentoFilter<$PrismaModel> | $Enums.TipoDocumento
  }

  export type EnumEstatusDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusDocumento | EnumEstatusDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusDocumento[]
    notIn?: $Enums.EstatusDocumento[]
    not?: NestedEnumEstatusDocumentoFilter<$PrismaModel> | $Enums.EstatusDocumento
  }

  export type DocumentoCountOrderByAggregateInput = {
    id?: SortOrder
    folio?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    rutaArchivo?: SortOrder
    rutaArchivoFirmado?: SortOrder
    hashArchivo?: SortOrder
    tamanoBytes?: SortOrder
    mimeType?: SortOrder
    estatus?: SortOrder
    fechaEmision?: SortOrder
    fechaVencimiento?: SortOrder
    validado?: SortOrder
    firmado?: SortOrder
    cadenaBlockchain?: SortOrder
    qrCode?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentoAvgOrderByAggregateInput = {
    tamanoBytes?: SortOrder
  }

  export type DocumentoMaxOrderByAggregateInput = {
    id?: SortOrder
    folio?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    rutaArchivo?: SortOrder
    rutaArchivoFirmado?: SortOrder
    hashArchivo?: SortOrder
    tamanoBytes?: SortOrder
    mimeType?: SortOrder
    estatus?: SortOrder
    fechaEmision?: SortOrder
    fechaVencimiento?: SortOrder
    validado?: SortOrder
    firmado?: SortOrder
    cadenaBlockchain?: SortOrder
    qrCode?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentoMinOrderByAggregateInput = {
    id?: SortOrder
    folio?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    rutaArchivo?: SortOrder
    rutaArchivoFirmado?: SortOrder
    hashArchivo?: SortOrder
    tamanoBytes?: SortOrder
    mimeType?: SortOrder
    estatus?: SortOrder
    fechaEmision?: SortOrder
    fechaVencimiento?: SortOrder
    validado?: SortOrder
    firmado?: SortOrder
    cadenaBlockchain?: SortOrder
    qrCode?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentoSumOrderByAggregateInput = {
    tamanoBytes?: SortOrder
  }

  export type EnumTipoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[]
    notIn?: $Enums.TipoDocumento[]
    not?: NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.TipoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumTipoDocumentoFilter<$PrismaModel>
  }

  export type EnumEstatusDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusDocumento | EnumEstatusDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusDocumento[]
    notIn?: $Enums.EstatusDocumento[]
    not?: NestedEnumEstatusDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.EstatusDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstatusDocumentoFilter<$PrismaModel>
    _max?: NestedEnumEstatusDocumentoFilter<$PrismaModel>
  }

  export type DocumentoScalarRelationFilter = {
    is?: DocumentoWhereInput
    isNot?: DocumentoWhereInput
  }

  export type DocumentoEstudianteDocumentoIdEstudianteIdCompoundUniqueInput = {
    documentoId: string
    estudianteId: string
  }

  export type DocumentoEstudianteCountOrderByAggregateInput = {
    id?: SortOrder
    observaciones?: SortOrder
    motivoRechazo?: SortOrder
    revisadoPor?: SortOrder
    fechaRevision?: SortOrder
    escaneoVirus?: SortOrder
    virusDetectado?: SortOrder
    nombreVirusDetectado?: SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentoEstudianteMaxOrderByAggregateInput = {
    id?: SortOrder
    observaciones?: SortOrder
    motivoRechazo?: SortOrder
    revisadoPor?: SortOrder
    fechaRevision?: SortOrder
    escaneoVirus?: SortOrder
    virusDetectado?: SortOrder
    nombreVirusDetectado?: SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentoEstudianteMinOrderByAggregateInput = {
    id?: SortOrder
    observaciones?: SortOrder
    motivoRechazo?: SortOrder
    revisadoPor?: SortOrder
    fechaRevision?: SortOrder
    escaneoVirus?: SortOrder
    virusDetectado?: SortOrder
    nombreVirusDetectado?: SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    documentoId?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type ActividadUsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    descripcion?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActividadUsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    descripcion?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActividadUsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    descripcion?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
  }

  export type EstudianteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ProfesorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ProfesorCreateWithoutUsuarioInput, ProfesorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUsuarioInput
    connect?: ProfesorWhereUniqueInput
  }

  export type AdministradorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AdministradorCreateWithoutUsuarioInput, AdministradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdministradorCreateOrConnectWithoutUsuarioInput
    connect?: AdministradorWhereUniqueInput
  }

  export type TokenSesionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TokenSesionCreateWithoutUsuarioInput, TokenSesionUncheckedCreateWithoutUsuarioInput> | TokenSesionCreateWithoutUsuarioInput[] | TokenSesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenSesionCreateOrConnectWithoutUsuarioInput | TokenSesionCreateOrConnectWithoutUsuarioInput[]
    createMany?: TokenSesionCreateManyUsuarioInputEnvelope
    connect?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
  }

  export type ActividadUsuarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ActividadUsuarioCreateWithoutUsuarioInput, ActividadUsuarioUncheckedCreateWithoutUsuarioInput> | ActividadUsuarioCreateWithoutUsuarioInput[] | ActividadUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadUsuarioCreateOrConnectWithoutUsuarioInput | ActividadUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ActividadUsuarioCreateManyUsuarioInputEnvelope
    connect?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
  }

  export type DocumentoCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<DocumentoCreateWithoutCreadoPorInput, DocumentoUncheckedCreateWithoutCreadoPorInput> | DocumentoCreateWithoutCreadoPorInput[] | DocumentoUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCreadoPorInput | DocumentoCreateOrConnectWithoutCreadoPorInput[]
    createMany?: DocumentoCreateManyCreadoPorInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type EstudianteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ProfesorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ProfesorCreateWithoutUsuarioInput, ProfesorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUsuarioInput
    connect?: ProfesorWhereUniqueInput
  }

  export type AdministradorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AdministradorCreateWithoutUsuarioInput, AdministradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdministradorCreateOrConnectWithoutUsuarioInput
    connect?: AdministradorWhereUniqueInput
  }

  export type TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TokenSesionCreateWithoutUsuarioInput, TokenSesionUncheckedCreateWithoutUsuarioInput> | TokenSesionCreateWithoutUsuarioInput[] | TokenSesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenSesionCreateOrConnectWithoutUsuarioInput | TokenSesionCreateOrConnectWithoutUsuarioInput[]
    createMany?: TokenSesionCreateManyUsuarioInputEnvelope
    connect?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
  }

  export type ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ActividadUsuarioCreateWithoutUsuarioInput, ActividadUsuarioUncheckedCreateWithoutUsuarioInput> | ActividadUsuarioCreateWithoutUsuarioInput[] | ActividadUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadUsuarioCreateOrConnectWithoutUsuarioInput | ActividadUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ActividadUsuarioCreateManyUsuarioInputEnvelope
    connect?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
  }

  export type DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<DocumentoCreateWithoutCreadoPorInput, DocumentoUncheckedCreateWithoutCreadoPorInput> | DocumentoCreateWithoutCreadoPorInput[] | DocumentoUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCreadoPorInput | DocumentoCreateOrConnectWithoutCreadoPorInput[]
    createMany?: DocumentoCreateManyCreadoPorInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EstudianteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    upsert?: EstudianteUpsertWithoutUsuarioInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutUsuarioInput, EstudianteUpdateWithoutUsuarioInput>, EstudianteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ProfesorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ProfesorCreateWithoutUsuarioInput, ProfesorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUsuarioInput
    upsert?: ProfesorUpsertWithoutUsuarioInput
    disconnect?: ProfesorWhereInput | boolean
    delete?: ProfesorWhereInput | boolean
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutUsuarioInput, ProfesorUpdateWithoutUsuarioInput>, ProfesorUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdministradorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AdministradorCreateWithoutUsuarioInput, AdministradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdministradorCreateOrConnectWithoutUsuarioInput
    upsert?: AdministradorUpsertWithoutUsuarioInput
    disconnect?: AdministradorWhereInput | boolean
    delete?: AdministradorWhereInput | boolean
    connect?: AdministradorWhereUniqueInput
    update?: XOR<XOR<AdministradorUpdateToOneWithWhereWithoutUsuarioInput, AdministradorUpdateWithoutUsuarioInput>, AdministradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type TokenSesionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TokenSesionCreateWithoutUsuarioInput, TokenSesionUncheckedCreateWithoutUsuarioInput> | TokenSesionCreateWithoutUsuarioInput[] | TokenSesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenSesionCreateOrConnectWithoutUsuarioInput | TokenSesionCreateOrConnectWithoutUsuarioInput[]
    upsert?: TokenSesionUpsertWithWhereUniqueWithoutUsuarioInput | TokenSesionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TokenSesionCreateManyUsuarioInputEnvelope
    set?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    disconnect?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    delete?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    connect?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    update?: TokenSesionUpdateWithWhereUniqueWithoutUsuarioInput | TokenSesionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TokenSesionUpdateManyWithWhereWithoutUsuarioInput | TokenSesionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TokenSesionScalarWhereInput | TokenSesionScalarWhereInput[]
  }

  export type ActividadUsuarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ActividadUsuarioCreateWithoutUsuarioInput, ActividadUsuarioUncheckedCreateWithoutUsuarioInput> | ActividadUsuarioCreateWithoutUsuarioInput[] | ActividadUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadUsuarioCreateOrConnectWithoutUsuarioInput | ActividadUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ActividadUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | ActividadUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ActividadUsuarioCreateManyUsuarioInputEnvelope
    set?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    disconnect?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    delete?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    connect?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    update?: ActividadUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | ActividadUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ActividadUsuarioUpdateManyWithWhereWithoutUsuarioInput | ActividadUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ActividadUsuarioScalarWhereInput | ActividadUsuarioScalarWhereInput[]
  }

  export type DocumentoUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<DocumentoCreateWithoutCreadoPorInput, DocumentoUncheckedCreateWithoutCreadoPorInput> | DocumentoCreateWithoutCreadoPorInput[] | DocumentoUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCreadoPorInput | DocumentoCreateOrConnectWithoutCreadoPorInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutCreadoPorInput | DocumentoUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: DocumentoCreateManyCreadoPorInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutCreadoPorInput | DocumentoUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutCreadoPorInput | DocumentoUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutUsuarioInput
    upsert?: EstudianteUpsertWithoutUsuarioInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutUsuarioInput, EstudianteUpdateWithoutUsuarioInput>, EstudianteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ProfesorCreateWithoutUsuarioInput, ProfesorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutUsuarioInput
    upsert?: ProfesorUpsertWithoutUsuarioInput
    disconnect?: ProfesorWhereInput | boolean
    delete?: ProfesorWhereInput | boolean
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutUsuarioInput, ProfesorUpdateWithoutUsuarioInput>, ProfesorUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AdministradorCreateWithoutUsuarioInput, AdministradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdministradorCreateOrConnectWithoutUsuarioInput
    upsert?: AdministradorUpsertWithoutUsuarioInput
    disconnect?: AdministradorWhereInput | boolean
    delete?: AdministradorWhereInput | boolean
    connect?: AdministradorWhereUniqueInput
    update?: XOR<XOR<AdministradorUpdateToOneWithWhereWithoutUsuarioInput, AdministradorUpdateWithoutUsuarioInput>, AdministradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TokenSesionCreateWithoutUsuarioInput, TokenSesionUncheckedCreateWithoutUsuarioInput> | TokenSesionCreateWithoutUsuarioInput[] | TokenSesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenSesionCreateOrConnectWithoutUsuarioInput | TokenSesionCreateOrConnectWithoutUsuarioInput[]
    upsert?: TokenSesionUpsertWithWhereUniqueWithoutUsuarioInput | TokenSesionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TokenSesionCreateManyUsuarioInputEnvelope
    set?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    disconnect?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    delete?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    connect?: TokenSesionWhereUniqueInput | TokenSesionWhereUniqueInput[]
    update?: TokenSesionUpdateWithWhereUniqueWithoutUsuarioInput | TokenSesionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TokenSesionUpdateManyWithWhereWithoutUsuarioInput | TokenSesionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TokenSesionScalarWhereInput | TokenSesionScalarWhereInput[]
  }

  export type ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ActividadUsuarioCreateWithoutUsuarioInput, ActividadUsuarioUncheckedCreateWithoutUsuarioInput> | ActividadUsuarioCreateWithoutUsuarioInput[] | ActividadUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadUsuarioCreateOrConnectWithoutUsuarioInput | ActividadUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ActividadUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | ActividadUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ActividadUsuarioCreateManyUsuarioInputEnvelope
    set?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    disconnect?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    delete?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    connect?: ActividadUsuarioWhereUniqueInput | ActividadUsuarioWhereUniqueInput[]
    update?: ActividadUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | ActividadUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ActividadUsuarioUpdateManyWithWhereWithoutUsuarioInput | ActividadUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ActividadUsuarioScalarWhereInput | ActividadUsuarioScalarWhereInput[]
  }

  export type DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<DocumentoCreateWithoutCreadoPorInput, DocumentoUncheckedCreateWithoutCreadoPorInput> | DocumentoCreateWithoutCreadoPorInput[] | DocumentoUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCreadoPorInput | DocumentoCreateOrConnectWithoutCreadoPorInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutCreadoPorInput | DocumentoUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: DocumentoCreateManyCreadoPorInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutCreadoPorInput | DocumentoUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutCreadoPorInput | DocumentoUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutTokensInput = {
    create?: XOR<UsuarioCreateWithoutTokensInput, UsuarioUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTokensInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EnumTipoTokenFieldUpdateOperationsInput = {
    set?: $Enums.TipoToken
  }

  export type UsuarioUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UsuarioCreateWithoutTokensInput, UsuarioUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTokensInput
    upsert?: UsuarioUpsertWithoutTokensInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTokensInput, UsuarioUpdateWithoutTokensInput>, UsuarioUncheckedUpdateWithoutTokensInput>
  }

  export type UsuarioCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEstudianteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CarreraCreateNestedOneWithoutEstudiantesInput = {
    create?: XOR<CarreraCreateWithoutEstudiantesInput, CarreraUncheckedCreateWithoutEstudiantesInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutEstudiantesInput
    connect?: CarreraWhereUniqueInput
  }

  export type InscripcionCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<InscripcionCreateWithoutEstudianteInput, InscripcionUncheckedCreateWithoutEstudianteInput> | InscripcionCreateWithoutEstudianteInput[] | InscripcionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutEstudianteInput | InscripcionCreateOrConnectWithoutEstudianteInput[]
    createMany?: InscripcionCreateManyEstudianteInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type CalificacionCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<CalificacionCreateWithoutEstudianteInput, CalificacionUncheckedCreateWithoutEstudianteInput> | CalificacionCreateWithoutEstudianteInput[] | CalificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutEstudianteInput | CalificacionCreateOrConnectWithoutEstudianteInput[]
    createMany?: CalificacionCreateManyEstudianteInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type DocumentoEstudianteCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutEstudianteInput, DocumentoEstudianteUncheckedCreateWithoutEstudianteInput> | DocumentoEstudianteCreateWithoutEstudianteInput[] | DocumentoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutEstudianteInput | DocumentoEstudianteCreateOrConnectWithoutEstudianteInput[]
    createMany?: DocumentoEstudianteCreateManyEstudianteInputEnvelope
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
  }

  export type NotificacionCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<NotificacionCreateWithoutEstudianteInput, NotificacionUncheckedCreateWithoutEstudianteInput> | NotificacionCreateWithoutEstudianteInput[] | NotificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutEstudianteInput | NotificacionCreateOrConnectWithoutEstudianteInput[]
    createMany?: NotificacionCreateManyEstudianteInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type InscripcionUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<InscripcionCreateWithoutEstudianteInput, InscripcionUncheckedCreateWithoutEstudianteInput> | InscripcionCreateWithoutEstudianteInput[] | InscripcionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutEstudianteInput | InscripcionCreateOrConnectWithoutEstudianteInput[]
    createMany?: InscripcionCreateManyEstudianteInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type CalificacionUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<CalificacionCreateWithoutEstudianteInput, CalificacionUncheckedCreateWithoutEstudianteInput> | CalificacionCreateWithoutEstudianteInput[] | CalificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutEstudianteInput | CalificacionCreateOrConnectWithoutEstudianteInput[]
    createMany?: CalificacionCreateManyEstudianteInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutEstudianteInput, DocumentoEstudianteUncheckedCreateWithoutEstudianteInput> | DocumentoEstudianteCreateWithoutEstudianteInput[] | DocumentoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutEstudianteInput | DocumentoEstudianteCreateOrConnectWithoutEstudianteInput[]
    createMany?: DocumentoEstudianteCreateManyEstudianteInputEnvelope
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
  }

  export type NotificacionUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<NotificacionCreateWithoutEstudianteInput, NotificacionUncheckedCreateWithoutEstudianteInput> | NotificacionCreateWithoutEstudianteInput[] | NotificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutEstudianteInput | NotificacionCreateOrConnectWithoutEstudianteInput[]
    createMany?: NotificacionCreateManyEstudianteInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type EnumEstatusEstudianteFieldUpdateOperationsInput = {
    set?: $Enums.EstatusEstudiante
  }

  export type UsuarioUpdateOneRequiredWithoutEstudianteNestedInput = {
    create?: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEstudianteInput
    upsert?: UsuarioUpsertWithoutEstudianteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEstudianteInput, UsuarioUpdateWithoutEstudianteInput>, UsuarioUncheckedUpdateWithoutEstudianteInput>
  }

  export type CarreraUpdateOneWithoutEstudiantesNestedInput = {
    create?: XOR<CarreraCreateWithoutEstudiantesInput, CarreraUncheckedCreateWithoutEstudiantesInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutEstudiantesInput
    upsert?: CarreraUpsertWithoutEstudiantesInput
    disconnect?: CarreraWhereInput | boolean
    delete?: CarreraWhereInput | boolean
    connect?: CarreraWhereUniqueInput
    update?: XOR<XOR<CarreraUpdateToOneWithWhereWithoutEstudiantesInput, CarreraUpdateWithoutEstudiantesInput>, CarreraUncheckedUpdateWithoutEstudiantesInput>
  }

  export type InscripcionUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<InscripcionCreateWithoutEstudianteInput, InscripcionUncheckedCreateWithoutEstudianteInput> | InscripcionCreateWithoutEstudianteInput[] | InscripcionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutEstudianteInput | InscripcionCreateOrConnectWithoutEstudianteInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutEstudianteInput | InscripcionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: InscripcionCreateManyEstudianteInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutEstudianteInput | InscripcionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutEstudianteInput | InscripcionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type CalificacionUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<CalificacionCreateWithoutEstudianteInput, CalificacionUncheckedCreateWithoutEstudianteInput> | CalificacionCreateWithoutEstudianteInput[] | CalificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutEstudianteInput | CalificacionCreateOrConnectWithoutEstudianteInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutEstudianteInput | CalificacionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: CalificacionCreateManyEstudianteInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutEstudianteInput | CalificacionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutEstudianteInput | CalificacionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutEstudianteInput, DocumentoEstudianteUncheckedCreateWithoutEstudianteInput> | DocumentoEstudianteCreateWithoutEstudianteInput[] | DocumentoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutEstudianteInput | DocumentoEstudianteCreateOrConnectWithoutEstudianteInput[]
    upsert?: DocumentoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput | DocumentoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: DocumentoEstudianteCreateManyEstudianteInputEnvelope
    set?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    disconnect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    delete?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    update?: DocumentoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput | DocumentoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: DocumentoEstudianteUpdateManyWithWhereWithoutEstudianteInput | DocumentoEstudianteUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: DocumentoEstudianteScalarWhereInput | DocumentoEstudianteScalarWhereInput[]
  }

  export type NotificacionUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<NotificacionCreateWithoutEstudianteInput, NotificacionUncheckedCreateWithoutEstudianteInput> | NotificacionCreateWithoutEstudianteInput[] | NotificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutEstudianteInput | NotificacionCreateOrConnectWithoutEstudianteInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutEstudianteInput | NotificacionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: NotificacionCreateManyEstudianteInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutEstudianteInput | NotificacionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutEstudianteInput | NotificacionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<InscripcionCreateWithoutEstudianteInput, InscripcionUncheckedCreateWithoutEstudianteInput> | InscripcionCreateWithoutEstudianteInput[] | InscripcionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutEstudianteInput | InscripcionCreateOrConnectWithoutEstudianteInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutEstudianteInput | InscripcionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: InscripcionCreateManyEstudianteInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutEstudianteInput | InscripcionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutEstudianteInput | InscripcionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<CalificacionCreateWithoutEstudianteInput, CalificacionUncheckedCreateWithoutEstudianteInput> | CalificacionCreateWithoutEstudianteInput[] | CalificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutEstudianteInput | CalificacionCreateOrConnectWithoutEstudianteInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutEstudianteInput | CalificacionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: CalificacionCreateManyEstudianteInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutEstudianteInput | CalificacionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutEstudianteInput | CalificacionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutEstudianteInput, DocumentoEstudianteUncheckedCreateWithoutEstudianteInput> | DocumentoEstudianteCreateWithoutEstudianteInput[] | DocumentoEstudianteUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutEstudianteInput | DocumentoEstudianteCreateOrConnectWithoutEstudianteInput[]
    upsert?: DocumentoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput | DocumentoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: DocumentoEstudianteCreateManyEstudianteInputEnvelope
    set?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    disconnect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    delete?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    update?: DocumentoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput | DocumentoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: DocumentoEstudianteUpdateManyWithWhereWithoutEstudianteInput | DocumentoEstudianteUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: DocumentoEstudianteScalarWhereInput | DocumentoEstudianteScalarWhereInput[]
  }

  export type NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<NotificacionCreateWithoutEstudianteInput, NotificacionUncheckedCreateWithoutEstudianteInput> | NotificacionCreateWithoutEstudianteInput[] | NotificacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutEstudianteInput | NotificacionCreateOrConnectWithoutEstudianteInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutEstudianteInput | NotificacionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: NotificacionCreateManyEstudianteInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutEstudianteInput | NotificacionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutEstudianteInput | NotificacionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type EstudianteCreateNestedManyWithoutCarreraInput = {
    create?: XOR<EstudianteCreateWithoutCarreraInput, EstudianteUncheckedCreateWithoutCarreraInput> | EstudianteCreateWithoutCarreraInput[] | EstudianteUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutCarreraInput | EstudianteCreateOrConnectWithoutCarreraInput[]
    createMany?: EstudianteCreateManyCarreraInputEnvelope
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
  }

  export type MateriaCreateNestedManyWithoutCarreraInput = {
    create?: XOR<MateriaCreateWithoutCarreraInput, MateriaUncheckedCreateWithoutCarreraInput> | MateriaCreateWithoutCarreraInput[] | MateriaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutCarreraInput | MateriaCreateOrConnectWithoutCarreraInput[]
    createMany?: MateriaCreateManyCarreraInputEnvelope
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
  }

  export type EstudianteUncheckedCreateNestedManyWithoutCarreraInput = {
    create?: XOR<EstudianteCreateWithoutCarreraInput, EstudianteUncheckedCreateWithoutCarreraInput> | EstudianteCreateWithoutCarreraInput[] | EstudianteUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutCarreraInput | EstudianteCreateOrConnectWithoutCarreraInput[]
    createMany?: EstudianteCreateManyCarreraInputEnvelope
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
  }

  export type MateriaUncheckedCreateNestedManyWithoutCarreraInput = {
    create?: XOR<MateriaCreateWithoutCarreraInput, MateriaUncheckedCreateWithoutCarreraInput> | MateriaCreateWithoutCarreraInput[] | MateriaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutCarreraInput | MateriaCreateOrConnectWithoutCarreraInput[]
    createMany?: MateriaCreateManyCarreraInputEnvelope
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
  }

  export type EnumModalidadFieldUpdateOperationsInput = {
    set?: $Enums.Modalidad
  }

  export type EstudianteUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<EstudianteCreateWithoutCarreraInput, EstudianteUncheckedCreateWithoutCarreraInput> | EstudianteCreateWithoutCarreraInput[] | EstudianteUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutCarreraInput | EstudianteCreateOrConnectWithoutCarreraInput[]
    upsert?: EstudianteUpsertWithWhereUniqueWithoutCarreraInput | EstudianteUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: EstudianteCreateManyCarreraInputEnvelope
    set?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    disconnect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    delete?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    update?: EstudianteUpdateWithWhereUniqueWithoutCarreraInput | EstudianteUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: EstudianteUpdateManyWithWhereWithoutCarreraInput | EstudianteUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
  }

  export type MateriaUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<MateriaCreateWithoutCarreraInput, MateriaUncheckedCreateWithoutCarreraInput> | MateriaCreateWithoutCarreraInput[] | MateriaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutCarreraInput | MateriaCreateOrConnectWithoutCarreraInput[]
    upsert?: MateriaUpsertWithWhereUniqueWithoutCarreraInput | MateriaUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: MateriaCreateManyCarreraInputEnvelope
    set?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    disconnect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    delete?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    update?: MateriaUpdateWithWhereUniqueWithoutCarreraInput | MateriaUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: MateriaUpdateManyWithWhereWithoutCarreraInput | MateriaUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
  }

  export type EstudianteUncheckedUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<EstudianteCreateWithoutCarreraInput, EstudianteUncheckedCreateWithoutCarreraInput> | EstudianteCreateWithoutCarreraInput[] | EstudianteUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EstudianteCreateOrConnectWithoutCarreraInput | EstudianteCreateOrConnectWithoutCarreraInput[]
    upsert?: EstudianteUpsertWithWhereUniqueWithoutCarreraInput | EstudianteUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: EstudianteCreateManyCarreraInputEnvelope
    set?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    disconnect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    delete?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    connect?: EstudianteWhereUniqueInput | EstudianteWhereUniqueInput[]
    update?: EstudianteUpdateWithWhereUniqueWithoutCarreraInput | EstudianteUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: EstudianteUpdateManyWithWhereWithoutCarreraInput | EstudianteUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
  }

  export type MateriaUncheckedUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<MateriaCreateWithoutCarreraInput, MateriaUncheckedCreateWithoutCarreraInput> | MateriaCreateWithoutCarreraInput[] | MateriaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutCarreraInput | MateriaCreateOrConnectWithoutCarreraInput[]
    upsert?: MateriaUpsertWithWhereUniqueWithoutCarreraInput | MateriaUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: MateriaCreateManyCarreraInputEnvelope
    set?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    disconnect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    delete?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    update?: MateriaUpdateWithWhereUniqueWithoutCarreraInput | MateriaUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: MateriaUpdateManyWithWhereWithoutCarreraInput | MateriaUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
  }

  export type CarreraCreateNestedOneWithoutMateriasInput = {
    create?: XOR<CarreraCreateWithoutMateriasInput, CarreraUncheckedCreateWithoutMateriasInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutMateriasInput
    connect?: CarreraWhereUniqueInput
  }

  export type GrupoCreateNestedManyWithoutMateriaInput = {
    create?: XOR<GrupoCreateWithoutMateriaInput, GrupoUncheckedCreateWithoutMateriaInput> | GrupoCreateWithoutMateriaInput[] | GrupoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutMateriaInput | GrupoCreateOrConnectWithoutMateriaInput[]
    createMany?: GrupoCreateManyMateriaInputEnvelope
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
  }

  export type CalificacionCreateNestedManyWithoutMateriaInput = {
    create?: XOR<CalificacionCreateWithoutMateriaInput, CalificacionUncheckedCreateWithoutMateriaInput> | CalificacionCreateWithoutMateriaInput[] | CalificacionUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutMateriaInput | CalificacionCreateOrConnectWithoutMateriaInput[]
    createMany?: CalificacionCreateManyMateriaInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type GrupoUncheckedCreateNestedManyWithoutMateriaInput = {
    create?: XOR<GrupoCreateWithoutMateriaInput, GrupoUncheckedCreateWithoutMateriaInput> | GrupoCreateWithoutMateriaInput[] | GrupoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutMateriaInput | GrupoCreateOrConnectWithoutMateriaInput[]
    createMany?: GrupoCreateManyMateriaInputEnvelope
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
  }

  export type CalificacionUncheckedCreateNestedManyWithoutMateriaInput = {
    create?: XOR<CalificacionCreateWithoutMateriaInput, CalificacionUncheckedCreateWithoutMateriaInput> | CalificacionCreateWithoutMateriaInput[] | CalificacionUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutMateriaInput | CalificacionCreateOrConnectWithoutMateriaInput[]
    createMany?: CalificacionCreateManyMateriaInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type CarreraUpdateOneRequiredWithoutMateriasNestedInput = {
    create?: XOR<CarreraCreateWithoutMateriasInput, CarreraUncheckedCreateWithoutMateriasInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutMateriasInput
    upsert?: CarreraUpsertWithoutMateriasInput
    connect?: CarreraWhereUniqueInput
    update?: XOR<XOR<CarreraUpdateToOneWithWhereWithoutMateriasInput, CarreraUpdateWithoutMateriasInput>, CarreraUncheckedUpdateWithoutMateriasInput>
  }

  export type GrupoUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<GrupoCreateWithoutMateriaInput, GrupoUncheckedCreateWithoutMateriaInput> | GrupoCreateWithoutMateriaInput[] | GrupoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutMateriaInput | GrupoCreateOrConnectWithoutMateriaInput[]
    upsert?: GrupoUpsertWithWhereUniqueWithoutMateriaInput | GrupoUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: GrupoCreateManyMateriaInputEnvelope
    set?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    disconnect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    delete?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    update?: GrupoUpdateWithWhereUniqueWithoutMateriaInput | GrupoUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: GrupoUpdateManyWithWhereWithoutMateriaInput | GrupoUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: GrupoScalarWhereInput | GrupoScalarWhereInput[]
  }

  export type CalificacionUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<CalificacionCreateWithoutMateriaInput, CalificacionUncheckedCreateWithoutMateriaInput> | CalificacionCreateWithoutMateriaInput[] | CalificacionUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutMateriaInput | CalificacionCreateOrConnectWithoutMateriaInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutMateriaInput | CalificacionUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: CalificacionCreateManyMateriaInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutMateriaInput | CalificacionUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutMateriaInput | CalificacionUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type GrupoUncheckedUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<GrupoCreateWithoutMateriaInput, GrupoUncheckedCreateWithoutMateriaInput> | GrupoCreateWithoutMateriaInput[] | GrupoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutMateriaInput | GrupoCreateOrConnectWithoutMateriaInput[]
    upsert?: GrupoUpsertWithWhereUniqueWithoutMateriaInput | GrupoUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: GrupoCreateManyMateriaInputEnvelope
    set?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    disconnect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    delete?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    update?: GrupoUpdateWithWhereUniqueWithoutMateriaInput | GrupoUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: GrupoUpdateManyWithWhereWithoutMateriaInput | GrupoUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: GrupoScalarWhereInput | GrupoScalarWhereInput[]
  }

  export type CalificacionUncheckedUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<CalificacionCreateWithoutMateriaInput, CalificacionUncheckedCreateWithoutMateriaInput> | CalificacionCreateWithoutMateriaInput[] | CalificacionUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutMateriaInput | CalificacionCreateOrConnectWithoutMateriaInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutMateriaInput | CalificacionUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: CalificacionCreateManyMateriaInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutMateriaInput | CalificacionUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutMateriaInput | CalificacionUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type MateriaCreateNestedOneWithoutGruposInput = {
    create?: XOR<MateriaCreateWithoutGruposInput, MateriaUncheckedCreateWithoutGruposInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutGruposInput
    connect?: MateriaWhereUniqueInput
  }

  export type ProfesorCreateNestedOneWithoutGruposInput = {
    create?: XOR<ProfesorCreateWithoutGruposInput, ProfesorUncheckedCreateWithoutGruposInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutGruposInput
    connect?: ProfesorWhereUniqueInput
  }

  export type InscripcionCreateNestedManyWithoutGrupoInput = {
    create?: XOR<InscripcionCreateWithoutGrupoInput, InscripcionUncheckedCreateWithoutGrupoInput> | InscripcionCreateWithoutGrupoInput[] | InscripcionUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutGrupoInput | InscripcionCreateOrConnectWithoutGrupoInput[]
    createMany?: InscripcionCreateManyGrupoInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type InscripcionUncheckedCreateNestedManyWithoutGrupoInput = {
    create?: XOR<InscripcionCreateWithoutGrupoInput, InscripcionUncheckedCreateWithoutGrupoInput> | InscripcionCreateWithoutGrupoInput[] | InscripcionUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutGrupoInput | InscripcionCreateOrConnectWithoutGrupoInput[]
    createMany?: InscripcionCreateManyGrupoInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type MateriaUpdateOneRequiredWithoutGruposNestedInput = {
    create?: XOR<MateriaCreateWithoutGruposInput, MateriaUncheckedCreateWithoutGruposInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutGruposInput
    upsert?: MateriaUpsertWithoutGruposInput
    connect?: MateriaWhereUniqueInput
    update?: XOR<XOR<MateriaUpdateToOneWithWhereWithoutGruposInput, MateriaUpdateWithoutGruposInput>, MateriaUncheckedUpdateWithoutGruposInput>
  }

  export type ProfesorUpdateOneRequiredWithoutGruposNestedInput = {
    create?: XOR<ProfesorCreateWithoutGruposInput, ProfesorUncheckedCreateWithoutGruposInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutGruposInput
    upsert?: ProfesorUpsertWithoutGruposInput
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutGruposInput, ProfesorUpdateWithoutGruposInput>, ProfesorUncheckedUpdateWithoutGruposInput>
  }

  export type InscripcionUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<InscripcionCreateWithoutGrupoInput, InscripcionUncheckedCreateWithoutGrupoInput> | InscripcionCreateWithoutGrupoInput[] | InscripcionUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutGrupoInput | InscripcionCreateOrConnectWithoutGrupoInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutGrupoInput | InscripcionUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: InscripcionCreateManyGrupoInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutGrupoInput | InscripcionUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutGrupoInput | InscripcionUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type InscripcionUncheckedUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<InscripcionCreateWithoutGrupoInput, InscripcionUncheckedCreateWithoutGrupoInput> | InscripcionCreateWithoutGrupoInput[] | InscripcionUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutGrupoInput | InscripcionCreateOrConnectWithoutGrupoInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutGrupoInput | InscripcionUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: InscripcionCreateManyGrupoInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutGrupoInput | InscripcionUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutGrupoInput | InscripcionUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type EstudianteCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<EstudianteCreateWithoutInscripcionesInput, EstudianteUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutInscripcionesInput
    connect?: EstudianteWhereUniqueInput
  }

  export type GrupoCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<GrupoCreateWithoutInscripcionesInput, GrupoUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: GrupoCreateOrConnectWithoutInscripcionesInput
    connect?: GrupoWhereUniqueInput
  }

  export type CalificacionCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<CalificacionCreateWithoutInscripcionInput, CalificacionUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CalificacionCreateOrConnectWithoutInscripcionInput
    connect?: CalificacionWhereUniqueInput
  }

  export type CalificacionUncheckedCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<CalificacionCreateWithoutInscripcionInput, CalificacionUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CalificacionCreateOrConnectWithoutInscripcionInput
    connect?: CalificacionWhereUniqueInput
  }

  export type EnumEstatusInscripcionFieldUpdateOperationsInput = {
    set?: $Enums.EstatusInscripcion
  }

  export type EstudianteUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<EstudianteCreateWithoutInscripcionesInput, EstudianteUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutInscripcionesInput
    upsert?: EstudianteUpsertWithoutInscripcionesInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutInscripcionesInput, EstudianteUpdateWithoutInscripcionesInput>, EstudianteUncheckedUpdateWithoutInscripcionesInput>
  }

  export type GrupoUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<GrupoCreateWithoutInscripcionesInput, GrupoUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: GrupoCreateOrConnectWithoutInscripcionesInput
    upsert?: GrupoUpsertWithoutInscripcionesInput
    connect?: GrupoWhereUniqueInput
    update?: XOR<XOR<GrupoUpdateToOneWithWhereWithoutInscripcionesInput, GrupoUpdateWithoutInscripcionesInput>, GrupoUncheckedUpdateWithoutInscripcionesInput>
  }

  export type CalificacionUpdateOneWithoutInscripcionNestedInput = {
    create?: XOR<CalificacionCreateWithoutInscripcionInput, CalificacionUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CalificacionCreateOrConnectWithoutInscripcionInput
    upsert?: CalificacionUpsertWithoutInscripcionInput
    disconnect?: CalificacionWhereInput | boolean
    delete?: CalificacionWhereInput | boolean
    connect?: CalificacionWhereUniqueInput
    update?: XOR<XOR<CalificacionUpdateToOneWithWhereWithoutInscripcionInput, CalificacionUpdateWithoutInscripcionInput>, CalificacionUncheckedUpdateWithoutInscripcionInput>
  }

  export type CalificacionUncheckedUpdateOneWithoutInscripcionNestedInput = {
    create?: XOR<CalificacionCreateWithoutInscripcionInput, CalificacionUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CalificacionCreateOrConnectWithoutInscripcionInput
    upsert?: CalificacionUpsertWithoutInscripcionInput
    disconnect?: CalificacionWhereInput | boolean
    delete?: CalificacionWhereInput | boolean
    connect?: CalificacionWhereUniqueInput
    update?: XOR<XOR<CalificacionUpdateToOneWithWhereWithoutInscripcionInput, CalificacionUpdateWithoutInscripcionInput>, CalificacionUncheckedUpdateWithoutInscripcionInput>
  }

  export type EstudianteCreateNestedOneWithoutCalificacionesInput = {
    create?: XOR<EstudianteCreateWithoutCalificacionesInput, EstudianteUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutCalificacionesInput
    connect?: EstudianteWhereUniqueInput
  }

  export type MateriaCreateNestedOneWithoutCalificacionesInput = {
    create?: XOR<MateriaCreateWithoutCalificacionesInput, MateriaUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutCalificacionesInput
    connect?: MateriaWhereUniqueInput
  }

  export type InscripcionCreateNestedOneWithoutCalificacionInput = {
    create?: XOR<InscripcionCreateWithoutCalificacionInput, InscripcionUncheckedCreateWithoutCalificacionInput>
    connectOrCreate?: InscripcionCreateOrConnectWithoutCalificacionInput
    connect?: InscripcionWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EstudianteUpdateOneRequiredWithoutCalificacionesNestedInput = {
    create?: XOR<EstudianteCreateWithoutCalificacionesInput, EstudianteUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutCalificacionesInput
    upsert?: EstudianteUpsertWithoutCalificacionesInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutCalificacionesInput, EstudianteUpdateWithoutCalificacionesInput>, EstudianteUncheckedUpdateWithoutCalificacionesInput>
  }

  export type MateriaUpdateOneRequiredWithoutCalificacionesNestedInput = {
    create?: XOR<MateriaCreateWithoutCalificacionesInput, MateriaUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutCalificacionesInput
    upsert?: MateriaUpsertWithoutCalificacionesInput
    connect?: MateriaWhereUniqueInput
    update?: XOR<XOR<MateriaUpdateToOneWithWhereWithoutCalificacionesInput, MateriaUpdateWithoutCalificacionesInput>, MateriaUncheckedUpdateWithoutCalificacionesInput>
  }

  export type InscripcionUpdateOneRequiredWithoutCalificacionNestedInput = {
    create?: XOR<InscripcionCreateWithoutCalificacionInput, InscripcionUncheckedCreateWithoutCalificacionInput>
    connectOrCreate?: InscripcionCreateOrConnectWithoutCalificacionInput
    upsert?: InscripcionUpsertWithoutCalificacionInput
    connect?: InscripcionWhereUniqueInput
    update?: XOR<XOR<InscripcionUpdateToOneWithWhereWithoutCalificacionInput, InscripcionUpdateWithoutCalificacionInput>, InscripcionUncheckedUpdateWithoutCalificacionInput>
  }

  export type UsuarioCreateNestedOneWithoutProfesorInput = {
    create?: XOR<UsuarioCreateWithoutProfesorInput, UsuarioUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProfesorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type GrupoCreateNestedManyWithoutProfesorInput = {
    create?: XOR<GrupoCreateWithoutProfesorInput, GrupoUncheckedCreateWithoutProfesorInput> | GrupoCreateWithoutProfesorInput[] | GrupoUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutProfesorInput | GrupoCreateOrConnectWithoutProfesorInput[]
    createMany?: GrupoCreateManyProfesorInputEnvelope
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
  }

  export type GrupoUncheckedCreateNestedManyWithoutProfesorInput = {
    create?: XOR<GrupoCreateWithoutProfesorInput, GrupoUncheckedCreateWithoutProfesorInput> | GrupoCreateWithoutProfesorInput[] | GrupoUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutProfesorInput | GrupoCreateOrConnectWithoutProfesorInput[]
    createMany?: GrupoCreateManyProfesorInputEnvelope
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutProfesorNestedInput = {
    create?: XOR<UsuarioCreateWithoutProfesorInput, UsuarioUncheckedCreateWithoutProfesorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProfesorInput
    upsert?: UsuarioUpsertWithoutProfesorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutProfesorInput, UsuarioUpdateWithoutProfesorInput>, UsuarioUncheckedUpdateWithoutProfesorInput>
  }

  export type GrupoUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<GrupoCreateWithoutProfesorInput, GrupoUncheckedCreateWithoutProfesorInput> | GrupoCreateWithoutProfesorInput[] | GrupoUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutProfesorInput | GrupoCreateOrConnectWithoutProfesorInput[]
    upsert?: GrupoUpsertWithWhereUniqueWithoutProfesorInput | GrupoUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: GrupoCreateManyProfesorInputEnvelope
    set?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    disconnect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    delete?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    update?: GrupoUpdateWithWhereUniqueWithoutProfesorInput | GrupoUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: GrupoUpdateManyWithWhereWithoutProfesorInput | GrupoUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: GrupoScalarWhereInput | GrupoScalarWhereInput[]
  }

  export type GrupoUncheckedUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<GrupoCreateWithoutProfesorInput, GrupoUncheckedCreateWithoutProfesorInput> | GrupoCreateWithoutProfesorInput[] | GrupoUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: GrupoCreateOrConnectWithoutProfesorInput | GrupoCreateOrConnectWithoutProfesorInput[]
    upsert?: GrupoUpsertWithWhereUniqueWithoutProfesorInput | GrupoUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: GrupoCreateManyProfesorInputEnvelope
    set?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    disconnect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    delete?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    connect?: GrupoWhereUniqueInput | GrupoWhereUniqueInput[]
    update?: GrupoUpdateWithWhereUniqueWithoutProfesorInput | GrupoUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: GrupoUpdateManyWithWhereWithoutProfesorInput | GrupoUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: GrupoScalarWhereInput | GrupoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutAdministradorInput = {
    create?: XOR<UsuarioCreateWithoutAdministradorInput, UsuarioUncheckedCreateWithoutAdministradorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAdministradorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutAdministradorNestedInput = {
    create?: XOR<UsuarioCreateWithoutAdministradorInput, UsuarioUncheckedCreateWithoutAdministradorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAdministradorInput
    upsert?: UsuarioUpsertWithoutAdministradorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAdministradorInput, UsuarioUpdateWithoutAdministradorInput>, UsuarioUncheckedUpdateWithoutAdministradorInput>
  }

  export type UsuarioCreateNestedOneWithoutDocumentosCreadosInput = {
    create?: XOR<UsuarioCreateWithoutDocumentosCreadosInput, UsuarioUncheckedCreateWithoutDocumentosCreadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDocumentosCreadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DocumentoEstudianteCreateNestedManyWithoutDocumentoInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutDocumentoInput, DocumentoEstudianteUncheckedCreateWithoutDocumentoInput> | DocumentoEstudianteCreateWithoutDocumentoInput[] | DocumentoEstudianteUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutDocumentoInput | DocumentoEstudianteCreateOrConnectWithoutDocumentoInput[]
    createMany?: DocumentoEstudianteCreateManyDocumentoInputEnvelope
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
  }

  export type DocumentoEstudianteUncheckedCreateNestedManyWithoutDocumentoInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutDocumentoInput, DocumentoEstudianteUncheckedCreateWithoutDocumentoInput> | DocumentoEstudianteCreateWithoutDocumentoInput[] | DocumentoEstudianteUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutDocumentoInput | DocumentoEstudianteCreateOrConnectWithoutDocumentoInput[]
    createMany?: DocumentoEstudianteCreateManyDocumentoInputEnvelope
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
  }

  export type EnumTipoDocumentoFieldUpdateOperationsInput = {
    set?: $Enums.TipoDocumento
  }

  export type EnumEstatusDocumentoFieldUpdateOperationsInput = {
    set?: $Enums.EstatusDocumento
  }

  export type UsuarioUpdateOneRequiredWithoutDocumentosCreadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutDocumentosCreadosInput, UsuarioUncheckedCreateWithoutDocumentosCreadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDocumentosCreadosInput
    upsert?: UsuarioUpsertWithoutDocumentosCreadosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutDocumentosCreadosInput, UsuarioUpdateWithoutDocumentosCreadosInput>, UsuarioUncheckedUpdateWithoutDocumentosCreadosInput>
  }

  export type DocumentoEstudianteUpdateManyWithoutDocumentoNestedInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutDocumentoInput, DocumentoEstudianteUncheckedCreateWithoutDocumentoInput> | DocumentoEstudianteCreateWithoutDocumentoInput[] | DocumentoEstudianteUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutDocumentoInput | DocumentoEstudianteCreateOrConnectWithoutDocumentoInput[]
    upsert?: DocumentoEstudianteUpsertWithWhereUniqueWithoutDocumentoInput | DocumentoEstudianteUpsertWithWhereUniqueWithoutDocumentoInput[]
    createMany?: DocumentoEstudianteCreateManyDocumentoInputEnvelope
    set?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    disconnect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    delete?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    update?: DocumentoEstudianteUpdateWithWhereUniqueWithoutDocumentoInput | DocumentoEstudianteUpdateWithWhereUniqueWithoutDocumentoInput[]
    updateMany?: DocumentoEstudianteUpdateManyWithWhereWithoutDocumentoInput | DocumentoEstudianteUpdateManyWithWhereWithoutDocumentoInput[]
    deleteMany?: DocumentoEstudianteScalarWhereInput | DocumentoEstudianteScalarWhereInput[]
  }

  export type DocumentoEstudianteUncheckedUpdateManyWithoutDocumentoNestedInput = {
    create?: XOR<DocumentoEstudianteCreateWithoutDocumentoInput, DocumentoEstudianteUncheckedCreateWithoutDocumentoInput> | DocumentoEstudianteCreateWithoutDocumentoInput[] | DocumentoEstudianteUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: DocumentoEstudianteCreateOrConnectWithoutDocumentoInput | DocumentoEstudianteCreateOrConnectWithoutDocumentoInput[]
    upsert?: DocumentoEstudianteUpsertWithWhereUniqueWithoutDocumentoInput | DocumentoEstudianteUpsertWithWhereUniqueWithoutDocumentoInput[]
    createMany?: DocumentoEstudianteCreateManyDocumentoInputEnvelope
    set?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    disconnect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    delete?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    connect?: DocumentoEstudianteWhereUniqueInput | DocumentoEstudianteWhereUniqueInput[]
    update?: DocumentoEstudianteUpdateWithWhereUniqueWithoutDocumentoInput | DocumentoEstudianteUpdateWithWhereUniqueWithoutDocumentoInput[]
    updateMany?: DocumentoEstudianteUpdateManyWithWhereWithoutDocumentoInput | DocumentoEstudianteUpdateManyWithWhereWithoutDocumentoInput[]
    deleteMany?: DocumentoEstudianteScalarWhereInput | DocumentoEstudianteScalarWhereInput[]
  }

  export type DocumentoCreateNestedOneWithoutDocumentosEstudianteInput = {
    create?: XOR<DocumentoCreateWithoutDocumentosEstudianteInput, DocumentoUncheckedCreateWithoutDocumentosEstudianteInput>
    connectOrCreate?: DocumentoCreateOrConnectWithoutDocumentosEstudianteInput
    connect?: DocumentoWhereUniqueInput
  }

  export type EstudianteCreateNestedOneWithoutDocumentosInput = {
    create?: XOR<EstudianteCreateWithoutDocumentosInput, EstudianteUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutDocumentosInput
    connect?: EstudianteWhereUniqueInput
  }

  export type DocumentoUpdateOneRequiredWithoutDocumentosEstudianteNestedInput = {
    create?: XOR<DocumentoCreateWithoutDocumentosEstudianteInput, DocumentoUncheckedCreateWithoutDocumentosEstudianteInput>
    connectOrCreate?: DocumentoCreateOrConnectWithoutDocumentosEstudianteInput
    upsert?: DocumentoUpsertWithoutDocumentosEstudianteInput
    connect?: DocumentoWhereUniqueInput
    update?: XOR<XOR<DocumentoUpdateToOneWithWhereWithoutDocumentosEstudianteInput, DocumentoUpdateWithoutDocumentosEstudianteInput>, DocumentoUncheckedUpdateWithoutDocumentosEstudianteInput>
  }

  export type EstudianteUpdateOneRequiredWithoutDocumentosNestedInput = {
    create?: XOR<EstudianteCreateWithoutDocumentosInput, EstudianteUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutDocumentosInput
    upsert?: EstudianteUpsertWithoutDocumentosInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutDocumentosInput, EstudianteUpdateWithoutDocumentosInput>, EstudianteUncheckedUpdateWithoutDocumentosInput>
  }

  export type EstudianteCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<EstudianteCreateWithoutNotificacionesInput, EstudianteUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutNotificacionesInput
    connect?: EstudianteWhereUniqueInput
  }

  export type EnumTipoNotificacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoNotificacion
  }

  export type EstudianteUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<EstudianteCreateWithoutNotificacionesInput, EstudianteUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutNotificacionesInput
    upsert?: EstudianteUpsertWithoutNotificacionesInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutNotificacionesInput, EstudianteUpdateWithoutNotificacionesInput>, EstudianteUncheckedUpdateWithoutNotificacionesInput>
  }

  export type UsuarioCreateNestedOneWithoutActividadesInput = {
    create?: XOR<UsuarioCreateWithoutActividadesInput, UsuarioUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutActividadesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutActividadesNestedInput = {
    create?: XOR<UsuarioCreateWithoutActividadesInput, UsuarioUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutActividadesInput
    upsert?: UsuarioUpsertWithoutActividadesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutActividadesInput, UsuarioUpdateWithoutActividadesInput>, UsuarioUncheckedUpdateWithoutActividadesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTipoTokenFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoToken | EnumTipoTokenFieldRefInput<$PrismaModel>
    in?: $Enums.TipoToken[]
    notIn?: $Enums.TipoToken[]
    not?: NestedEnumTipoTokenFilter<$PrismaModel> | $Enums.TipoToken
  }

  export type NestedEnumTipoTokenWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoToken | EnumTipoTokenFieldRefInput<$PrismaModel>
    in?: $Enums.TipoToken[]
    notIn?: $Enums.TipoToken[]
    not?: NestedEnumTipoTokenWithAggregatesFilter<$PrismaModel> | $Enums.TipoToken
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoTokenFilter<$PrismaModel>
    _max?: NestedEnumTipoTokenFilter<$PrismaModel>
  }

  export type NestedEnumEstatusEstudianteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusEstudiante | EnumEstatusEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusEstudiante[]
    notIn?: $Enums.EstatusEstudiante[]
    not?: NestedEnumEstatusEstudianteFilter<$PrismaModel> | $Enums.EstatusEstudiante
  }

  export type NestedEnumEstatusEstudianteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusEstudiante | EnumEstatusEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusEstudiante[]
    notIn?: $Enums.EstatusEstudiante[]
    not?: NestedEnumEstatusEstudianteWithAggregatesFilter<$PrismaModel> | $Enums.EstatusEstudiante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstatusEstudianteFilter<$PrismaModel>
    _max?: NestedEnumEstatusEstudianteFilter<$PrismaModel>
  }

  export type NestedEnumModalidadFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[]
    notIn?: $Enums.Modalidad[]
    not?: NestedEnumModalidadFilter<$PrismaModel> | $Enums.Modalidad
  }

  export type NestedEnumModalidadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[]
    notIn?: $Enums.Modalidad[]
    not?: NestedEnumModalidadWithAggregatesFilter<$PrismaModel> | $Enums.Modalidad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModalidadFilter<$PrismaModel>
    _max?: NestedEnumModalidadFilter<$PrismaModel>
  }

  export type NestedEnumEstatusInscripcionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusInscripcion | EnumEstatusInscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusInscripcion[]
    notIn?: $Enums.EstatusInscripcion[]
    not?: NestedEnumEstatusInscripcionFilter<$PrismaModel> | $Enums.EstatusInscripcion
  }

  export type NestedEnumEstatusInscripcionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusInscripcion | EnumEstatusInscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusInscripcion[]
    notIn?: $Enums.EstatusInscripcion[]
    not?: NestedEnumEstatusInscripcionWithAggregatesFilter<$PrismaModel> | $Enums.EstatusInscripcion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstatusInscripcionFilter<$PrismaModel>
    _max?: NestedEnumEstatusInscripcionFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTipoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[]
    notIn?: $Enums.TipoDocumento[]
    not?: NestedEnumTipoDocumentoFilter<$PrismaModel> | $Enums.TipoDocumento
  }

  export type NestedEnumEstatusDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusDocumento | EnumEstatusDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusDocumento[]
    notIn?: $Enums.EstatusDocumento[]
    not?: NestedEnumEstatusDocumentoFilter<$PrismaModel> | $Enums.EstatusDocumento
  }

  export type NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[]
    notIn?: $Enums.TipoDocumento[]
    not?: NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.TipoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumTipoDocumentoFilter<$PrismaModel>
  }

  export type NestedEnumEstatusDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstatusDocumento | EnumEstatusDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstatusDocumento[]
    notIn?: $Enums.EstatusDocumento[]
    not?: NestedEnumEstatusDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.EstatusDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstatusDocumentoFilter<$PrismaModel>
    _max?: NestedEnumEstatusDocumentoFilter<$PrismaModel>
  }

  export type NestedEnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type EstudianteCreateWithoutUsuarioInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carrera?: CarreraCreateNestedOneWithoutEstudiantesInput
    inscripciones?: InscripcionCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutUsuarioInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutUsuarioInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
  }

  export type ProfesorCreateWithoutUsuarioInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutUsuarioInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorCreateOrConnectWithoutUsuarioInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutUsuarioInput, ProfesorUncheckedCreateWithoutUsuarioInput>
  }

  export type AdministradorCreateWithoutUsuarioInput = {
    id?: string
    numeroEmpleado: string
    area?: string | null
    cargo?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministradorUncheckedCreateWithoutUsuarioInput = {
    id?: string
    numeroEmpleado: string
    area?: string | null
    cargo?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministradorCreateOrConnectWithoutUsuarioInput = {
    where: AdministradorWhereUniqueInput
    create: XOR<AdministradorCreateWithoutUsuarioInput, AdministradorUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenSesionCreateWithoutUsuarioInput = {
    id?: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date | string
    revocado?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type TokenSesionUncheckedCreateWithoutUsuarioInput = {
    id?: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date | string
    revocado?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type TokenSesionCreateOrConnectWithoutUsuarioInput = {
    where: TokenSesionWhereUniqueInput
    create: XOR<TokenSesionCreateWithoutUsuarioInput, TokenSesionUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenSesionCreateManyUsuarioInputEnvelope = {
    data: TokenSesionCreateManyUsuarioInput | TokenSesionCreateManyUsuarioInput[]
  }

  export type ActividadUsuarioCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    entidad?: string | null
    entidadId?: string | null
    descripcion?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActividadUsuarioUncheckedCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    entidad?: string | null
    entidadId?: string | null
    descripcion?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActividadUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: ActividadUsuarioWhereUniqueInput
    create: XOR<ActividadUsuarioCreateWithoutUsuarioInput, ActividadUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ActividadUsuarioCreateManyUsuarioInputEnvelope = {
    data: ActividadUsuarioCreateManyUsuarioInput | ActividadUsuarioCreateManyUsuarioInput[]
  }

  export type DocumentoCreateWithoutCreadoPorInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentosEstudiante?: DocumentoEstudianteCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateWithoutCreadoPorInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentosEstudiante?: DocumentoEstudianteUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoCreateOrConnectWithoutCreadoPorInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutCreadoPorInput, DocumentoUncheckedCreateWithoutCreadoPorInput>
  }

  export type DocumentoCreateManyCreadoPorInputEnvelope = {
    data: DocumentoCreateManyCreadoPorInput | DocumentoCreateManyCreadoPorInput[]
  }

  export type EstudianteUpsertWithoutUsuarioInput = {
    update: XOR<EstudianteUpdateWithoutUsuarioInput, EstudianteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EstudianteCreateWithoutUsuarioInput, EstudianteUncheckedCreateWithoutUsuarioInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutUsuarioInput, EstudianteUncheckedUpdateWithoutUsuarioInput>
  }

  export type EstudianteUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carrera?: CarreraUpdateOneWithoutEstudiantesNestedInput
    inscripciones?: InscripcionUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type ProfesorUpsertWithoutUsuarioInput = {
    update: XOR<ProfesorUpdateWithoutUsuarioInput, ProfesorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ProfesorCreateWithoutUsuarioInput, ProfesorUncheckedCreateWithoutUsuarioInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutUsuarioInput, ProfesorUncheckedUpdateWithoutUsuarioInput>
  }

  export type ProfesorUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type AdministradorUpsertWithoutUsuarioInput = {
    update: XOR<AdministradorUpdateWithoutUsuarioInput, AdministradorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AdministradorCreateWithoutUsuarioInput, AdministradorUncheckedCreateWithoutUsuarioInput>
    where?: AdministradorWhereInput
  }

  export type AdministradorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: AdministradorWhereInput
    data: XOR<AdministradorUpdateWithoutUsuarioInput, AdministradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdministradorUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministradorUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenSesionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: TokenSesionWhereUniqueInput
    update: XOR<TokenSesionUpdateWithoutUsuarioInput, TokenSesionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TokenSesionCreateWithoutUsuarioInput, TokenSesionUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenSesionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: TokenSesionWhereUniqueInput
    data: XOR<TokenSesionUpdateWithoutUsuarioInput, TokenSesionUncheckedUpdateWithoutUsuarioInput>
  }

  export type TokenSesionUpdateManyWithWhereWithoutUsuarioInput = {
    where: TokenSesionScalarWhereInput
    data: XOR<TokenSesionUpdateManyMutationInput, TokenSesionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type TokenSesionScalarWhereInput = {
    AND?: TokenSesionScalarWhereInput | TokenSesionScalarWhereInput[]
    OR?: TokenSesionScalarWhereInput[]
    NOT?: TokenSesionScalarWhereInput | TokenSesionScalarWhereInput[]
    id?: StringFilter<"TokenSesion"> | string
    token?: StringFilter<"TokenSesion"> | string
    tipo?: EnumTipoTokenFilter<"TokenSesion"> | $Enums.TipoToken
    expiraEn?: DateTimeFilter<"TokenSesion"> | Date | string
    revocado?: BoolFilter<"TokenSesion"> | boolean
    ipAddress?: StringNullableFilter<"TokenSesion"> | string | null
    userAgent?: StringNullableFilter<"TokenSesion"> | string | null
    usuarioId?: StringFilter<"TokenSesion"> | string
    createdAt?: DateTimeFilter<"TokenSesion"> | Date | string
  }

  export type ActividadUsuarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ActividadUsuarioWhereUniqueInput
    update: XOR<ActividadUsuarioUpdateWithoutUsuarioInput, ActividadUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ActividadUsuarioCreateWithoutUsuarioInput, ActividadUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ActividadUsuarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ActividadUsuarioWhereUniqueInput
    data: XOR<ActividadUsuarioUpdateWithoutUsuarioInput, ActividadUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ActividadUsuarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: ActividadUsuarioScalarWhereInput
    data: XOR<ActividadUsuarioUpdateManyMutationInput, ActividadUsuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ActividadUsuarioScalarWhereInput = {
    AND?: ActividadUsuarioScalarWhereInput | ActividadUsuarioScalarWhereInput[]
    OR?: ActividadUsuarioScalarWhereInput[]
    NOT?: ActividadUsuarioScalarWhereInput | ActividadUsuarioScalarWhereInput[]
    id?: StringFilter<"ActividadUsuario"> | string
    accion?: StringFilter<"ActividadUsuario"> | string
    entidad?: StringNullableFilter<"ActividadUsuario"> | string | null
    entidadId?: StringNullableFilter<"ActividadUsuario"> | string | null
    descripcion?: StringNullableFilter<"ActividadUsuario"> | string | null
    ipAddress?: StringNullableFilter<"ActividadUsuario"> | string | null
    userAgent?: StringNullableFilter<"ActividadUsuario"> | string | null
    usuarioId?: StringFilter<"ActividadUsuario"> | string
    createdAt?: DateTimeFilter<"ActividadUsuario"> | Date | string
  }

  export type DocumentoUpsertWithWhereUniqueWithoutCreadoPorInput = {
    where: DocumentoWhereUniqueInput
    update: XOR<DocumentoUpdateWithoutCreadoPorInput, DocumentoUncheckedUpdateWithoutCreadoPorInput>
    create: XOR<DocumentoCreateWithoutCreadoPorInput, DocumentoUncheckedCreateWithoutCreadoPorInput>
  }

  export type DocumentoUpdateWithWhereUniqueWithoutCreadoPorInput = {
    where: DocumentoWhereUniqueInput
    data: XOR<DocumentoUpdateWithoutCreadoPorInput, DocumentoUncheckedUpdateWithoutCreadoPorInput>
  }

  export type DocumentoUpdateManyWithWhereWithoutCreadoPorInput = {
    where: DocumentoScalarWhereInput
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyWithoutCreadoPorInput>
  }

  export type DocumentoScalarWhereInput = {
    AND?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
    OR?: DocumentoScalarWhereInput[]
    NOT?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
    id?: StringFilter<"Documento"> | string
    folio?: StringFilter<"Documento"> | string
    tipo?: EnumTipoDocumentoFilter<"Documento"> | $Enums.TipoDocumento
    titulo?: StringFilter<"Documento"> | string
    descripcion?: StringNullableFilter<"Documento"> | string | null
    rutaArchivo?: StringFilter<"Documento"> | string
    rutaArchivoFirmado?: StringNullableFilter<"Documento"> | string | null
    hashArchivo?: StringFilter<"Documento"> | string
    tamanoBytes?: IntFilter<"Documento"> | number
    mimeType?: StringFilter<"Documento"> | string
    estatus?: EnumEstatusDocumentoFilter<"Documento"> | $Enums.EstatusDocumento
    fechaEmision?: DateTimeNullableFilter<"Documento"> | Date | string | null
    fechaVencimiento?: DateTimeNullableFilter<"Documento"> | Date | string | null
    validado?: BoolFilter<"Documento"> | boolean
    firmado?: BoolFilter<"Documento"> | boolean
    cadenaBlockchain?: StringNullableFilter<"Documento"> | string | null
    qrCode?: StringNullableFilter<"Documento"> | string | null
    creadoPorId?: StringFilter<"Documento"> | string
    createdAt?: DateTimeFilter<"Documento"> | Date | string
    updatedAt?: DateTimeFilter<"Documento"> | Date | string
  }

  export type UsuarioCreateWithoutTokensInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorCreateNestedOneWithoutUsuarioInput
    actividades?: ActividadUsuarioCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUncheckedCreateWithoutTokensInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorUncheckedCreateNestedOneWithoutUsuarioInput
    actividades?: ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioCreateOrConnectWithoutTokensInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTokensInput, UsuarioUncheckedCreateWithoutTokensInput>
  }

  export type UsuarioUpsertWithoutTokensInput = {
    update: XOR<UsuarioUpdateWithoutTokensInput, UsuarioUncheckedUpdateWithoutTokensInput>
    create: XOR<UsuarioCreateWithoutTokensInput, UsuarioUncheckedCreateWithoutTokensInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTokensInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTokensInput, UsuarioUncheckedUpdateWithoutTokensInput>
  }

  export type UsuarioUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUpdateOneWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioCreateWithoutEstudianteInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor?: ProfesorCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUncheckedCreateWithoutEstudianteInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorUncheckedCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioCreateOrConnectWithoutEstudianteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
  }

  export type CarreraCreateWithoutEstudiantesInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materias?: MateriaCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateWithoutEstudiantesInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materias?: MateriaUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraCreateOrConnectWithoutEstudiantesInput = {
    where: CarreraWhereUniqueInput
    create: XOR<CarreraCreateWithoutEstudiantesInput, CarreraUncheckedCreateWithoutEstudiantesInput>
  }

  export type InscripcionCreateWithoutEstudianteInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    grupo: GrupoCreateNestedOneWithoutInscripcionesInput
    calificacion?: CalificacionCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutEstudianteInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    grupoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calificacion?: CalificacionUncheckedCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutEstudianteInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutEstudianteInput, InscripcionUncheckedCreateWithoutEstudianteInput>
  }

  export type InscripcionCreateManyEstudianteInputEnvelope = {
    data: InscripcionCreateManyEstudianteInput | InscripcionCreateManyEstudianteInput[]
  }

  export type CalificacionCreateWithoutEstudianteInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materia: MateriaCreateNestedOneWithoutCalificacionesInput
    inscripcion: InscripcionCreateNestedOneWithoutCalificacionInput
  }

  export type CalificacionUncheckedCreateWithoutEstudianteInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    materiaId: string
    inscripcionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionCreateOrConnectWithoutEstudianteInput = {
    where: CalificacionWhereUniqueInput
    create: XOR<CalificacionCreateWithoutEstudianteInput, CalificacionUncheckedCreateWithoutEstudianteInput>
  }

  export type CalificacionCreateManyEstudianteInputEnvelope = {
    data: CalificacionCreateManyEstudianteInput | CalificacionCreateManyEstudianteInput[]
  }

  export type DocumentoEstudianteCreateWithoutEstudianteInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    createdAt?: Date | string
    documento: DocumentoCreateNestedOneWithoutDocumentosEstudianteInput
  }

  export type DocumentoEstudianteUncheckedCreateWithoutEstudianteInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    documentoId: string
    createdAt?: Date | string
  }

  export type DocumentoEstudianteCreateOrConnectWithoutEstudianteInput = {
    where: DocumentoEstudianteWhereUniqueInput
    create: XOR<DocumentoEstudianteCreateWithoutEstudianteInput, DocumentoEstudianteUncheckedCreateWithoutEstudianteInput>
  }

  export type DocumentoEstudianteCreateManyEstudianteInputEnvelope = {
    data: DocumentoEstudianteCreateManyEstudianteInput | DocumentoEstudianteCreateManyEstudianteInput[]
  }

  export type NotificacionCreateWithoutEstudianteInput = {
    id?: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida?: boolean
    documentoId?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUncheckedCreateWithoutEstudianteInput = {
    id?: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida?: boolean
    documentoId?: string | null
    createdAt?: Date | string
  }

  export type NotificacionCreateOrConnectWithoutEstudianteInput = {
    where: NotificacionWhereUniqueInput
    create: XOR<NotificacionCreateWithoutEstudianteInput, NotificacionUncheckedCreateWithoutEstudianteInput>
  }

  export type NotificacionCreateManyEstudianteInputEnvelope = {
    data: NotificacionCreateManyEstudianteInput | NotificacionCreateManyEstudianteInput[]
  }

  export type UsuarioUpsertWithoutEstudianteInput = {
    update: XOR<UsuarioUpdateWithoutEstudianteInput, UsuarioUncheckedUpdateWithoutEstudianteInput>
    create: XOR<UsuarioCreateWithoutEstudianteInput, UsuarioUncheckedCreateWithoutEstudianteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEstudianteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEstudianteInput, UsuarioUncheckedUpdateWithoutEstudianteInput>
  }

  export type UsuarioUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type CarreraUpsertWithoutEstudiantesInput = {
    update: XOR<CarreraUpdateWithoutEstudiantesInput, CarreraUncheckedUpdateWithoutEstudiantesInput>
    create: XOR<CarreraCreateWithoutEstudiantesInput, CarreraUncheckedCreateWithoutEstudiantesInput>
    where?: CarreraWhereInput
  }

  export type CarreraUpdateToOneWithWhereWithoutEstudiantesInput = {
    where?: CarreraWhereInput
    data: XOR<CarreraUpdateWithoutEstudiantesInput, CarreraUncheckedUpdateWithoutEstudiantesInput>
  }

  export type CarreraUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materias?: MateriaUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materias?: MateriaUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type InscripcionUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: InscripcionWhereUniqueInput
    update: XOR<InscripcionUpdateWithoutEstudianteInput, InscripcionUncheckedUpdateWithoutEstudianteInput>
    create: XOR<InscripcionCreateWithoutEstudianteInput, InscripcionUncheckedCreateWithoutEstudianteInput>
  }

  export type InscripcionUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: InscripcionWhereUniqueInput
    data: XOR<InscripcionUpdateWithoutEstudianteInput, InscripcionUncheckedUpdateWithoutEstudianteInput>
  }

  export type InscripcionUpdateManyWithWhereWithoutEstudianteInput = {
    where: InscripcionScalarWhereInput
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type InscripcionScalarWhereInput = {
    AND?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
    OR?: InscripcionScalarWhereInput[]
    NOT?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
    id?: StringFilter<"Inscripcion"> | string
    periodo?: StringFilter<"Inscripcion"> | string
    estatus?: EnumEstatusInscripcionFilter<"Inscripcion"> | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFilter<"Inscripcion"> | Date | string
    estudianteId?: StringFilter<"Inscripcion"> | string
    grupoId?: StringFilter<"Inscripcion"> | string
    createdAt?: DateTimeFilter<"Inscripcion"> | Date | string
    updatedAt?: DateTimeFilter<"Inscripcion"> | Date | string
  }

  export type CalificacionUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: CalificacionWhereUniqueInput
    update: XOR<CalificacionUpdateWithoutEstudianteInput, CalificacionUncheckedUpdateWithoutEstudianteInput>
    create: XOR<CalificacionCreateWithoutEstudianteInput, CalificacionUncheckedCreateWithoutEstudianteInput>
  }

  export type CalificacionUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: CalificacionWhereUniqueInput
    data: XOR<CalificacionUpdateWithoutEstudianteInput, CalificacionUncheckedUpdateWithoutEstudianteInput>
  }

  export type CalificacionUpdateManyWithWhereWithoutEstudianteInput = {
    where: CalificacionScalarWhereInput
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type CalificacionScalarWhereInput = {
    AND?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
    OR?: CalificacionScalarWhereInput[]
    NOT?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
    id?: StringFilter<"Calificacion"> | string
    calificacion?: FloatFilter<"Calificacion"> | number
    estatus?: StringFilter<"Calificacion"> | string
    observaciones?: StringNullableFilter<"Calificacion"> | string | null
    estudianteId?: StringFilter<"Calificacion"> | string
    materiaId?: StringFilter<"Calificacion"> | string
    inscripcionId?: StringFilter<"Calificacion"> | string
    createdAt?: DateTimeFilter<"Calificacion"> | Date | string
    updatedAt?: DateTimeFilter<"Calificacion"> | Date | string
  }

  export type DocumentoEstudianteUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: DocumentoEstudianteWhereUniqueInput
    update: XOR<DocumentoEstudianteUpdateWithoutEstudianteInput, DocumentoEstudianteUncheckedUpdateWithoutEstudianteInput>
    create: XOR<DocumentoEstudianteCreateWithoutEstudianteInput, DocumentoEstudianteUncheckedCreateWithoutEstudianteInput>
  }

  export type DocumentoEstudianteUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: DocumentoEstudianteWhereUniqueInput
    data: XOR<DocumentoEstudianteUpdateWithoutEstudianteInput, DocumentoEstudianteUncheckedUpdateWithoutEstudianteInput>
  }

  export type DocumentoEstudianteUpdateManyWithWhereWithoutEstudianteInput = {
    where: DocumentoEstudianteScalarWhereInput
    data: XOR<DocumentoEstudianteUpdateManyMutationInput, DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type DocumentoEstudianteScalarWhereInput = {
    AND?: DocumentoEstudianteScalarWhereInput | DocumentoEstudianteScalarWhereInput[]
    OR?: DocumentoEstudianteScalarWhereInput[]
    NOT?: DocumentoEstudianteScalarWhereInput | DocumentoEstudianteScalarWhereInput[]
    id?: StringFilter<"DocumentoEstudiante"> | string
    observaciones?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    motivoRechazo?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    revisadoPor?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    fechaRevision?: DateTimeNullableFilter<"DocumentoEstudiante"> | Date | string | null
    escaneoVirus?: BoolFilter<"DocumentoEstudiante"> | boolean
    virusDetectado?: BoolFilter<"DocumentoEstudiante"> | boolean
    nombreVirusDetectado?: StringNullableFilter<"DocumentoEstudiante"> | string | null
    documentoId?: StringFilter<"DocumentoEstudiante"> | string
    estudianteId?: StringFilter<"DocumentoEstudiante"> | string
    createdAt?: DateTimeFilter<"DocumentoEstudiante"> | Date | string
  }

  export type NotificacionUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: NotificacionWhereUniqueInput
    update: XOR<NotificacionUpdateWithoutEstudianteInput, NotificacionUncheckedUpdateWithoutEstudianteInput>
    create: XOR<NotificacionCreateWithoutEstudianteInput, NotificacionUncheckedCreateWithoutEstudianteInput>
  }

  export type NotificacionUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: NotificacionWhereUniqueInput
    data: XOR<NotificacionUpdateWithoutEstudianteInput, NotificacionUncheckedUpdateWithoutEstudianteInput>
  }

  export type NotificacionUpdateManyWithWhereWithoutEstudianteInput = {
    where: NotificacionScalarWhereInput
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    OR?: NotificacionScalarWhereInput[]
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    id?: StringFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionFilter<"Notificacion"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    documentoId?: StringNullableFilter<"Notificacion"> | string | null
    estudianteId?: StringFilter<"Notificacion"> | string
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
  }

  export type EstudianteCreateWithoutCarreraInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    inscripciones?: InscripcionCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutCarreraInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutCarreraInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutCarreraInput, EstudianteUncheckedCreateWithoutCarreraInput>
  }

  export type EstudianteCreateManyCarreraInputEnvelope = {
    data: EstudianteCreateManyCarreraInput | EstudianteCreateManyCarreraInput[]
  }

  export type MateriaCreateWithoutCarreraInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoCreateNestedManyWithoutMateriaInput
    calificaciones?: CalificacionCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateWithoutCarreraInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoUncheckedCreateNestedManyWithoutMateriaInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaCreateOrConnectWithoutCarreraInput = {
    where: MateriaWhereUniqueInput
    create: XOR<MateriaCreateWithoutCarreraInput, MateriaUncheckedCreateWithoutCarreraInput>
  }

  export type MateriaCreateManyCarreraInputEnvelope = {
    data: MateriaCreateManyCarreraInput | MateriaCreateManyCarreraInput[]
  }

  export type EstudianteUpsertWithWhereUniqueWithoutCarreraInput = {
    where: EstudianteWhereUniqueInput
    update: XOR<EstudianteUpdateWithoutCarreraInput, EstudianteUncheckedUpdateWithoutCarreraInput>
    create: XOR<EstudianteCreateWithoutCarreraInput, EstudianteUncheckedCreateWithoutCarreraInput>
  }

  export type EstudianteUpdateWithWhereUniqueWithoutCarreraInput = {
    where: EstudianteWhereUniqueInput
    data: XOR<EstudianteUpdateWithoutCarreraInput, EstudianteUncheckedUpdateWithoutCarreraInput>
  }

  export type EstudianteUpdateManyWithWhereWithoutCarreraInput = {
    where: EstudianteScalarWhereInput
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyWithoutCarreraInput>
  }

  export type EstudianteScalarWhereInput = {
    AND?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
    OR?: EstudianteScalarWhereInput[]
    NOT?: EstudianteScalarWhereInput | EstudianteScalarWhereInput[]
    id?: StringFilter<"Estudiante"> | string
    matricula?: StringFilter<"Estudiante"> | string
    fechaNacimiento?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    curp?: StringNullableFilter<"Estudiante"> | string | null
    nss?: StringNullableFilter<"Estudiante"> | string | null
    direccion?: StringNullableFilter<"Estudiante"> | string | null
    ciudad?: StringNullableFilter<"Estudiante"> | string | null
    estado?: StringNullableFilter<"Estudiante"> | string | null
    codigoPostal?: StringNullableFilter<"Estudiante"> | string | null
    tutorNombre?: StringNullableFilter<"Estudiante"> | string | null
    tutorTelefono?: StringNullableFilter<"Estudiante"> | string | null
    tutorEmail?: StringNullableFilter<"Estudiante"> | string | null
    estatus?: EnumEstatusEstudianteFilter<"Estudiante"> | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFilter<"Estudiante"> | Date | string
    fechaEgreso?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    usuarioId?: StringFilter<"Estudiante"> | string
    carreraId?: StringNullableFilter<"Estudiante"> | string | null
    createdAt?: DateTimeFilter<"Estudiante"> | Date | string
    updatedAt?: DateTimeFilter<"Estudiante"> | Date | string
  }

  export type MateriaUpsertWithWhereUniqueWithoutCarreraInput = {
    where: MateriaWhereUniqueInput
    update: XOR<MateriaUpdateWithoutCarreraInput, MateriaUncheckedUpdateWithoutCarreraInput>
    create: XOR<MateriaCreateWithoutCarreraInput, MateriaUncheckedCreateWithoutCarreraInput>
  }

  export type MateriaUpdateWithWhereUniqueWithoutCarreraInput = {
    where: MateriaWhereUniqueInput
    data: XOR<MateriaUpdateWithoutCarreraInput, MateriaUncheckedUpdateWithoutCarreraInput>
  }

  export type MateriaUpdateManyWithWhereWithoutCarreraInput = {
    where: MateriaScalarWhereInput
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyWithoutCarreraInput>
  }

  export type MateriaScalarWhereInput = {
    AND?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
    OR?: MateriaScalarWhereInput[]
    NOT?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
    id?: StringFilter<"Materia"> | string
    clave?: StringFilter<"Materia"> | string
    nombre?: StringFilter<"Materia"> | string
    descripcion?: StringNullableFilter<"Materia"> | string | null
    creditos?: IntFilter<"Materia"> | number
    semestre?: IntFilter<"Materia"> | number
    horasTeoria?: IntFilter<"Materia"> | number
    horasPractica?: IntFilter<"Materia"> | number
    activo?: BoolFilter<"Materia"> | boolean
    carreraId?: StringFilter<"Materia"> | string
    createdAt?: DateTimeFilter<"Materia"> | Date | string
    updatedAt?: DateTimeFilter<"Materia"> | Date | string
  }

  export type CarreraCreateWithoutMateriasInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiantes?: EstudianteCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateWithoutMateriasInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    duracionSemestres: number
    creditos: number
    modalidad: $Enums.Modalidad
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiantes?: EstudianteUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraCreateOrConnectWithoutMateriasInput = {
    where: CarreraWhereUniqueInput
    create: XOR<CarreraCreateWithoutMateriasInput, CarreraUncheckedCreateWithoutMateriasInput>
  }

  export type GrupoCreateWithoutMateriaInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutGruposInput
    inscripciones?: InscripcionCreateNestedManyWithoutGrupoInput
  }

  export type GrupoUncheckedCreateWithoutMateriaInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    profesorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type GrupoCreateOrConnectWithoutMateriaInput = {
    where: GrupoWhereUniqueInput
    create: XOR<GrupoCreateWithoutMateriaInput, GrupoUncheckedCreateWithoutMateriaInput>
  }

  export type GrupoCreateManyMateriaInputEnvelope = {
    data: GrupoCreateManyMateriaInput | GrupoCreateManyMateriaInput[]
  }

  export type CalificacionCreateWithoutMateriaInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutCalificacionesInput
    inscripcion: InscripcionCreateNestedOneWithoutCalificacionInput
  }

  export type CalificacionUncheckedCreateWithoutMateriaInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    estudianteId: string
    inscripcionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionCreateOrConnectWithoutMateriaInput = {
    where: CalificacionWhereUniqueInput
    create: XOR<CalificacionCreateWithoutMateriaInput, CalificacionUncheckedCreateWithoutMateriaInput>
  }

  export type CalificacionCreateManyMateriaInputEnvelope = {
    data: CalificacionCreateManyMateriaInput | CalificacionCreateManyMateriaInput[]
  }

  export type CarreraUpsertWithoutMateriasInput = {
    update: XOR<CarreraUpdateWithoutMateriasInput, CarreraUncheckedUpdateWithoutMateriasInput>
    create: XOR<CarreraCreateWithoutMateriasInput, CarreraUncheckedCreateWithoutMateriasInput>
    where?: CarreraWhereInput
  }

  export type CarreraUpdateToOneWithWhereWithoutMateriasInput = {
    where?: CarreraWhereInput
    data: XOR<CarreraUpdateWithoutMateriasInput, CarreraUncheckedUpdateWithoutMateriasInput>
  }

  export type CarreraUpdateWithoutMateriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: EstudianteUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateWithoutMateriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    duracionSemestres?: IntFieldUpdateOperationsInput | number
    creditos?: IntFieldUpdateOperationsInput | number
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: EstudianteUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type GrupoUpsertWithWhereUniqueWithoutMateriaInput = {
    where: GrupoWhereUniqueInput
    update: XOR<GrupoUpdateWithoutMateriaInput, GrupoUncheckedUpdateWithoutMateriaInput>
    create: XOR<GrupoCreateWithoutMateriaInput, GrupoUncheckedCreateWithoutMateriaInput>
  }

  export type GrupoUpdateWithWhereUniqueWithoutMateriaInput = {
    where: GrupoWhereUniqueInput
    data: XOR<GrupoUpdateWithoutMateriaInput, GrupoUncheckedUpdateWithoutMateriaInput>
  }

  export type GrupoUpdateManyWithWhereWithoutMateriaInput = {
    where: GrupoScalarWhereInput
    data: XOR<GrupoUpdateManyMutationInput, GrupoUncheckedUpdateManyWithoutMateriaInput>
  }

  export type GrupoScalarWhereInput = {
    AND?: GrupoScalarWhereInput | GrupoScalarWhereInput[]
    OR?: GrupoScalarWhereInput[]
    NOT?: GrupoScalarWhereInput | GrupoScalarWhereInput[]
    id?: StringFilter<"Grupo"> | string
    clave?: StringFilter<"Grupo"> | string
    periodo?: StringFilter<"Grupo"> | string
    cupoMaximo?: IntFilter<"Grupo"> | number
    cupoDisponible?: IntFilter<"Grupo"> | number
    horario?: StringFilter<"Grupo"> | string
    aula?: StringNullableFilter<"Grupo"> | string | null
    activo?: BoolFilter<"Grupo"> | boolean
    materiaId?: StringFilter<"Grupo"> | string
    profesorId?: StringFilter<"Grupo"> | string
    createdAt?: DateTimeFilter<"Grupo"> | Date | string
    updatedAt?: DateTimeFilter<"Grupo"> | Date | string
  }

  export type CalificacionUpsertWithWhereUniqueWithoutMateriaInput = {
    where: CalificacionWhereUniqueInput
    update: XOR<CalificacionUpdateWithoutMateriaInput, CalificacionUncheckedUpdateWithoutMateriaInput>
    create: XOR<CalificacionCreateWithoutMateriaInput, CalificacionUncheckedCreateWithoutMateriaInput>
  }

  export type CalificacionUpdateWithWhereUniqueWithoutMateriaInput = {
    where: CalificacionWhereUniqueInput
    data: XOR<CalificacionUpdateWithoutMateriaInput, CalificacionUncheckedUpdateWithoutMateriaInput>
  }

  export type CalificacionUpdateManyWithWhereWithoutMateriaInput = {
    where: CalificacionScalarWhereInput
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyWithoutMateriaInput>
  }

  export type MateriaCreateWithoutGruposInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    carrera: CarreraCreateNestedOneWithoutMateriasInput
    calificaciones?: CalificacionCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateWithoutGruposInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    carreraId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaCreateOrConnectWithoutGruposInput = {
    where: MateriaWhereUniqueInput
    create: XOR<MateriaCreateWithoutGruposInput, MateriaUncheckedCreateWithoutGruposInput>
  }

  export type ProfesorCreateWithoutGruposInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutGruposInput = {
    id?: string
    numeroEmpleado: string
    especialidad?: string | null
    grado?: string | null
    departamento?: string | null
    activo?: boolean
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfesorCreateOrConnectWithoutGruposInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutGruposInput, ProfesorUncheckedCreateWithoutGruposInput>
  }

  export type InscripcionCreateWithoutGrupoInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutInscripcionesInput
    calificacion?: CalificacionCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutGrupoInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    estudianteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calificacion?: CalificacionUncheckedCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutGrupoInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutGrupoInput, InscripcionUncheckedCreateWithoutGrupoInput>
  }

  export type InscripcionCreateManyGrupoInputEnvelope = {
    data: InscripcionCreateManyGrupoInput | InscripcionCreateManyGrupoInput[]
  }

  export type MateriaUpsertWithoutGruposInput = {
    update: XOR<MateriaUpdateWithoutGruposInput, MateriaUncheckedUpdateWithoutGruposInput>
    create: XOR<MateriaCreateWithoutGruposInput, MateriaUncheckedCreateWithoutGruposInput>
    where?: MateriaWhereInput
  }

  export type MateriaUpdateToOneWithWhereWithoutGruposInput = {
    where?: MateriaWhereInput
    data: XOR<MateriaUpdateWithoutGruposInput, MateriaUncheckedUpdateWithoutGruposInput>
  }

  export type MateriaUpdateWithoutGruposInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carrera?: CarreraUpdateOneRequiredWithoutMateriasNestedInput
    calificaciones?: CalificacionUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateWithoutGruposInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    carreraId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: CalificacionUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type ProfesorUpsertWithoutGruposInput = {
    update: XOR<ProfesorUpdateWithoutGruposInput, ProfesorUncheckedUpdateWithoutGruposInput>
    create: XOR<ProfesorCreateWithoutGruposInput, ProfesorUncheckedCreateWithoutGruposInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutGruposInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutGruposInput, ProfesorUncheckedUpdateWithoutGruposInput>
  }

  export type ProfesorUpdateWithoutGruposInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutGruposInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEmpleado?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscripcionUpsertWithWhereUniqueWithoutGrupoInput = {
    where: InscripcionWhereUniqueInput
    update: XOR<InscripcionUpdateWithoutGrupoInput, InscripcionUncheckedUpdateWithoutGrupoInput>
    create: XOR<InscripcionCreateWithoutGrupoInput, InscripcionUncheckedCreateWithoutGrupoInput>
  }

  export type InscripcionUpdateWithWhereUniqueWithoutGrupoInput = {
    where: InscripcionWhereUniqueInput
    data: XOR<InscripcionUpdateWithoutGrupoInput, InscripcionUncheckedUpdateWithoutGrupoInput>
  }

  export type InscripcionUpdateManyWithWhereWithoutGrupoInput = {
    where: InscripcionScalarWhereInput
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyWithoutGrupoInput>
  }

  export type EstudianteCreateWithoutInscripcionesInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    carrera?: CarreraCreateNestedOneWithoutEstudiantesInput
    calificaciones?: CalificacionCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutInscripcionesInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutInscripcionesInput, EstudianteUncheckedCreateWithoutInscripcionesInput>
  }

  export type GrupoCreateWithoutInscripcionesInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materia: MateriaCreateNestedOneWithoutGruposInput
    profesor: ProfesorCreateNestedOneWithoutGruposInput
  }

  export type GrupoUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    materiaId: string
    profesorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GrupoCreateOrConnectWithoutInscripcionesInput = {
    where: GrupoWhereUniqueInput
    create: XOR<GrupoCreateWithoutInscripcionesInput, GrupoUncheckedCreateWithoutInscripcionesInput>
  }

  export type CalificacionCreateWithoutInscripcionInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutCalificacionesInput
    materia: MateriaCreateNestedOneWithoutCalificacionesInput
  }

  export type CalificacionUncheckedCreateWithoutInscripcionInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    estudianteId: string
    materiaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionCreateOrConnectWithoutInscripcionInput = {
    where: CalificacionWhereUniqueInput
    create: XOR<CalificacionCreateWithoutInscripcionInput, CalificacionUncheckedCreateWithoutInscripcionInput>
  }

  export type EstudianteUpsertWithoutInscripcionesInput = {
    update: XOR<EstudianteUpdateWithoutInscripcionesInput, EstudianteUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<EstudianteCreateWithoutInscripcionesInput, EstudianteUncheckedCreateWithoutInscripcionesInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutInscripcionesInput, EstudianteUncheckedUpdateWithoutInscripcionesInput>
  }

  export type EstudianteUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    carrera?: CarreraUpdateOneWithoutEstudiantesNestedInput
    calificaciones?: CalificacionUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type GrupoUpsertWithoutInscripcionesInput = {
    update: XOR<GrupoUpdateWithoutInscripcionesInput, GrupoUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<GrupoCreateWithoutInscripcionesInput, GrupoUncheckedCreateWithoutInscripcionesInput>
    where?: GrupoWhereInput
  }

  export type GrupoUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: GrupoWhereInput
    data: XOR<GrupoUpdateWithoutInscripcionesInput, GrupoUncheckedUpdateWithoutInscripcionesInput>
  }

  export type GrupoUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materia?: MateriaUpdateOneRequiredWithoutGruposNestedInput
    profesor?: ProfesorUpdateOneRequiredWithoutGruposNestedInput
  }

  export type GrupoUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    materiaId?: StringFieldUpdateOperationsInput | string
    profesorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUpsertWithoutInscripcionInput = {
    update: XOR<CalificacionUpdateWithoutInscripcionInput, CalificacionUncheckedUpdateWithoutInscripcionInput>
    create: XOR<CalificacionCreateWithoutInscripcionInput, CalificacionUncheckedCreateWithoutInscripcionInput>
    where?: CalificacionWhereInput
  }

  export type CalificacionUpdateToOneWithWhereWithoutInscripcionInput = {
    where?: CalificacionWhereInput
    data: XOR<CalificacionUpdateWithoutInscripcionInput, CalificacionUncheckedUpdateWithoutInscripcionInput>
  }

  export type CalificacionUpdateWithoutInscripcionInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutCalificacionesNestedInput
    materia?: MateriaUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type CalificacionUncheckedUpdateWithoutInscripcionInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    materiaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateWithoutCalificacionesInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    carrera?: CarreraCreateNestedOneWithoutEstudiantesInput
    inscripciones?: InscripcionCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutCalificacionesInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutCalificacionesInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutCalificacionesInput, EstudianteUncheckedCreateWithoutCalificacionesInput>
  }

  export type MateriaCreateWithoutCalificacionesInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    carrera: CarreraCreateNestedOneWithoutMateriasInput
    grupos?: GrupoCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateWithoutCalificacionesInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    carreraId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grupos?: GrupoUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaCreateOrConnectWithoutCalificacionesInput = {
    where: MateriaWhereUniqueInput
    create: XOR<MateriaCreateWithoutCalificacionesInput, MateriaUncheckedCreateWithoutCalificacionesInput>
  }

  export type InscripcionCreateWithoutCalificacionInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutInscripcionesInput
    grupo: GrupoCreateNestedOneWithoutInscripcionesInput
  }

  export type InscripcionUncheckedCreateWithoutCalificacionInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    estudianteId: string
    grupoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscripcionCreateOrConnectWithoutCalificacionInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutCalificacionInput, InscripcionUncheckedCreateWithoutCalificacionInput>
  }

  export type EstudianteUpsertWithoutCalificacionesInput = {
    update: XOR<EstudianteUpdateWithoutCalificacionesInput, EstudianteUncheckedUpdateWithoutCalificacionesInput>
    create: XOR<EstudianteCreateWithoutCalificacionesInput, EstudianteUncheckedCreateWithoutCalificacionesInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutCalificacionesInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutCalificacionesInput, EstudianteUncheckedUpdateWithoutCalificacionesInput>
  }

  export type EstudianteUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    carrera?: CarreraUpdateOneWithoutEstudiantesNestedInput
    inscripciones?: InscripcionUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type MateriaUpsertWithoutCalificacionesInput = {
    update: XOR<MateriaUpdateWithoutCalificacionesInput, MateriaUncheckedUpdateWithoutCalificacionesInput>
    create: XOR<MateriaCreateWithoutCalificacionesInput, MateriaUncheckedCreateWithoutCalificacionesInput>
    where?: MateriaWhereInput
  }

  export type MateriaUpdateToOneWithWhereWithoutCalificacionesInput = {
    where?: MateriaWhereInput
    data: XOR<MateriaUpdateWithoutCalificacionesInput, MateriaUncheckedUpdateWithoutCalificacionesInput>
  }

  export type MateriaUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carrera?: CarreraUpdateOneRequiredWithoutMateriasNestedInput
    grupos?: GrupoUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    carreraId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type InscripcionUpsertWithoutCalificacionInput = {
    update: XOR<InscripcionUpdateWithoutCalificacionInput, InscripcionUncheckedUpdateWithoutCalificacionInput>
    create: XOR<InscripcionCreateWithoutCalificacionInput, InscripcionUncheckedCreateWithoutCalificacionInput>
    where?: InscripcionWhereInput
  }

  export type InscripcionUpdateToOneWithWhereWithoutCalificacionInput = {
    where?: InscripcionWhereInput
    data: XOR<InscripcionUpdateWithoutCalificacionInput, InscripcionUncheckedUpdateWithoutCalificacionInput>
  }

  export type InscripcionUpdateWithoutCalificacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutInscripcionesNestedInput
    grupo?: GrupoUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutCalificacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    grupoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateWithoutProfesorInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUncheckedCreateWithoutProfesorInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorUncheckedCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioCreateOrConnectWithoutProfesorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProfesorInput, UsuarioUncheckedCreateWithoutProfesorInput>
  }

  export type GrupoCreateWithoutProfesorInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materia: MateriaCreateNestedOneWithoutGruposInput
    inscripciones?: InscripcionCreateNestedManyWithoutGrupoInput
  }

  export type GrupoUncheckedCreateWithoutProfesorInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    materiaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type GrupoCreateOrConnectWithoutProfesorInput = {
    where: GrupoWhereUniqueInput
    create: XOR<GrupoCreateWithoutProfesorInput, GrupoUncheckedCreateWithoutProfesorInput>
  }

  export type GrupoCreateManyProfesorInputEnvelope = {
    data: GrupoCreateManyProfesorInput | GrupoCreateManyProfesorInput[]
  }

  export type UsuarioUpsertWithoutProfesorInput = {
    update: XOR<UsuarioUpdateWithoutProfesorInput, UsuarioUncheckedUpdateWithoutProfesorInput>
    create: XOR<UsuarioCreateWithoutProfesorInput, UsuarioUncheckedCreateWithoutProfesorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutProfesorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutProfesorInput, UsuarioUncheckedUpdateWithoutProfesorInput>
  }

  export type UsuarioUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type GrupoUpsertWithWhereUniqueWithoutProfesorInput = {
    where: GrupoWhereUniqueInput
    update: XOR<GrupoUpdateWithoutProfesorInput, GrupoUncheckedUpdateWithoutProfesorInput>
    create: XOR<GrupoCreateWithoutProfesorInput, GrupoUncheckedCreateWithoutProfesorInput>
  }

  export type GrupoUpdateWithWhereUniqueWithoutProfesorInput = {
    where: GrupoWhereUniqueInput
    data: XOR<GrupoUpdateWithoutProfesorInput, GrupoUncheckedUpdateWithoutProfesorInput>
  }

  export type GrupoUpdateManyWithWhereWithoutProfesorInput = {
    where: GrupoScalarWhereInput
    data: XOR<GrupoUpdateManyMutationInput, GrupoUncheckedUpdateManyWithoutProfesorInput>
  }

  export type UsuarioCreateWithoutAdministradorInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUncheckedCreateWithoutAdministradorInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioCreateOrConnectWithoutAdministradorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAdministradorInput, UsuarioUncheckedCreateWithoutAdministradorInput>
  }

  export type UsuarioUpsertWithoutAdministradorInput = {
    update: XOR<UsuarioUpdateWithoutAdministradorInput, UsuarioUncheckedUpdateWithoutAdministradorInput>
    create: XOR<UsuarioCreateWithoutAdministradorInput, UsuarioUncheckedCreateWithoutAdministradorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAdministradorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAdministradorInput, UsuarioUncheckedUpdateWithoutAdministradorInput>
  }

  export type UsuarioUpdateWithoutAdministradorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAdministradorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioCreateWithoutDocumentosCreadosInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDocumentosCreadosInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorUncheckedCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput
    actividades?: ActividadUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDocumentosCreadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDocumentosCreadosInput, UsuarioUncheckedCreateWithoutDocumentosCreadosInput>
  }

  export type DocumentoEstudianteCreateWithoutDocumentoInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    createdAt?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutDocumentosInput
  }

  export type DocumentoEstudianteUncheckedCreateWithoutDocumentoInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    estudianteId: string
    createdAt?: Date | string
  }

  export type DocumentoEstudianteCreateOrConnectWithoutDocumentoInput = {
    where: DocumentoEstudianteWhereUniqueInput
    create: XOR<DocumentoEstudianteCreateWithoutDocumentoInput, DocumentoEstudianteUncheckedCreateWithoutDocumentoInput>
  }

  export type DocumentoEstudianteCreateManyDocumentoInputEnvelope = {
    data: DocumentoEstudianteCreateManyDocumentoInput | DocumentoEstudianteCreateManyDocumentoInput[]
  }

  export type UsuarioUpsertWithoutDocumentosCreadosInput = {
    update: XOR<UsuarioUpdateWithoutDocumentosCreadosInput, UsuarioUncheckedUpdateWithoutDocumentosCreadosInput>
    create: XOR<UsuarioCreateWithoutDocumentosCreadosInput, UsuarioUncheckedCreateWithoutDocumentosCreadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutDocumentosCreadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutDocumentosCreadosInput, UsuarioUncheckedUpdateWithoutDocumentosCreadosInput>
  }

  export type UsuarioUpdateWithoutDocumentosCreadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDocumentosCreadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput
    actividades?: ActividadUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type DocumentoEstudianteUpsertWithWhereUniqueWithoutDocumentoInput = {
    where: DocumentoEstudianteWhereUniqueInput
    update: XOR<DocumentoEstudianteUpdateWithoutDocumentoInput, DocumentoEstudianteUncheckedUpdateWithoutDocumentoInput>
    create: XOR<DocumentoEstudianteCreateWithoutDocumentoInput, DocumentoEstudianteUncheckedCreateWithoutDocumentoInput>
  }

  export type DocumentoEstudianteUpdateWithWhereUniqueWithoutDocumentoInput = {
    where: DocumentoEstudianteWhereUniqueInput
    data: XOR<DocumentoEstudianteUpdateWithoutDocumentoInput, DocumentoEstudianteUncheckedUpdateWithoutDocumentoInput>
  }

  export type DocumentoEstudianteUpdateManyWithWhereWithoutDocumentoInput = {
    where: DocumentoEstudianteScalarWhereInput
    data: XOR<DocumentoEstudianteUpdateManyMutationInput, DocumentoEstudianteUncheckedUpdateManyWithoutDocumentoInput>
  }

  export type DocumentoCreateWithoutDocumentosEstudianteInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creadoPor: UsuarioCreateNestedOneWithoutDocumentosCreadosInput
  }

  export type DocumentoUncheckedCreateWithoutDocumentosEstudianteInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    creadoPorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoCreateOrConnectWithoutDocumentosEstudianteInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutDocumentosEstudianteInput, DocumentoUncheckedCreateWithoutDocumentosEstudianteInput>
  }

  export type EstudianteCreateWithoutDocumentosInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    carrera?: CarreraCreateNestedOneWithoutEstudiantesInput
    inscripciones?: InscripcionCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutDocumentosInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutDocumentosInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutDocumentosInput, EstudianteUncheckedCreateWithoutDocumentosInput>
  }

  export type DocumentoUpsertWithoutDocumentosEstudianteInput = {
    update: XOR<DocumentoUpdateWithoutDocumentosEstudianteInput, DocumentoUncheckedUpdateWithoutDocumentosEstudianteInput>
    create: XOR<DocumentoCreateWithoutDocumentosEstudianteInput, DocumentoUncheckedCreateWithoutDocumentosEstudianteInput>
    where?: DocumentoWhereInput
  }

  export type DocumentoUpdateToOneWithWhereWithoutDocumentosEstudianteInput = {
    where?: DocumentoWhereInput
    data: XOR<DocumentoUpdateWithoutDocumentosEstudianteInput, DocumentoUncheckedUpdateWithoutDocumentosEstudianteInput>
  }

  export type DocumentoUpdateWithoutDocumentosEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCreadosNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutDocumentosEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    creadoPorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteUpsertWithoutDocumentosInput = {
    update: XOR<EstudianteUpdateWithoutDocumentosInput, EstudianteUncheckedUpdateWithoutDocumentosInput>
    create: XOR<EstudianteCreateWithoutDocumentosInput, EstudianteUncheckedCreateWithoutDocumentosInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutDocumentosInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutDocumentosInput, EstudianteUncheckedUpdateWithoutDocumentosInput>
  }

  export type EstudianteUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    carrera?: CarreraUpdateOneWithoutEstudiantesNestedInput
    inscripciones?: InscripcionUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteCreateWithoutNotificacionesInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEstudianteInput
    carrera?: CarreraCreateNestedOneWithoutEstudiantesInput
    inscripciones?: InscripcionCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutNotificacionesInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    carreraId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inscripciones?: InscripcionUncheckedCreateNestedManyWithoutEstudianteInput
    calificaciones?: CalificacionUncheckedCreateNestedManyWithoutEstudianteInput
    documentos?: DocumentoEstudianteUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutNotificacionesInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutNotificacionesInput, EstudianteUncheckedCreateWithoutNotificacionesInput>
  }

  export type EstudianteUpsertWithoutNotificacionesInput = {
    update: XOR<EstudianteUpdateWithoutNotificacionesInput, EstudianteUncheckedUpdateWithoutNotificacionesInput>
    create: XOR<EstudianteCreateWithoutNotificacionesInput, EstudianteUncheckedCreateWithoutNotificacionesInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutNotificacionesInput, EstudianteUncheckedUpdateWithoutNotificacionesInput>
  }

  export type EstudianteUpdateWithoutNotificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    carrera?: CarreraUpdateOneWithoutEstudiantesNestedInput
    inscripciones?: InscripcionUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutNotificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    carreraId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioCreateWithoutActividadesInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioUncheckedCreateWithoutActividadesInput = {
    id?: string
    email: string
    password: string
    nombre: string
    apellidoPaterno: string
    apellidoMaterno?: string | null
    telefono?: string | null
    rol?: $Enums.Rol
    activo?: boolean
    emailVerificado?: boolean
    primerLogin?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    estudiante?: EstudianteUncheckedCreateNestedOneWithoutUsuarioInput
    profesor?: ProfesorUncheckedCreateNestedOneWithoutUsuarioInput
    administrador?: AdministradorUncheckedCreateNestedOneWithoutUsuarioInput
    tokens?: TokenSesionUncheckedCreateNestedManyWithoutUsuarioInput
    documentosCreados?: DocumentoUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UsuarioCreateOrConnectWithoutActividadesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutActividadesInput, UsuarioUncheckedCreateWithoutActividadesInput>
  }

  export type UsuarioUpsertWithoutActividadesInput = {
    update: XOR<UsuarioUpdateWithoutActividadesInput, UsuarioUncheckedUpdateWithoutActividadesInput>
    create: XOR<UsuarioCreateWithoutActividadesInput, UsuarioUncheckedCreateWithoutActividadesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutActividadesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutActividadesInput, UsuarioUncheckedUpdateWithoutActividadesInput>
  }

  export type UsuarioUpdateWithoutActividadesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUpdateManyWithoutCreadoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutActividadesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoPaterno?: StringFieldUpdateOperationsInput | string
    apellidoMaterno?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    activo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    primerLogin?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUncheckedUpdateOneWithoutUsuarioNestedInput
    profesor?: ProfesorUncheckedUpdateOneWithoutUsuarioNestedInput
    administrador?: AdministradorUncheckedUpdateOneWithoutUsuarioNestedInput
    tokens?: TokenSesionUncheckedUpdateManyWithoutUsuarioNestedInput
    documentosCreados?: DocumentoUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type TokenSesionCreateManyUsuarioInput = {
    id?: string
    token: string
    tipo: $Enums.TipoToken
    expiraEn: Date | string
    revocado?: boolean
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActividadUsuarioCreateManyUsuarioInput = {
    id?: string
    accion: string
    entidad?: string | null
    entidadId?: string | null
    descripcion?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DocumentoCreateManyCreadoPorInput = {
    id?: string
    folio: string
    tipo: $Enums.TipoDocumento
    titulo: string
    descripcion?: string | null
    rutaArchivo: string
    rutaArchivoFirmado?: string | null
    hashArchivo: string
    tamanoBytes: number
    mimeType: string
    estatus?: $Enums.EstatusDocumento
    fechaEmision?: Date | string | null
    fechaVencimiento?: Date | string | null
    validado?: boolean
    firmado?: boolean
    cadenaBlockchain?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenSesionUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenSesionUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenSesionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoTokenFieldUpdateOperationsInput | $Enums.TipoToken
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    revocado?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActividadUsuarioUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActividadUsuarioUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActividadUsuarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUpdateWithoutCreadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentosEstudiante?: DocumentoEstudianteUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutCreadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentosEstudiante?: DocumentoEstudianteUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateManyWithoutCreadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    folio?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    rutaArchivoFirmado?: NullableStringFieldUpdateOperationsInput | string | null
    hashArchivo?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusDocumentoFieldUpdateOperationsInput | $Enums.EstatusDocumento
    fechaEmision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validado?: BoolFieldUpdateOperationsInput | boolean
    firmado?: BoolFieldUpdateOperationsInput | boolean
    cadenaBlockchain?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscripcionCreateManyEstudianteInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    grupoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionCreateManyEstudianteInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    materiaId: string
    inscripcionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentoEstudianteCreateManyEstudianteInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    documentoId: string
    createdAt?: Date | string
  }

  export type NotificacionCreateManyEstudianteInput = {
    id?: string
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    leida?: boolean
    documentoId?: string | null
    createdAt?: Date | string
  }

  export type InscripcionUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: GrupoUpdateOneRequiredWithoutInscripcionesNestedInput
    calificacion?: CalificacionUpdateOneWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calificacion?: CalificacionUncheckedUpdateOneWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materia?: MateriaUpdateOneRequiredWithoutCalificacionesNestedInput
    inscripcion?: InscripcionUpdateOneRequiredWithoutCalificacionNestedInput
  }

  export type CalificacionUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    materiaId?: StringFieldUpdateOperationsInput | string
    inscripcionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    materiaId?: StringFieldUpdateOperationsInput | string
    inscripcionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documento?: DocumentoUpdateOneRequiredWithoutDocumentosEstudianteNestedInput
  }

  export type DocumentoEstudianteUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    documentoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    documentoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    documentoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateManyCarreraInput = {
    id?: string
    matricula: string
    fechaNacimiento?: Date | string | null
    curp?: string | null
    nss?: string | null
    direccion?: string | null
    ciudad?: string | null
    estado?: string | null
    codigoPostal?: string | null
    tutorNombre?: string | null
    tutorTelefono?: string | null
    tutorEmail?: string | null
    estatus?: $Enums.EstatusEstudiante
    fechaIngreso?: Date | string
    fechaEgreso?: Date | string | null
    usuarioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriaCreateManyCarreraInput = {
    id?: string
    clave: string
    nombre: string
    descripcion?: string | null
    creditos: number
    semestre: number
    horasTeoria: number
    horasPractica: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EstudianteUpdateWithoutCarreraInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEstudianteNestedInput
    inscripciones?: InscripcionUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutCarreraInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutEstudianteNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutEstudianteNestedInput
    documentos?: DocumentoEstudianteUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateManyWithoutCarreraInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    nss?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    tutorNombre?: NullableStringFieldUpdateOperationsInput | string | null
    tutorTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    tutorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    estatus?: EnumEstatusEstudianteFieldUpdateOperationsInput | $Enums.EstatusEstudiante
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEgreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriaUpdateWithoutCarreraInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUpdateManyWithoutMateriaNestedInput
    calificaciones?: CalificacionUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateWithoutCarreraInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos?: GrupoUncheckedUpdateManyWithoutMateriaNestedInput
    calificaciones?: CalificacionUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateManyWithoutCarreraInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creditos?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    horasTeoria?: IntFieldUpdateOperationsInput | number
    horasPractica?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoCreateManyMateriaInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    profesorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalificacionCreateManyMateriaInput = {
    id?: string
    calificacion: number
    estatus: string
    observaciones?: string | null
    estudianteId: string
    inscripcionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GrupoUpdateWithoutMateriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutGruposNestedInput
    inscripciones?: InscripcionUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoUncheckedUpdateWithoutMateriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    profesorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoUncheckedUpdateManyWithoutMateriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    profesorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUpdateWithoutMateriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutCalificacionesNestedInput
    inscripcion?: InscripcionUpdateOneRequiredWithoutCalificacionNestedInput
  }

  export type CalificacionUncheckedUpdateWithoutMateriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscripcionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUncheckedUpdateManyWithoutMateriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    estatus?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscripcionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscripcionCreateManyGrupoInput = {
    id?: string
    periodo: string
    estatus?: $Enums.EstatusInscripcion
    fechaInscripcion?: Date | string
    estudianteId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscripcionUpdateWithoutGrupoInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutInscripcionesNestedInput
    calificacion?: CalificacionUpdateOneWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutGrupoInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calificacion?: CalificacionUncheckedUpdateOneWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateManyWithoutGrupoInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    estatus?: EnumEstatusInscripcionFieldUpdateOperationsInput | $Enums.EstatusInscripcion
    fechaInscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoCreateManyProfesorInput = {
    id?: string
    clave: string
    periodo: string
    cupoMaximo: number
    cupoDisponible: number
    horario: string
    aula?: string | null
    activo?: boolean
    materiaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GrupoUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materia?: MateriaUpdateOneRequiredWithoutGruposNestedInput
    inscripciones?: InscripcionUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoUncheckedUpdateWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    materiaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripciones?: InscripcionUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoUncheckedUpdateManyWithoutProfesorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    cupoMaximo?: IntFieldUpdateOperationsInput | number
    cupoDisponible?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    materiaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteCreateManyDocumentoInput = {
    id?: string
    observaciones?: string | null
    motivoRechazo?: string | null
    revisadoPor?: string | null
    fechaRevision?: Date | string | null
    escaneoVirus?: boolean
    virusDetectado?: boolean
    nombreVirusDetectado?: string | null
    estudianteId: string
    createdAt?: Date | string
  }

  export type DocumentoEstudianteUpdateWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutDocumentosNestedInput
  }

  export type DocumentoEstudianteUncheckedUpdateWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoEstudianteUncheckedUpdateManyWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    revisadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRevision?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escaneoVirus?: BoolFieldUpdateOperationsInput | boolean
    virusDetectado?: BoolFieldUpdateOperationsInput | boolean
    nombreVirusDetectado?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}